#!/usr/bin/perl

################################################################################
# GPX track converter: post-process routes and tracks produced by GPS loggers etc.
#
# Reads from file(s) given as argument or STDIN and writes to STDOUT or a file.
# Concatenates segments of multiple given tracks or routes (sequential composition),
# using (header) metadata of the first track, preserving segments, and collecting waypoints.
# Can fill gaps in main input by merging data from alternative input (from parallel tracks),
# ignoring metadata and segment information of the alternative input.
#
# Reports missing data and by default ignores points containing implausible data w.r.t.
# altitude, ascent/descent rate, speed, acceleration/deceleration, and direction change.
# Optionally filters out points before or after given time limits.
# Optionally filters out points with an element value below or above given limits.
# Optionally prunes comments, extensions, or extension elements with value below or above given limits.
# By default carries over missing altitude and time data between segments.
# By default fills in missing altitude and time data by interpolation within segments.
# By default inserts interpolated points in long time gaps (default 1800 seconds sufficient for exiftool).
# Optionally corrects elevation and smoothens tracks.
# (Orthometric height = GPS ellipsoidal height - geoid height,
#  see http://www.unavco.org/edu_outreach/tutorial/geoidcorr.html)
# Produces statistics including ascent/descent rates, optionally also for climbing phases.
# Optionally produces additional statistics on a per-segment or per-day basis.
# Optionally calculates approximate total energy spent by biking along the resulting track.
# Prints information (if enabled), any warnings (if enabled), and errors to STDERR.
#

use constant TOOL_NAME    => "GPXConv";
use constant TOOL_VERSION => "2.8.2";
my $TOOL_ID = TOOL_NAME." v".TOOL_VERSION;

my $usage =
"Usage:  gpxconv <option(s) and infile(s)> [> <outfile>]

Command-line options:
  -h | -help | --help          - print these hints and exit
  -version                     - print tool name and version and exit
  -swim, -walk, -cycle, -drive, -fly - type of recorded activity, default: drive
  -no_sanitize                 - do not sanitize trackpoints with implausible data
  -no_insert                   - do not insert trackpoints on long time gaps
  -smooth                      - smoothen tracks
  -phases                      - analyze and provide statistics for ascent/descent phases
  -segs [<n>..[<m>][(+|-)<d>]] - add statistics per segment n..m, may adapt indexes +/-d
  -days [<n>..[<m>][(+|-)<d>]] - add statistics per day n..m, may adapt indexes +/-d
  -merge <file>                - complete gaps in infile(s) by data from given GPX file
  -weight <value>              - calculate biking energy for given weight in kg
  -begin <time>                - ignore points before given time
  -end <time>                  - ignore points after given time
  -min <name> <limit>          - filter out points with element value below limit
  -max <name> <limit>          - filter out points with element value above limit
  -min_ext <name> <limit>      - prune extension elements with value below limit
  -max_ext <name> <limit>      - prune extension elements with value above limit
  -prune_wpts                  - remove waypoints
  -prune_cmts                  - remove comments
  -prune_exts                  - remove extensions
  -nw                          - do not print warnings
  -ni                          - do not print information
  -o <outfile>                 - output the resulting track to <outfile>
  -debug                       - enable internal consistency checks and debug output
Other options can be set by changing values of the configuration variables.

(c) 2012-2024 David von Oheimb - License: MIT - ".TOOL_NAME." version ".TOOL_VERSION;
################################################################################

use strict;
use warnings;
# use feature 'signatures'; # https://perldoc.perl.org/perlsub#Signatures

### configuration variables

my $activity = "-drive"; # default

# basic output control
use constant PRUNE_WPTS           => 0; # by default do not ignore waypoints
use constant PRUNE_AUTOMATIC_WPTS => 1; # ignore waypoints containing <name><!\[CDATA\[\d*\]\]></name>
use constant PRUNE_CMTS           => 0; # by default do not remove comments
use constant PRUNE_DESCS          => 0; # do not remove descriptions
use constant PRUNE_LINKS          => 0; # do not remove links
use constant PRUNE_EXTENSIONS     => 0; # by default do not remove extensions
use constant PRUNE_RECORDED_SPEED => 1; # remove existing speed extensions with recorded speed (<gpxtpx:speed>)
use constant INCLUDE_SPEED        => 1; # include our simple speed extensions with recorded or computed speed (<speed>)
use constant DISABLE_TRKPT_CMT    => 0; # do not add 'cmt' entries to trackpoints, e.g., comments on ignored points
use constant DISABLE_TRKPT_SRC    => 0; # do not add 'src' entries to trackpoints, e.g., on time gaps and interpolated data
use constant DISABLE_TRKPT_FIX    => 0; # do not add 'fix' entries to trackpoints, on points inserted with interpolated data

# control filling in missing altitude and/or time
use constant CARRY_OVER_ELE    => 1; # copy missing altitude from end of previous segment or begin of following segment # better not: last available value (prev_avail_ele)
use constant CARRY_OVER_TIME   => 1; # copy missing time     from end of previous segment or begin of following segment
use constant FILL_MISSING_ELE  => 1; # interpolate missing altitude
use constant FILL_MISSING_TIME => 1; # interpolate missing time

# control use of recorded vs. computed speed
use constant MAX_TIMEDIFF_RECORDED_SPEED => 2; # maximum number of seconds for which recorded speed is used

# analysis control
use constant MIN_SPEED_MOVING =>  1; # threshold for detecting movement (in km/h)
use constant ANALYZE_PHASES   =>  0; # by default do not analyze ascent/descent phases
use constant ELE_THRESHOLD    => 25; # threshold for detecting/accepting ascent or descent (in m);
                                     # should be larger than short-term altitude measurement error
my $PHASES_REPORT_THRESHOLD = ELE_THRESHOLD; # default

# smoothing control
use constant MERGE_FILL_GAP    => 60; # minimum gap duration in seconds to be filled by merging
use constant ENABLE_SMOOTHING  =>  0; # by default disable smoothing
use constant SMOOTHING_MAX_GAP => 60; # maximum number of seconds between trackpoint to be smoothened and its neighbors

# control insertion of points within long time gaps
use constant INSERT_POINTS       =>    1; # enable inserting points with interpolated data in long time gaps
my $insert_points = INSERT_POINTS;
use constant INSERT_SEGMENT      =>    0; # enable inserting segment for long time gaps just before segment start
use constant INSERTION_MAX_GAP   => 1800; # length of gap in seconds between consecutive trackpoints before
# insertion should be used (1800 for exiftool default GeoMaxIntSecs; for TrailGuru 3600 would be sufficient)

# warning output control
use constant PRINT_WARNINGS      =>    1; # whether printing warnings is enabled by default
use constant PRINT_INFO          =>    1; # whether printing information is enabled by default
use constant WARNING_TPT_DIST    => 2000; # threshold for trackpoint distance warning (in meters)
use constant WARNING_WPT_DIST    =>  100; # threshold for waypoint distance warning (in meters)
use constant MAX_SPEED_DEVIATION =>0.025; # threshold for speed measuring deviation warning (fraction of MAX_PLAUSIBLE_SPEED)
# using absolute value for MAX_SPEED_DEVIATION because we compute speed from absolute values (coordinates and time)

# sanitization control
use constant   SANITIZE_TRKPTS   =>    1; # whether trackpoint sanitization is enabled by default
my $sanitize = SANITIZE_TRKPTS;
my $MIN_TIMEDIFF          ; # in seconds
my $MAX_PLAUSIBLE_SPEED   ; # maximal speed in km/h
my $MAX_PLAUSIBLE_ACCEL   ; # maximal acceleration m/s/s
my $MAX_PLAUSIBLE_DECEL   ; # maximal deceleration m/s/s
my $MAX_PLAUSIBLE_ELE_GAIN; # maximal ascent rate in m/h
my $MAX_PLAUSIBLE_ELE_LOSS; # maximal descent rate in m/h
use constant MAX_PLAUSIBLE_ANGLE_DIFF =>  170; # maximal plausible turning angle above speed threshold
use constant MAX_PLAUSIBLE_ANGLE_SPD_THRESHOLD => 5; # speed threshold for maximal plausible turning angle in km/h
use constant MIN_PLAUSIBLE_ELE        => -450; # minimal plausible altitude; actual elevation values on Earth may be as low as -450 m at Dead Sea

# time control
use constant TIME_CORRECTION => 0; # number of seconds to add to time stamps in trkpt and wpt
my $MAX_UNDEF_TIME = str_to_epoch("9999-12-31T23:59:59Z"); # as used in RFC 5820 section 4.1.2.5

# elevation correction control
use constant GEOID_ELE_CORRECTION   => 0; # whether to correct elevation wrt. geoid height retrieved online
use constant DEFAULT_ELE_CORRECTION => 0; # 47; # if used should be -(average geoid height)

### other constants

use constant H2S            =>    3600 ; # factor for converting hours to seconds
use constant M2KM           =>    0.001; # factor for converting m to km
use constant MPS2KMPH       =>H2S * M2KM;# factor for converting m/s to km/h
use constant METERS_PER_DEGREE_LAT => 10000 * 1000 / 90; # on Earth, by definition
use constant LAT_PRECISION  =>   "%.5f"; #  latitude resolution = 0.00001° (<= 1.11 meters)
use constant LON_PRECISION  =>   "%.5f"; # longitude resolution = 0.00001° (<= 1.11 meters)
use constant ELE_PRECISION  =>  "%5.0f"; #  altitude resolution = 1 meters
use constant ELE_PRECISION0 =>   "%.0f";
use constant ELE_PRECISION3 =>   "%.3f";
use constant DIF_PRECISION  => "%+5.0f"; #  altitude difference          resolution = 1 meters
use constant RAT_PRECISION  => "%+5.0f"; #  altitude ascent/descent rate resolution = 1 meters
use constant RAT_PRECISION2 => "%+6.0f"; #  altitude ascent/descent rate resolution = 1 meters
use constant DIS_PRECISION  =>   "%.3f"; #  distance resolution = 0.001 km
use constant DIS_PRECISION2 =>  "%6.3f"; #  distance resolution = 0.001 km
use constant SEC_PRECISION  =>   "%.0f"; #   seconds resolution = 1 second
use constant SPD_PRECISION  =>  "%4.0f"; #     speed resolution = 1 km/h
use constant AVG_PRECISION  =>   "%.1f"; # avg speed resolution = 0.1 km/h
use constant SPD_PRECISION0 =>   "%.0f";
use constant ACC_PRECISION  =>   "%.1f"; # acceleration resolution = 0.1 m/s/s

# trkpt flags
use constant DUPLICATED_POINT   => 1 << 0;
use constant INSERTED_POINT     => 1 << 1;
use constant INTERPOLATED_ELE   => 1 << 2;
use constant INTERPOLATED_TIM   => 1 << 3;
use constant SUBSTITUTED_ELE    => 1 << 4;
use constant SUBSTITUTED_TIM    => 1 << 5;
use constant COMPUTED_SPEED     => 1 << 6;

# global option variables

my $debug = 0;
my $merge;
my $num_ignored_hdrs   = 0;
my $begin_sec;
my $num_ignored_before = 0;
my $end_sec;
my $num_ignored_after  = 0;
my $max_elem;
my $max_elem_limit;
my $num_elem_above  = 0;
my $min_elem;
my $min_elem_limit;
my $num_elem_below  = 0;
my $max_ext;
my $max_ext_limit;
my $num_ext_above  = 0;
my $min_ext;
my $min_ext_limit;
my $num_ext_below  = 0;
my $ele_corr         = DEFAULT_ELE_CORRECTION;
my $smoothing        = ENABLE_SMOOTHING;
my $num_smoothened   = 0;
my $phases           = ANALYZE_PHASES;
my $weight;
my $prune_wpts       = PRUNE_WPTS;
my $num_pruned_wpts  = 0;
my $num_auto_wpts    = 0;
my $prune_cmts       = PRUNE_CMTS;
my $num_pruned_cmts  = 0;
my $num_pruned_descs = 0;
my $num_pruned_links = 0;
my $prune_exts       = PRUNE_EXTENSIONS;
my $num_pruned_exts  = 0;
my $print_warnings   = PRINT_WARNINGS;
my $print_info       = PRINT_INFO;

# trackpoint data

my @IGN; # number of points ignored immediately before this one
my @SEG;
my @FLG;
my @LAT;
my @LON;
my @ELE; # or "" if not available
my @TIM; # or "" if not available
my @SEC; # computed from @TIM, possibly adapted, or undefined if not available
my @DIS; # derived from LAT and LON, and ELE if available, also from point before, 0 for first point
my @RAT; # derived from optionally ELE and SEC, also from point before, or "" if not available
my @SPD; # as recorded or computed (as average since previous point if FLG contains COMPUTED_SPEED), or "" if not available
my @CMT; # as given in input but without <cmt> and </cmt> tags, or "" if not available
my @SRC; # as given in input but without <src> and </src> tags, or "" if not available
my @FIX; # as given in input but without <fix> and </fix> tags, or "" if not available
my @EXT; # or "" if not available

# waypoint data

my @WLAT;
my @WLON;
my @WELE; # or "" if not available
my @WTIM; # or "" if not available
my @WSEC; # computed from @WTIM, possibly adapted, or undefined if not available
my @WTXT; # inner waypoint text after </time>, or "" if not available
my @WSTR; # for diagnostics only: full original but indented waypoint text surrounded by '...', or undefined for statistics waypoint

# ascent/descent phase data

my @PHASE_DURATION;
my @PHASE_DIFF;
my @PHASE_DIST;
my @PHASE_SPD;
my @PHASE_RATE;
my @PHASE_MAX_SPD_INDEX;
my @PHASE_MAX_RATE_INDEX;
my @PHASE_END_INDEX;
my $ascent__phases_suppressed = 0;
my $descent_phases_suppressed = 0;

# global state variables

my $HEAD;
my $found_corr = 0;

my $lat, my $lon, my $ele, my $tim, my $sec, my $spd; # TODO make local

my $min_lat, my $max_lat;
my $min_lon, my $max_lon;

my ($min_sec, $max_sec);
my ($min_tim, $max_tim) = ("", ""); # $max_tim is not really used

my ($segs, $days);
my ($part_start, $part_end, $part_offset);
# in the following arrays, index ($part_start - 1) will be used for the overall values
my (@MAX_SPD      , @MIN_ELE      , @MAX_ELE      , @MAX_GAIN      , @MAX_LOSS      ); # TODO remove these redundant arrays (GAIN/LOSS via RAT)
my (@MAX_SPD_INDEX, @MIN_ELE_INDEX, @MAX_ELE_INDEX, @MAX_GAIN_INDEX, @MAX_LOSS_INDEX);
my (@LAST_GAIN_INDEX, @LAST_LOSS_INDEX, @PART_START_INDEX, @PART_END_INDEX);
my (@SUM__ASCENT, @TIME__ASCENT, @MISSING__ASCENT_TIME,
    @SUM_DESCENT, @TIME_DESCENT, @MISSING_DESCENT_TIME);
my (@SUM_DIS, @DURATION);

my $sum_dis_mov = 0;
my $avg_timediff;

 # for calculating relative deviation between recorded and computed speed
my $sum_speed = 0;
my $sum_speed_deviation = 0;

my $sum_timediff_mov = 0;
my $sum_energy = 0;

my $out = *STDOUT;  # https://stackoverflow.com/questions/10478884/are-there-rules-which-tell-me-what-form-of-stdout-stderr-sdtin-i-have-to-choose

### various subprocedures

#http://www.perlmonks.org/?node_id=406883
#sub max { return $_[0] > $_[1] ? $_[0] : $_[1]; }
use List::Util qw[min max];

# http://stackoverflow.com/questions/178539/how-do-you-round-a-floating-point-number-in-perl
use Math::Round qw(nearest);
use Math::Trig  qw(deg2rad pi2);   # use Math::Trig 'great_circle_distance';
use constant    RAD2DEG => 360 / pi2;
use File::Temp  qw(tempfile);

# use DateTime::Format::ISO8601;
use Time::ParseDate ();

# use Time::PrintDate;
use Time::gmtime qw(gmtime);

use Scalar::Util qw(looks_like_number);

sub print_line { print STDERR "$_[0]\n"; }

sub warning {
    print_line("WARNING: $_[0]") if $print_warnings;
}

sub info {
    print_line("INFO   : $_[0]") if $print_info;
}

sub abort {
    print_line("$_[0]\naborting");
    exit 1;
}

sub debug {
    print_line("### DEBUG: $_[0]");
}

sub debug_log {
    print_line("### LOG: $_[0]") if $debug;
}

# https://stackoverflow.com/questions/229009/how-can-i-get-a-call-stack-listing-in-perl
# alternatively to making explicit individual calls to stacktras, may use: perl -d:Confess
sub stacktrace {
    use Devel::StackTrace;
    print_line("");
    debug(Devel::StackTrace->new->as_string);
    # { # further alternative:
    #     use Carp qw<longmess>;
    #   # local $Carp::CarpLevel = -1;
    #     debug longmess();
    # }
    # { # further alternative:
    #     for (print STDERR "Stack Trace:\n", my $i = 0; my @call_details = caller($i); $i++) {
    #         print STDERR $call_details[1].":".$call_details[2]." in function ".$call_details[3]."\n";
    #     }
    # }
}

# str_to_epoch("1970-01-01T00:00:00Z") = 0; returns undef on error
# due to parsedate(), allows for weird values, e.g., 2000-01-01T00:00:63Z is taken as 2000-01-01T00:01:03Z
sub str_to_epoch {
    stacktrace() unless $_[0];
    my $s = $_[0];
    return undef unless $s =~ m/^\d\d\d\d-\d\d-\d\dT\d\d(:\d\d(:\d\d(\.\d{1,})?)?)?Z$/; # pre-parse because parsedate() is not very strict

# within a day, may use: seconds + 60 * (minute + 60 * hour)
# return DateTime::Format::ISO8601->parse_datetime($s)->epoch();
# # not used due to Perl library bug on Mac OS X: "dyld: lazy symbol binding failed: Symbol not found: _Perl_newSVpvn_flags"
# # http://www.en8848.com.cn/Reilly%20Books/perl3/cookbook/ch03_08.htm
# use Time::Local;
# $date is "1998-06-03" (YYYY-MM-DD form).
# ($yyyy, $mm, $dd) = ($date =~ /(\d+)-(\d+)-(\d+)/;
# # calculate epoch seconds at midnight on that day in this timezone
# $epoch_seconds = timegm(0, 0, 0, $dd, $mm, $yyyy);
    $s =~ s/-/\//g;
    $s =~ s/(T\d+)Z/$1:00Z/; # workaround for the case that only hour is given
    $s =~ s/T/ /;
    $s =~ s/Z/+0000/;
    my $sec = Time::ParseDate::parsedate($s);
    $sec += $1 if defined $sec && $s =~ m/:\d\d(\.\d+)/; # fractional seconds
    return $sec;
}

sub epoch_to_str {
    stacktrace() unless defined $_[0];

# use DateTime; # not used due to Perl library bug on Mac OS X:
                # "dyld: lazy symbol binding failed: Symbol not found: _Perl_newSVpvn_flags"
#  my $dt = DateTime->from_epoch(epoch => $_[0]);
#  return $dt->ymd."T".$dt->hms."Z";
#use Date::Manip qw(ParseDate UnixDate);
#$date = ParseDate("18 Jan 1973, 3:45:50");
#  return UnixDate($_[0], "%Y-%m-%dT%H:%M:%SZ");
    my $sec = shift;
    my $millisec = nearest(.001, $sec - int($sec)); # fractional seconds
    my $tm = gmtime($sec);
    return sprintf(
        "%04d-%02d-%02dT%02d:%02d:%02d%sZ",
        $tm->year + 1900,
        $tm->mon + 1,
        $tm->mday, $tm->hour, $tm->min, $tm->sec,
        $millisec == 0 ? "" : substr(substr($millisec, 1)."00", 0, 4));
}

sub round_tim { # round to nearest second
    stacktrace() unless $_[0];
    my $tim = shift;
    # $tim =~ s/(:\d\d)(\.\d+)/$1/;  # strip fractional seconds
    return $tim =~ m/\.(\d+)Z$/ && $1 != 0 ? epoch_to_str(nearest(1, str_to_epoch($tim))) : $tim;
}

sub timediff_str {
    stacktrace() if !defined $_[1] || $_[1] eq "";
    my $t = $_[1] + 0.5; # for rounding to nearest second
    my $s = $t % 60;
    $t = ($t - $s) / 60;
    my $m = $t % 60;
    $t = ($t - $m) / 60;
    return sprintf($_[0].":%02d:%02d h", $t, $m, $s);
}
sub timediff_string { return timediff_str("%d", $_[0]); }

sub ele_string {
    stacktrace() if !defined $_[1] || $_[1] eq "";
    my $len = $_[0];
    my $ele = $_[1];
    $ele = (sprintf ELE_PRECISION0, $ele) =~ s/^\s*-(0(\.0*)?)$/$1/r if $len >= 0;
    return (" " x max(0, abs($len) - length($ele))) . $ele;
}
sub dis_str {
    stacktrace() if !defined $_[1] || $_[1] eq "";
    return sprintf $_[0]." km", M2KM * $_[1];
}
sub dis_string { return dis_str(DIS_PRECISION, $_[0]); }

sub point_str { return "point $_[0] ".($tim ne "" ? "tim=$tim" : "$lat , $lon ".($ele eq "" ? "none" : $ele)); }

sub spd_or_none { return $_[0] eq "" ? "none" : (sprintf "%.3f", MPS2KMPH * $_[0]) =~ s/\.?0+$//r; }

my $spd_prec_len = 1; # used only for spd_string
sub spd_full {
    stacktrace() if !defined $_[0] || $_[0] eq "";
    return sprintf SPD_PRECISION, MPS2KMPH * $_[0];
}
sub spd_str {
    stacktrace() if !defined $_[0] || $_[0] eq "";
    return sprintf SPD_PRECISION0, MPS2KMPH * $_[0];
}
sub spd_string {
    my $s = spd_str($_[0]);
    return " " x ($spd_prec_len - length($s)) . $s;
}

# used only for formatting:
my $lat_prec_len = my $lat_full_len = lat_str(0);
my $lon_prec_len = my $lon_full_len = lon_str(0);
my $ele_prec_len = my $ele_full_len = length((sprintf ELE_PRECISION0, 0));
my $tim_len = length(epoch_to_str(0));
sub lat_str { return (sprintf LAT_PRECISION, $_[0]) =~ s/^\s*-(0(\.0*)?)$/$1/r; }
sub lon_str { return (sprintf LON_PRECISION, $_[0]) =~ s/^\s*-(0(\.0*)?)$/$1/r; }
sub lat_string {
    my $s = lat_str($_[0]);
    return " " x max(0, $lat_prec_len - length($s)) . $s;
}
sub lon_string {
    my $s = lon_str($_[0]);
    return " " x max(0, $lon_prec_len - length($s)) . $s;
}


sub parse_point {
    my $str = $_[0];
    my $is_trkpt = $str =~ m/^<trkpt /;

    my $lat, my $lon;
    abort("FATAL: cannot find lat/lon part of point: $_[0]")
        unless $str =~ s#^(<\w+)(\s+(\w+\s*=\s*"[^\"]*"\s*)+)\s*>#$1>#s;
    my $lat_lon_str = $2;
    if ($lat_lon_str =~ m#\slat\s*=\s*"(-?\d*(\.\d+)?)"\s*lon\s*=\s*"(-?\d*(\.\d+)?)"#s) {
        ($lat, $lon) = ($1, $3);
    } elsif ($lat_lon_str =~ m#\slon\s*=\s*"(-?\d*(\.\d+)?)"\s*lat\s*=\s*"(-?\d*(\.\d+)?)"#s) {
        ($lat, $lon) = ($3, $1);
    } else {
        abort("FATAL: error parsing lat/lon part '$lat_lon_str' of point: $_[0]");
    }
    $lat_full_len = max($lat_full_len, length($lat));
    $lon_full_len = max($lon_full_len, length($lon));

    my $ele_str = my $ele = "";
    if ($str =~ s#[ \t]*(<ele>\s*([^\s<]*)\s*</ele>)\n?##s) {
        ($ele_str, my $ele_inner) = ($1, $2);
        abort("FATAL: error parsing elevation value '$ele_inner' in point: $_[0]")
            unless $ele_inner =~ m/^\s*(-?\d*(\.\d+)?)(\.\d*)?\s*$/; # ignores any decimals past any second decimal dot, e.g, takes ".12" on ".12.34" input
        $ele = $1; # may be empty or 0
        $ele_prec_len = max($ele_prec_len, length((sprintf ELE_PRECISION0, $ele)));
        $ele_full_len = max($ele_full_len, length($ele));
    }

    my $tim = "", my $sec;
    if ($str =~ s#[ \t]*(<time>\s*([^\s<]*)\s*</time>)\n?##s) {
        $tim = my $orig_tim = $2;
        $tim =~ s/\.0+Z/Z/;
        $tim_len = max($tim_len, length($tim));
        $sec = str_to_epoch($tim); # may be 0
        abort("FATAL: error parsing time value '$orig_tim' in point: $_[0]") unless defined $sec;
        $sec += 0.001 if $tim =~ m/\.999Z/; # for some reason, at least OruxMaps on Android often reports 0.001 seconds less than a full second
        if (TIME_CORRECTION) {
            $sec += TIME_CORRECTION;
            $tim = epoch_to_str($sec);
        } else {
            $tim =~ s/(T\d\d)Z/$1:00Z/;
            $tim =~ s/(T\d\d:\d\d)Z/$1:00Z/;
        }
    }
    $ele = "" if !$ele_str && $tim eq ""; # for routes generated, e.g., using Google My Maps

    my $cmt = "";
    if ($is_trkpt && !$prune_cmts && $str =~ s#[ \t]*<cmt>\s*(.*?)\s*?</cmt>\r?\n?##s) {
        $cmt = $1;
        $cmt =~ s#\n##sg;
    }

    my $src = "";
    if ($is_trkpt && $str =~ s#[ \t]*<src>\s*(.*?)\s*?</src>\r?\n?##s) {
        $src = $1;
        $src =~ s#\r?\n##sg; # TODO match \r? also in other similar situations
    }

    my $fix = "";
    if ($is_trkpt && $str =~ s#[ \t]*<fix>\s*(.*?)\s*?</fix>\r?\n?##s) {
        $fix = $1;
        $fix =~ s#\r?\n##sg;
    }

    my $ext = "";
    while ($str =~ s#[ \t]*(<extensions>.*?</extensions>)\n?#($ext .= $1, "")#es) {
        $ext =~ s#\n##sg;
    }

    my $spd = "";
    if ($is_trkpt && $ext =~ m#<(\w+:)?speed>([^<]*)</(\w+:)?speed>#s) {
        abort("FATAL: inconsistent tags '<$1speed>' and '</$3speed>' in speed extension of in point: $_[0]") if ($1 // "") ne ($3 // "");
        my ($prefix, $spd_str) = ($1, $2);
        abort("FATAL: error parsing speed extension value '$spd_str' in point: $_[0]")
            unless $spd_str =~ m/^\s*(-?\d*(\.\d+)?)(\.\d*)?\s*$/; # ignores any decimals past any second decimal dot, e.g, takes ".12" on ".12.34" input
        # we assume that recorded speed takes altitude into account (i.e., is not just horizontal/lateral speed),
        # see also https://forums.geocaching.com/GC/index.php?/topic/209525-gps-speed-3d-or-2d/
        $spd = $1;
        $spd *= 1 / MPS2KMPH unless $prefix; # usually, speed is given m/s, while our abbreviated extension uses km/h
        $spd_prec_len = max($spd_prec_len, length(spd_str($spd))); # used only for spd_string
    }

    my $rest = $str;
    $rest =~ s#\n##sg;
    $rest =~ s#>[ \t]+<#><#g;
    # clean up potential errors in input:
    $rest =~ s#<ele></ele>##;
    $rest =~ s#<time></time>##;

    my $ignore = 0;
    $ignore = 1 if
        (diff_defined($sec, $begin_sec) // 0) < 0 && ++$num_ignored_before ||
        (diff_defined($sec,   $end_sec) // 0) < 0 && ++$num_ignored_after  ||
         $max_elem  && $_[0] =~ m#<$max_elem>\s*(-?[\.\d]+)\s*</$max_elem>#s && $1 > $max_elem_limit && ++$num_elem_above ||
         $min_elem  && $_[0] =~ m#<$min_elem>\s*(-?[\.\d]+)\s*</$min_elem>#s && $1 < $min_elem_limit && ++$num_elem_below;

    return ($lat, $lon, $ele, $tim, $sec, $spd, $rest, $cmt, $src, $fix, $ext, $ignore);
}

sub plural { my ($n, $str) = @_; return "$n $str".($n == 1 ? "" : "s"); }
sub points { return plural ($_[0], "point"); }

sub info_trkpt  { info_trkpt_i (-1, $_[0], $_[1]); }
sub warn_trkpt  { warn_trkpt_i (-1, $_[0], $_[1]); }
sub print_trkpt { print_trkpt_i(-1, $_[0], $_[1]); }

sub info_trkpt_i {
    print_trkpt_i($_[0], "INFO   : $_[1]", $_[2]) if $print_info;
}

sub warn_trkpt_i {
    print_trkpt_i($_[0], "WARNING: $_[1]", $_[2]) if $print_warnings;
}

sub print_trkpt_i {
    my $i    = $_[0];
    my $head = $_[1];    # may be empty
    my $tail = $_[2];    # may be empty
    my ($lati, $long, $elev, $t) =
      $i < 0
      ? ($lat    , $lon    , $ele    , $tim    )
      : ($LAT[$i], $LON[$i], $ELE[$i], $TIM[$i]);

    # using original precision here for better traceability
    # $lati = lat_str($lati);
    # $long = lon_str($long);
    if ($elev eq "") {
        $elev         = "NONE";
        $ele_prec_len = max($ele_prec_len, length($elev));
        $ele_full_len = max($ele_full_len, length($elev));
    } elsif ($ele_full_len > $ele_prec_len) {
        my $decimals = -1;
        $decimals = length($1) if $elev =~ m/\.(\d+)/;
        my $n_spaces = $ele_full_len - $ele_prec_len - $decimals - 1;
        $elev .= ' ' x $n_spaces if $n_spaces > 0;
    }
    my $time = $t eq "NO" ? "" : " <time>".($t eq "" ? "NONE" : $t);
    print_line("$head "
      . "<trkpt"
      . ' lat="' . ($lati . '"' . (' ' x max(0, $lat_full_len - length($lati))))
      . ' lon="' . ($long . '"' . (' ' x max(0, $lon_full_len - length($long))))
      . " <ele>" . ele_string(-$ele_full_len, $elev)
      . $time . ($tail ? " " x max(0, $tim_len + length(" <time>") - length($time)) : "")
      . $tail);
    abort("") if $head =~ "^FATAL:";
}

sub diff_defined  { return defined $_[0] && defined $_[1] ? $_[0] - $_[1] : undef; }
sub diff_nonempty { stacktrace() unless defined $_[0] && defined $_[1];
                    return $_[0] ne ""   && $_[1] ne ""   ? $_[0] - $_[1] : undef; }

sub rate { return defined $_[0] && $_[1] ? H2S * $_[0] / $_[1] : ""; } # ascent/descent rate in m/h

sub recalculate_DIS { my $i = $_[0];
    return if $i <= 0 || $SEG[$i];
    $DIS[$i] = distance($LAT[$i    ], $LON[$i    ], $ELE[$i    ],
                        $LAT[$i - 1], $LON[$i - 1], $ELE[$i - 1]);
}
sub recalculate_SPD { my $i = $_[0];
    return if $i <= 0 || $SEG[$i] || !($FLG[$i] & COMPUTED_SPEED);
    my $diff_time = diff_defined($SEC[$i], $SEC[$i - 1]);
    $SPD[$i] = $DIS[$i] / $diff_time if $diff_time;
}
sub recalculate_RAT { my $i = $_[0];
    return if $i <= 0 || $SEG[$i];
    $RAT[$i] = rate(diff_nonempty($ELE[$i], $ELE[$i - 1]), diff_defined($SEC[$i], $SEC[$i - 1]));
}
sub recalculate_all {
    my $i = $_[0];
    recalculate_DIS($i);
    recalculate_SPD($i);
    recalculate_RAT($i);
}

sub remove_trkpt { my ($i, $curr, $undo_time_gap_fill) = @_; # so far, used only with $i == $curr - 1 or $i == $curr
    # undo_time_gap_fill implies: do not count the previously inserted point being ignored, ignore segment start,
    # and due to linear interpolation keep the speed but re-calculate the distance (simply by addition) and rate
    $IGN[$i + 1] += $IGN[$i] + ($undo_time_gap_fill ? 0 : 1); # indicate that previous point has been ignored, in addition to any previous ignores
    $SEG[$i + 1] = 1 if $SEG[$i] && !$undo_time_gap_fill; # copy over any segment start
    my $dis_before = $DIS[$i];
    splice @IGN, $i, 1;
    splice @SEG, $i, 1;
    splice @FLG, $i, 1;
    splice @LAT, $i, 1;
    splice @LON, $i, 1;
    splice @ELE, $i, 1;
    splice @TIM, $i, 1;
    splice @SEC, $i, 1;
    splice @DIS, $i, 1;
    splice @RAT, $i, 1;
    splice @SPD, $i, 1;
    splice @CMT, $i, 1;
    splice @SRC, $i, 1;
    splice @FIX, $i, 1;
    splice @EXT, $i, 1;
    if ($undo_time_gap_fill) {
        $DIS[$i] += $dis_before if $i > 0;
        recalculate_RAT($i);
    } elsif ($i < $curr) {
        recalculate_DIS($i);
        recalculate_SPD($i);
        recalculate_RAT($i);
    }
}

sub distance {
    stacktrace() if !defined $_[0] || !defined $_[1] || !defined $_[2] || !defined $_[3] || !defined $_[4] || !defined $_[5];
    my $lat      = $_[0];
    my $lon      = $_[1];
    my $ele      = $_[2];
    my $prev_lat = $_[3];
    my $prev_lon = $_[4];
    my $prev_ele = $_[5];
    my $diff_lat = ($lat - $prev_lat) * METERS_PER_DEGREE_LAT;
    my $diff_lon = ($lon - $prev_lon) * METERS_PER_DEGREE_LAT *
      cos(deg2rad(($lat + $prev_lat) / 2));

#my$diff_lon = ($lon * cos(deg2rad($lat)) - $prev_lon * cos(deg2rad($prev_lat))) * METERS_PER_DEGREE_LAT;
    my $diff_ele = diff_nonempty($ele, $prev_ele) // 0;

    # assuming no altitude change if no altitude available
    return sqrt($diff_lat * $diff_lat + $diff_lon * $diff_lon + $diff_ele * $diff_ele);

#$distance = Math::Trig::great_circle_distance( #does not account for $diff_ele!
#						  deg2rad($lon)     , deg2rad(90 - $lat     ),
#						  deg2rad($prev_lon), deg2rad(90 - $prev_lat),
#						  40*1000*1000/pi/2); #http://perldoc.perl.org/Math/Trig.html
## debug "diff_lat=$diff_lat, diff_lon=$diff_lon, dis=$dis, distance=$distance";
}

sub distance_curr { # of $lat, $lon, $ele
    return distance($lat, $lon, $ele, $_[0], $_[1], $_[2]);
}

sub comp_diffs
{
    my $i = shift; # calculate differences relative to previous point $i -1
    # $prev_comp_spd is assumed to be average speed computed between previous points
    my ($prev_ele, $prev_sec, $prev_dis, $prev_comp_spd) = ($ELE[$i - 1], $SEC[$i - 1], $DIS[$i - 1], $SPD[$i - 1]);
    my (     $ele,      $sec,      $dis,           $spd) = ($ELE[$i    ], $SEC[$i    ], $DIS[$i    ], $SPD[$i    ]);
    my $diff_ele = diff_nonempty($ele, $prev_ele);

    #http://forums.howwhatwhy.com/showflat.php?Cat=&Board=scigen&Number=-208125
    my $timediff = diff_defined($sec, $prev_sec);
    my $rate = $RAT[$i];
    my $rate_new = rate($diff_ele, $timediff);
    abort("FATAL: internal inconsistency on ascent/descent rate: $rate vs. $rate_new") if $rate ne $rate_new;
    my $comp_spd = defined $timediff ? ($timediff > 0 ? $dis / $timediff : $prev_comp_spd) : "";
    $spd_prec_len = max($spd_prec_len, length(spd_str($comp_spd))) if $comp_spd ne ""; # used only for spd_string
    my $acc = $comp_spd ne "" && $prev_comp_spd ne "" && $timediff ? ($comp_spd - $prev_comp_spd) / $timediff : "";
    return ($diff_ele // "", $timediff // "", $rate, $dis, $comp_spd, $acc);
}


### parse command line
# TODO clean up use of ARGV

for (my $i = 0; $#ARGV - $i >= 0;) {
    my $opt  = $ARGV[$i];
    my $arg1 = $ARGV[$i + 1];
    my $arg2 = $ARGV[$i + 2];

    # not checking for duplicate options

    if ($opt eq "-h" || $opt =~ /^-*help$/) {
        print_line($usage);
        exit 0;
    } elsif ($opt eq "-version") {
        print_line($TOOL_ID);
        exit 0;
    } elsif ($opt eq "-swim"  ||
        $opt eq "-walk"  ||
        $opt eq "-cycle" ||
        $opt eq "-drive" ||
        $opt eq "-fly") {
        $activity = $opt;
    } elsif ($opt eq "-no_sanitize") {
        $sanitize = !SANITIZE_TRKPTS;
    } elsif ($opt eq "-no_insert") {
        $insert_points = !INSERT_POINTS;
    } elsif ($opt eq "-smooth") {
        $smoothing = 1;
    } elsif ($opt eq "-phases") {
        $phases = 1;
    } elsif ($opt eq "-merge") {
        abort("missing file argument for -$opt option") if $#ARGV - $i < 1;
        $merge = $arg1;
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    } elsif ($opt eq "-segs" || $opt eq "-days") {
        if ($opt eq "-segs") {
            abort("cannot use both -days and -$opt option") if $days;
            $segs = 1;
        } else {
            abort("cannot use both -segs and -$opt option") if $segs;
            $days = 1;
        }
        if ($#ARGV - $i >= 1 && $arg1 =~ m/^\d/) {
            abort("argument '$arg1' of -$opt option is not of the form <n>..[<m>][(+|-)<d>] with natural numbers n, m, and integer d")
            unless $arg1 =~ m/^(\d+)\.\.(\d+)?([-+]\d+)?+$/ && $1 > 0;
            ($part_start, $part_end, $part_offset) = ($1, $2, $3); # $part_end < $part_start will lead to empty selection, just like without $opt
            splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
        }
    } elsif ($opt eq "-weight") {
        abort("missing value argument for -$opt option") if $#ARGV - $i < 1;
        abort("cannot parse value argument in '$opt $arg1'") unless looks_like_number($arg1);
        $weight = $arg1 + 0;
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    } elsif ($opt eq "-begin" || $opt eq "-end") {
        abort("missing time argument for $opt option") if $#ARGV - $i < 1;
        my $sec = str_to_epoch($arg1);
        abort("cannot parse time argument in '$opt $arg1'") unless defined $sec;
        $begin_sec = $sec if $opt eq "-begin";
        $end_sec   = $sec if $opt eq "-end";
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    } elsif ($opt eq "-max" || $opt eq "-min") {
        abort("missing element name argument for $opt option") if $#ARGV - $i < 1;
        abort("missing limit argument for -$opt option") if $#ARGV - $i < 2;
        abort("cannot parse limit argument in '$opt $arg1 $arg2'") unless looks_like_number($arg2);
        ($max_elem, $max_elem_limit) = ($arg1, $arg2 + 0) if $opt eq "-max";;
        ($min_elem, $min_elem_limit) = ($arg1, $arg2 + 0) if $opt eq "-min";;
        splice @ARGV, $i + 1, 2;    # remove from ARGV the option arguments
    } elsif ($opt eq "-max_ext" || $opt eq "-min_ext") {
        abort("missing extension name argument for $opt option") if $#ARGV - $i < 1;
        abort("missing limit argument for -$opt option") if $#ARGV - $i < 2;
        abort("cannt parse limit argument in '$opt $arg1 $arg2'") unless looks_like_number($arg2);
        ($max_ext, $max_ext_limit) = ($arg1, $arg2 + 0) if $opt eq "-max_ext";
        ($min_ext, $min_ext_limit) = ($arg1, $arg2 + 0) if $opt eq "-min_ext";
        splice @ARGV, $i + 1, 2;    # remove from ARGV the option arguments
    } elsif ($opt eq "-prune_wpts") {
        $prune_wpts = 1;
    } elsif ($opt eq "-prune_cmts") {
        $prune_cmts = 1;
    } elsif ($opt eq "-prune_exts") {
        $prune_exts = 1;
    } elsif ($opt eq "-nw") {
        $print_warnings = 0;
    } elsif ($opt eq "-ni") {
        $print_info = 0;
    } elsif ($opt eq "-o") {

     # not checking for operlap with shell-level redirection of STDOUT using '>'
        abort("missing outfile argument for -o option") if $#ARGV - $i < 1;
        open($out, "> $arg1");
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    } elsif ($opt eq "-debug") {
        $debug = 1;
    } elsif ($opt =~ m/^-/) {
        abort("unknown option: $opt");
    } else {
        $i++;
        next;                   # infile
    }
    splice @ARGV, $i, 1;        # remove from ARGV the option just handled
}
if ($prune_exts) {
    warning("-min_ext option has little effect since -prune_exts is given") if $min_ext;
    warning("-max_ext option has little effect since -prune_exts is given") if $max_ext;
}

if ($activity eq "-swim") {
    $MIN_TIMEDIFF           = 4;
    $MAX_PLAUSIBLE_SPEED    = 7;
    $MAX_PLAUSIBLE_ACCEL    = 1;
    $MAX_PLAUSIBLE_DECEL    = 2;
    $MAX_PLAUSIBLE_ELE_GAIN = 1;
    $MAX_PLAUSIBLE_ELE_LOSS = 1;
} elsif ($activity eq "-walk") {
    $MIN_TIMEDIFF           = 4;
    $MAX_PLAUSIBLE_SPEED    = 20;
    $MAX_PLAUSIBLE_ACCEL    = 0.5;
    $MAX_PLAUSIBLE_DECEL    = 1;
    $MAX_PLAUSIBLE_ELE_GAIN = 1800;
    $MAX_PLAUSIBLE_ELE_LOSS = 3600;
} elsif ($activity eq "-cycle") {
    $MIN_TIMEDIFF           = 2;
    $MAX_PLAUSIBLE_SPEED    = 80;
    $MAX_PLAUSIBLE_ACCEL    = 4;
    $MAX_PLAUSIBLE_DECEL    = 8;
    $MAX_PLAUSIBLE_ELE_GAIN = 3000;
    $MAX_PLAUSIBLE_ELE_LOSS = 9000;
} elsif ($activity eq "-drive") { # default
    $MIN_TIMEDIFF           = 2;     # in seconds
    $MAX_PLAUSIBLE_SPEED    = 200;   # maximal speed in km/h
    $MAX_PLAUSIBLE_ACCEL    = 5;     # maximal acceleration m/s/s
    $MAX_PLAUSIBLE_DECEL    = 10;    # maximal deceleration m/s/s
    $MAX_PLAUSIBLE_ELE_GAIN = 20000; # maximal ascent rate in m/h
    $MAX_PLAUSIBLE_ELE_LOSS = 20000; # maximal descent rate in m/h
    $PHASES_REPORT_THRESHOLD = 100;
} elsif ($activity eq "-fly") {
    $MIN_TIMEDIFF           = 1;
    $MAX_PLAUSIBLE_SPEED    = 1200;
    $MAX_PLAUSIBLE_ACCEL    = 10;
    $MAX_PLAUSIBLE_DECEL    = 10;
    $MAX_PLAUSIBLE_ELE_GAIN = 30000;
    $MAX_PLAUSIBLE_ELE_LOSS = 50000;
    $PHASES_REPORT_THRESHOLD = 100;
} else {
    abort("unknown activity: $activity\naborting");
}
my $INSERTION_MAX_SPEED = $MAX_PLAUSIBLE_SPEED / 2;
my $MAX_SPEED_DEVIATION = $MAX_PLAUSIBLE_SPEED * MAX_SPEED_DEVIATION;


### main loops

## read all trackpoints from all track segments, optionally completing them

{ # TODO re-format
my $ele_miss_start  = 0; # first index of recent stretch with missing ele ; TODO restrict scope
my $tim_miss_start  = 0; # first index of recent stretch with missing time; TODO restrict scope
my $num_no_ele      = 0;
my $ele_gap_length  = 0;
my $num_no_time     = 0;
my $time_gap_length = 0;
# $prev_avail_tim = "";

$/ = "<trkpt ";
if ($merge) {
    open M, $merge || abort("FATAL: cannot open alternative GPX source file $merge: $.") if $#TIM < 0;
    <M>; # first item is before "<trktpt"
}
my ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $cmt1, $src1, $fix1, $exts1) if $merge; # current end of gap to be merged
my ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $cmt2, $src2, $fix2, $exts2) if $merge; # current trkpt from alternative input
sub next_trkpt2() {
    my $trkpt2;
    my $ignore2 = 1;
    while ($ignore2 && defined($trkpt2 = <M>)) {
        $trkpt2 =~ m#(.*?</trkpt>)#s;
        $trkpt2 = $1;
        abort("FATAL: cannot find end of trackpoint: <trkpt $_") unless $trkpt2;
        ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, my $rest_unused2, $cmt2, $src2, $fix2, $exts2, $ignore2) = parse_point("<trkpt $trkpt2") if $trkpt2;
    }
    ## debug_log "read non-ignored point   from alt input with lat=$lat2 lon=$lon2 ele=$ele2 tim=$tim2 sec=".($sec2 // "none")." spd=".spd_or_none($spd2) if $trkpt2;
    return $trkpt2;
}
my $in_merge = 0; # if set, using trkpt from $merge
if ($merge && !next_trkpt2()) {
    abort("FATAL: no trkpt found in alternative input $merge");
    $merge = 0;
    close M;
}

# TODO before further complicating input handling, split file reading and parsing from any further processing
for (my $state = 0,
     my $prev_lat, my $prev_lon, my $prev_ele, my $prev_tim = "", my $prev_sec,
     my $prev_avail_sec, my $prev_avail_ele  = "", my $ele_miss_length = 0, my $tim_miss_length = 0,
     my $i = 0;
     $in_merge ? (next_trkpt2() ? 1 : ($in_merge = -$in_merge, $in_merge != -2 && defined($_ = <>))) # EOF in $merge
               : (defined($_ = <>) ||
                  # in case EOF in infile(s):
                  ($merge && (info("infile(s) ended before alternative input"), 1) ? ($in_merge = 2, 1) : 0));
    ) {
    # anywhere (in headers, tracks, waypoints, trackpoints, ...):
    $num_pruned_cmts  += s#[ \t]*<cmts>.*?</cmt>\n?##sg              if $prune_cmts;
    $num_pruned_descs += s#[ \t]*<desc>.+?</desc>\n?##sg             if PRUNE_DESCS;
    $num_pruned_links += s#[ \t]*<link.*?>.+?</link>\n?##sg          if PRUNE_LINKS;
    $num_pruned_exts  += s#[ \t]*<extensions>.*?</extensions>\n?##sg if $prune_exts;
    if (!$prune_exts && ($min_ext || $max_ext)) {
        s@(<extensions>)(.*?)(</extensions>\n?)@ my ($start, $ext, $end) = ($1, $2, $3);
            $ext =~ s#(<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>)#$2 < $min_ext_limit ? ($num_ext_below++, "") : $1#esg if $min_ext;
            $ext =~ s#(<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>)#$2 > $max_ext_limit ? ($num_ext_above++, "") : $1#esg if $max_ext;
            $ext eq "" ? "" : "$start$ext$end"
        @esg;
    }

    #collect waypoints, possibly in later infile(s) headers
    my $prev_wpt_time_stripped = "";
    while (!$in_merge && s#(<wpt .+?)(</wpt>)\n?##s)
    {
        my $wpt = $1 . $2;

        # workaround for OruxMaps partly duplicating waypoints of <type>Finishing Point</type> when manually starting new segment
        my $wpt_time_stripped = $wpt;
        $wpt_time_stripped =~ s#<time>.*</time>##;
        next if $wpt =~ m#<type>Finishing Point</type># && $wpt_time_stripped eq $prev_wpt_time_stripped;
        $prev_wpt_time_stripped = $wpt_time_stripped;

        ($lat, $lon, $ele, $tim, my $sec, my $spd_unused, my $rest, my $cmt_unused, my $src_unused, my $fix_unused, my $exts, my $ignore) = parse_point($wpt); # collect some basic data even if pruned
        $rest =~ s#^<wpt[^>]*>##; # ignoring any further wpt attributes, yet there should not be any (besides lat and lon)
        $rest =~ s#</wpt>$##;
        ++$num_pruned_wpts if $prune_wpts && !$ignore;
        if (!$ignore && !$prune_wpts
            && !(PRUNE_AUTOMATIC_WPTS &&
                 $rest =~ m#<name><!\[CDATA\[\d*\]\]></name># && ++$num_auto_wpts)
            # better not leave out waypoints added previously by this tool because this would disturb the ordering and duplicates are now taken care of by add_stat_point():
            # && !($rest =~ m#\[(start|end.*?)\]#) # start/end waypoint added previously by this tool
            # && # waypoint with statistics added previously by this tool:
            # !($rest =~ m#\[((max|min)\s+(altitude|elevation|height)|max\s+speed|max\s+(climb|ascent|descent)\s+rate|total\s+(ascent|descent|gain|loss))\s+=\s+[+-]?[\.\d]+ k?m(\/h)?( at -?[\.\d]+ km/h|;\s+avg\s+rate\s+=\s+[+-]?[\d.]+ m/h)?\]#)
            )
        {
            push @WLAT, $lat;
            push @WLON, $lon;
            push @WELE, $ele;
            push @WTIM, $tim;
            push @WSEC, $sec;
            push @WTXT, $rest . $exts;
            $wpt =~ s/(^|\n)/\n  /sg; # indent waypoint lines, just for better readability of diagnostics
            push @WSTR, "'$wpt\n'";
        }
    }

    sub warn_smmoothing { warning("smoothing has already been done on input") if $_[0] =~ m#(\d+) points .*?smoothened($|\W)# && $1 > 0; } 
    if ($state == 0) {
        # processing first header (of first input file)

        if (s#\r?\nGPXConv statistics (.*?)GPXConv statistics end\r?\n##s) # remove any earlier statistics section
        {
            warn_smmoothing($1) if $smoothing;
        }
        if (m#$/#s) {
            s#$/##s;    #remove trailing "<trkpt "
        } else {
            s#(^.*</type>).*#$1\n<trkseg>\n#s; #ignore rest of (header-only) file having no trkpt
        }
        s#[ \t]+(\r?\n)$#$1#s;    #remove any trailing spaces on line before
        s#[ \t]*(<trkseg>)#$1#s;
        $HEAD  = $_;
        $state = 1;         # expecting the very first trkpt
    } elsif (!$in_merge && m#(<gpx[ >])#s) { # processing further GPX header, typically from next file
        ++$num_ignored_hdrs;
        if ($smoothing && m#\r?\nGPXConv statistics (.*?smoothened)(.*?)GPXConv statistics end\r?\n#)
        {
            warn_smmooting($1);
        }
        if ($#TIM >= 0) { # typically, new file
            info_trkpt_i($i - 1, "end of segment at", "") if $i > 0;
            info("further track, from file $ARGV");
        }
        $state = 2 if $state > 2;    # expecting new trkseg
    } else {
        # when $state == 1 || $state == 2: processing first trkpt in new trkseg
        # when $state == 3: processing further trkpt in trkseg
        my ($sec, $spd, $cmt, $src, $fix, $exts);
        if (!$in_merge) {
            m#(.*?</trkpt>)#s;
            my $trkpt = $1;
            abort("FATAL: cannot find end of trackpoint: <trkpt $_") unless $trkpt;
            ($lat, $lon, $ele, $tim, $sec, $spd, my $rest_unused, $cmt, $src, $fix, $exts, my $ignore) = parse_point("<trkpt $trkpt");
            next if $ignore;
            ## debug_log "read non-ignored point $i from infile(s) with lat=$lat lon=$lon ele=$ele tim=$tim sec=".($sec // "none")." spd=".spd_or_none($spd)."; state = $state";
        } elsif ($merge) {
            ($lat , $lon , $ele , $tim , $sec , $spd , $cmt , $src , $fix , $exts ) = $in_merge == -1 ?
            ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $cmt1, $src1, $fix1, $exts1) : # EOF in $merge during infile(s)
            ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $cmt2, $src2, $fix2, $exts2);
        }
        my $diff_time = diff_defined($sec, $prev_avail_sec) // 0;

        if ($merge) {
            if (!$in_merge) {
                if (($diff_time >= MERGE_FILL_GAP || $state == 1) && (diff_defined($sec2, $sec) // 0) < 0) { # $merge currently is before infiles(s)
                    $in_merge = 1;
                    if ($state == 1) {
                        info("alternative input starts before infile(s)");
                    } else { # certainly $i > 0
                        info_trkpt_i($i - 1, "start using alternative input on ".timediff_string($diff_time)." gap after", "");
                    }
                    ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $cmt1, $src1, $fix1, $exts1) =
                    ($lat , $lon , $ele , $tim , $sec , $spd , $cmt , $src , $fix , $exts );
                    ($lat , $lon , $ele , $tim , $sec , $spd , $cmt , $src , $fix , $exts ) =
                    ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $cmt2, $src2, $fix2, $exts2);
                } else {
                    while ($merge && defined $sec && defined $sec2 && $sec2 <= $sec) {
                        # advance $merge as far as possible to catch up with infile(s)
                        ($merge = 0, close M) unless next_trkpt2();
                    }
                }
            } else { # $in_merge != 0
                if (defined $sec && $in_merge != 2 && defined $sec1 && $sec1 <= $sec) { # $merge is not before infiles(s)
                    ($lat , $lon , $ele , $tim , $sec , $spd , $cmt , $src , $fix , $exts ) =
                    ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $cmt1, $src1, $fix1, $exts1);
                    $in_merge = 0;
                    info_trkpt_i($i - 1, "end using alternative input at", "");
                }
            }
            $diff_time = diff_defined($sec, $prev_avail_sec) // 0; # recalculation
        }

        if ($state > 1) {
            my $severity = $state < 3 ? "WARNING" : "FATAL"; # at segment start, just warn
            print_trkpt("$severity: before", " negative time difference (-".timediff_string(-$diff_time).")")
                if $diff_time < 0; # this implies defined $sec && defined $prev_sec
            if (defined $sec && defined $prev_sec && $diff_time == 0) {
                print_trkpt("$severity: point before      ",
                            " has same time but different position: $prev_lat, $prev_lon")
                    if $lat != $prev_lat || $lon != $prev_lon;
                print_trkpt("$severity: point before      ",
                            " has same time but different altitude: $prev_ele m")
                    if $ele != $prev_ele;
            }
        }

        my $flags = 0;
        my $dis = $i == 0 || $state == 1 ? 0 : distance_curr($prev_lat, $prev_lon, $prev_ele);
        if ($state < 3) { # at the first point in trkseg, first handle last point of segment before
            $prev_avail_ele = "";
            if (CARRY_OVER_ELE && $ele ne "") {
                if ($i > 0 && $ELE[$i - 1] eq "") {
                    # fill in altitude in last point of segment before
                    $FLG[$i - 1] |= SUBSTITUTED_ELE;
                    $ELE[$i - 1] = $prev_ele = $ele;
                    recalculate_all($i - 1);
                    $dis = distance_curr($prev_lat, $prev_lon, $prev_ele); # recalculation
                    $ele_miss_length += $DIS[$i - 1] if $ele_miss_start;
                    warn_trkpt_i($i - 1, "at segment end    ",
                                 " no altitude was given; using value from begin of next segment");
                }
            } elsif ($ele_miss_start) {
                warn_trkpt_i($i - 1, "             up to",
                             " was unable to interpolate missing altitude within segment");
                $ele_miss_start = 0;
            }
            if (CARRY_OVER_TIME && $tim ne "") {
                if ($i > 0 && $TIM[$i - 1] eq "") {
                    # fill in time in last point of segment before
                    $FLG[$i - 1] |= SUBSTITUTED_TIM;
                    $TIM[$i - 1] = $tim;
                    $SEC[$i - 1] = $sec;
                    recalculate_SPD($i - 1);
                    recalculate_RAT($i - 1);
                    $tim_miss_length += $DIS[$i - 1] if $tim_miss_start;
                    warn_trkpt_i($i - 1, "at segment end    ",
                                 " no time     was given; using value from begin of next segment");
                }
            } elsif ($tim_miss_start) {
                warn_trkpt_i($i - 1, "             up to",
                    " was unable to interpolate missing time within segment");
                $tim_miss_start = 0;
            }
        }

        if ($state == 1) {
            my $name = $ARGV =~ s/^(test.*?\.out)\d$/$1/r; # avoid variation in test log output due to iteration count in file name
            info("initial track, from file $name");
            info_trkpt("first   segment at", "");
        } elsif ($state == 2) {
            info_trkpt("further segment at", " after a time gap of ".timediff_string($diff_time)." and ".dis_string($dis));
        }

        if ($state < 3) { # now handle first point in trkseg
            my $resolution;
            if ($ele eq "") {
                if ($i == 0 || $prev_ele eq "") { # $prev_avail_ele
                    $resolution = " and no previous value available";
                } elsif (CARRY_OVER_ELE) {
                    $ele = $prev_ele; # $prev_avail_ele; # will become $ELE[$i]
                    $resolution = "; using previous available value";
                    $flags |= SUBSTITUTED_ELE;
                } else {
                    $resolution = " and carrying over previous available value is disabled";
                }
                warn_trkpt("at segment start  ",
                    " no altitude ".($resolution =~ / using / ? "was " : "")."given$resolution");
            }
            if ($tim eq "") {
                if ($prev_tim eq "") {
                    $resolution = " and no previous value available";
                } elsif (CARRY_OVER_TIME) {
                    $tim = $prev_tim;    # will become $TIM[$i]
                    $sec = $prev_sec;    # will become $SEC[$i]
                    $flags |= SUBSTITUTED_TIM;
                    $resolution = "; using previous value";
                } else {
                    $resolution = " and carrying over previous value is disabled";
                }
                warn_trkpt("at segment start  ",
                           " no time     ".($resolution =~ / using / ? "was " : "")."given$resolution");
            }
        } else {    # state == 3, further (i.e., not the first) point in trkseg
            if ($ele eq "" && FILL_MISSING_ELE && ($ele_miss_start || $prev_ele ne "")) { # $prev_avail_ele
                ($ele_miss_start, $ele_miss_length) = ($i, 0)
                  if !$ele_miss_start; # $i is > 0
                $ele_miss_length += $dis;
            }

            # substitute missing time if posssible using previous time, recorded speed, and distance from previous point
            if (!defined $sec && defined $prev_sec && $spd ne "" && $dis > 0 && $spd > 0) {
                my $comp_sec = $prev_sec + $dis / $spd;
                $tim = epoch_to_str($comp_sec);    # will become $TIM[$i]
                $sec = $comp_sec;                  # will become $SEC[$i]
                warn_trkpt("at                ", " no time recognized, " .
                           " filled in using time difference calculated by distance / speed");
                $FLG[$i] |= SUBSTITUTED_TIM;
            } # any inconsistency where either $dis is (nearly) 0 or $spd is (nearly) 0 are covered by warning w.r.t. MAX_SPEED_DEVIATION

            if ($tim eq "" && FILL_MISSING_TIME && ($tim_miss_start ||
                                                    $prev_tim ne "")) # not $prev_avail_tim, which may be an earlier time
            {
                ($tim_miss_start, $tim_miss_length) = ($i, 0) if $tim_miss_start == 0; # $i is > 0
                $tim_miss_length += $dis;
            }
        }
        if ($ele ne "" && $ele_miss_start) { # fill in missing altitude
            my $i_end = $i;
            if ($state < 3)
            {    # have been carrying over ele to end of last section
                $i_end--;
            } else {   # state == 3, further (i.e., not the first) point in trkseg
                $ele_miss_length += $dis;
            }
            my $ele_curr = $ELE[$ele_miss_start - 1]; # $prev_avail_ele
            my $ele_diff = $ele - $ele_curr;
            # $ele_miss_length == 0 is special case of missing altitude over a stretch with all same lat/lon
            my $ele_gradient = $ele_miss_length > 0 ? $ele_diff / $ele_miss_length : $ele_diff / ($i - $ele_miss_start + 1);
            if ($ele_gradient != 0) {
                my $j;
                for ($j = $ele_miss_start; $j < $i_end; $j++) {
                    $ele_curr += ($ele_miss_length > 0 ? $DIS[$j] : 1) * $ele_gradient;
                    $ELE[$j] = sprintf ELE_PRECISION3, $ele_curr;
                    $ele_full_len = max($ele_full_len, length($ELE[$j]));
                    recalculate_all($j);
                    # not changing $ele nor $prev_ele such that below time interpolation is not affected
                    $FLG[$j] |= INTERPOLATED_ELE;
                    ## debug_log "interpolating missing ele at point $j $tim: new ele=$ELE[$j] dis=$DIS[$j] rate=$RAT[$j]";
                }
                if ($i_end < $i) {
                    recalculate_all($j);
                } else {
                    $dis = distance_curr($LAT[$j - 1], $LON[$j - 1], $ELE[$j - 1]); # recalculation
                }
            }
            $ele_miss_start = 0;
        }
        # note: cannot interpolate missing time within stretch of missing altitude with all same lat/lon; would need another pass
        if ($tim ne "" && $tim_miss_start) {    # fill in missing time by interpolation
            my $i_end = $i;
            if ($state < 3)
            {    # have been carrying over time to end of last section
                $i_end--;
            } else {   # state == 3, further (i.e., not the first) point in trkseg
                $tim_miss_length += $dis;
            }
            my $sec_curr = $SEC[$tim_miss_start - 1]; # corresponds to $prev_tim
            my $sec_diff = $sec - $sec_curr;
            # $tim_miss_length == 0 is special case of missing time over a stretch with all same position;
            # since altitude is interpolated in same iteration, a stretch with all same lat/lon looks like all same position
            my $sec_gradient = $tim_miss_length > 0 ? $sec_diff / $tim_miss_length : $sec_diff / ($i - $tim_miss_start + 1);
            if ($sec_gradient != 0) {
                my $j;
                ## debug_log "interpolating missing time over ".dis_string($tim_miss_length).", sec_diff = $sec_diff";
                for ($j = $tim_miss_start; $j < $i_end; $j++) {
                    $sec_curr += ($tim_miss_length > 0 ? $DIS[$j] : 1) * $sec_gradient;
                    $SEC[$j] = $sec_curr;
                    $TIM[$j] = epoch_to_str($sec_curr);
                    recalculate_SPD($j);
                    recalculate_RAT($j);
                    $FLG[$j] |= INTERPOLATED_TIM;
                    ## debug_log "interpolating missing time at point $j with ele=$ELE[$j] new  time=$TIM[$j] dis=$DIS[$j] rate=".($RAT[$j] // "");
                }
                if ($i_end < $i) {
                    recalculate_SPD($j);
                    recalculate_RAT($j);
                }
            }
            $tim_miss_start = 0;
        }
        my $diff_ele = $i > 0 ? diff_nonempty($ele, $ELE[$i - 1]) : "";
        my $diff_sec = $i > 0 ? diff_defined ($sec, $SEC[$i - 1]) : undef;

        push @IGN, 0;
        push @SEG, $state < 3;
        push @FLG, $flags;
        push @LAT, $lat;
        push @LON, $lon;
        push @ELE, $ele;
        push @TIM, $tim;
        push @SEC, $sec;
        push @DIS, $dis;
        push @RAT, rate($diff_ele, $diff_sec);
        push @SPD, $spd; # initially as recorded, "" if not available
        push @CMT, $cmt;
        push @SRC, $src;
        push @FIX, $fix;
        push @EXT, $exts;

        # detect and report missing time and/or altitude
        my $ele_solution  = "cannot calculate ascent/descent";
        $ele_solution  = "trying to interpolate altitude" if $ele_miss_start;

        if ($ele eq "") {
            $num_no_ele++;
            $ele_gap_length += $dis; # using $dis == 0 for first point
            warn_trkpt("no altitude     at", "; $ele_solution") if !$SEG[$i] && $num_no_ele == 1;
        } elsif ($num_no_ele) {
            # unfortunately, this message may show after initial ones on next segment:
            warn_trkpt_i($i - 1, "no altitude  up to", " for ".points($num_no_ele)." over a distance of ".dis_string($ele_gap_length));
            $num_no_ele     = 0;
            $ele_gap_length = 0;
        }

        my $time_solution = "cannot calculate speed and acceleration";
        $time_solution = "trying to interpolate time" if $tim_miss_start;
        unless (defined $sec) {
            $num_no_time++;
            $time_gap_length += $dis; # using $dis == 0 for first point
            warn_trkpt("no time         at", "; $time_solution") if !$SEG[$i] && $num_no_time == 1;
        } elsif ($num_no_time) {
            # unfortunately, this message may show after initial ones on next segment:
            warn_trkpt_i($i - 1, "no time      up to", " for ".points($num_no_time)." over a distance of ".dis_string($time_gap_length));
            $num_no_time     = 0;
            $time_gap_length = 0;
        }
        my $sec_str = defined $sec ? epoch_to_str($sec) : "";
        abort("FATAL: internally inconsistent time data for trkpt ".($i + 1).": tim=$tim != $sec_str (=$sec)")
            if $tim =~ s/(\.\d*?)0+Z/$1Z/r ne $sec_str =~ s/(\.\d*?)0+Z/$1Z/r &&
            !($tim =~ m/\.999Z/ && defined $sec && $tim eq epoch_to_str($sec - 0.001));

        # will go wrong if previous trkpt gets ignored: $ELE[$#ELE] = $ELE[$#ELE-1] if $ele eq "" && !$SEG[$#ELE]; # implies $#ELE > 0
        $i++;
        ($prev_lat, $prev_lon, $prev_ele, $prev_tim, $prev_sec) =
        (     $lat,      $lon,      $ele,      $tim,      $sec);
        $prev_avail_ele = $ele if $ele ne "";

     # Commenting out $prev_avail_tim as it is currently unused, but referred to
     # in another comment
     # $prev_avail_tim = $tim if $tim ne "";

        $prev_avail_sec = $sec if defined $sec; # enables checking negative time difference also across missing time entries
        $state = 3; # ready to process further trkpt(s) in trkseg (or new trkseg or new track)
    }
    if (!$in_merge && m#</trkseg>.*<trkseg>#s) {
        info_trkpt_i($i - 1, "end of  segment at", "") if $i > 0;
        $state = 2; # starting new trkseg
        # reset intra-segment values
    }
    if ($i > 0 && !$in_merge && m#<trk>#) { # further track
        info("further track, again from file $ARGV") unless m#<gpx[ >]#s;
    }
    if ($in_merge < 0) {
        $in_merge = $merge = 0;
        close M;
    }
}
my $Len = dis_string($ele_gap_length); # TODO restrict scope
warn_trkpt_i($#TIM, "no altitude  up to",
             " for " . $num_no_ele . " points over a distance of $Len") if $num_no_ele > 1;
$Len = dis_string($time_gap_length);
warn_trkpt_i($#TIM, "no time      up to",
             " for " . $num_no_time . " points over a distance of $Len") if $num_no_time > 1;
info_trkpt("last   segment end", "") if $#TIM >= 0;
warn_trkpt("                at",
           " was unable to interpolate missing altitude by end of last segment") if $ele_miss_start;
warn_trkpt("                at",
           " was unable to interpolate missing time by end of last segment") if $tim_miss_start;
} # end TODO re-format


## sanitize trackpoints with implausible data, silently ignoring previously inserted or duplicated points

my ($num_removals_ele, $num_removals_dir, $num_removals_spd, $num_removals_acc, $num_removals_dec,
    $num_removals_gain, $num_removals_loss, $num_removals_diff) = (0, 0, 0, 0, 0, 0, 0, 0);
if ($sanitize) { # TODO re-format
my $num_removals_in_row = 0;
my $prev_ignore = 0;
my $sum_timediff_mov0 = 0;
my $num_pts_mov       = 0;
my ($prev_timediff, $timediff, $prev_dis, $dis) = ("", "", "", "");
$spd = "";
for (my $acc, my $rate, my $i = 0; $i <= $#TIM; $i++) {

    # silently ignore any point inserted or duplicated by a previous run of this tool
    while ($SRC[$i] =~ m#(^|\W)bridging time gap($|\W)# && $FIX[$i] =~ m#(^|\W)none($|\W)#) {
        remove_trkpt($i, $i, 1);
    }
    ($lat    , $lon    , $ele    , $tim    , $sec    , $spd    ) =
    ($LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i], $SPD[$i]);

    debug_log "consider sanitizing ".point_str($i)." spd=".spd_or_none($spd);
    my ($ignore, $ignore_before) = (0, 0);
    sub ignore_trkpt        { ignoring_trkpt(  -1, @_); }
    sub ignore_trkpt_before { ignoring_trkpt($i-1, @_); }
    sub ignoring_trkpt { my ($index, $Spd, $reason) = @_;
        my $Spd_txt = $Spd eq "" ? "" : " at speed = $Spd km/h";
        warn_trkpt_i($index, "ignoring", "$Spd_txt because $reason");
    }

    # debug "$i $tim $num_removals_in_row vs. $IGN[$i - 1] $IGN[$i]";
    # must delay report by one point because current point may be ignored in next iteration,
    # yet better report before any output on current point being ignored
    sub report_ignored_in_row {
        my $num_removals_in_row2 = $i == 0 ? 0 : $IGN[$i - 1];
        my $prev_not_ignored = $IGN[$i] == 0;
        # warning("ignored $num_removals_in_row2 points in a row") if $num_removals_in_row2 > 1 && $prev_not_ignored;
        if (!$ignore_before && !$prev_ignore) { # previous point not ignored this time and in iteration before
            abort("FATAL: internal inconsistency on number of most recent removals in a row: ".
                  "$num_removals_in_row vs. $num_removals_in_row2, condition 1 vs. $prev_not_ignored")
                if $num_removals_in_row != $num_removals_in_row2 || !$prev_not_ignored;
            warning("ignored $num_removals_in_row points in a row") if $num_removals_in_row > 1;
            $num_removals_in_row = 0;
        } elsif ($prev_not_ignored) {
            abort("FATAL: internal inconsistency on condition for reporting number of most recent removals in a row");
        }
    }

    # handle case(s) that do not involve earlier points and lead to removing current point
    if ($ele ne "" && $ele < MIN_PLAUSIBLE_ELE) {
        $num_removals_ele++;
        $ignore = 1;
        report_ignored_in_row();
        ignore_trkpt("", "altitude is less than ".MIN_PLAUSIBLE_ELE);
    } elsif ($spd ne "" && ($spd < 0 || MPS2KMPH * $spd > $MAX_PLAUSIBLE_SPEED)) {
        $num_removals_spd++;
        $ignore = 1;
        report_ignored_in_row();
        ignore_trkpt(spd_string($spd), "recorded speed is ". ($spd < 0 ? "negative" : "higher than ".$MAX_PLAUSIBLE_SPEED));
    } elsif ($SEG[$i]) {
        report_ignored_in_row();
    }

    my $comp_spd = "";
    if (!$ignore && !$SEG[$i]) { # not already ignoring current point, not at segment start
        (my $diff_ele, $timediff, $rate, $dis, $comp_spd, $acc) = comp_diffs($i);
        my ($theta_diff, $Spd2) = (0, "");
        if (!$SEG[$i - 1]) { # previous point not at segment start, implies $i >= 2 here
            my $timediff2 = $prev_timediff eq "" || $timediff eq "" ? 0 : $prev_timediff + $timediff;
            my      $dis2 =      $prev_dis eq "" ||      $dis eq "" ? 0 :      $prev_dis +      $dis;
            my $spd2 = $timediff2 <= 0 || $dis2 <= 0 ? "" : $dis2 / $timediff2; # average speed between three most recent points
            $spd_prec_len = max($spd_prec_len, length(spd_str($spd2))) if $spd2 ne ""; # used only for spd_string
            if ($spd2 ne "" && MPS2KMPH * $spd2 > MAX_PLAUSIBLE_ANGLE_SPD_THRESHOLD) {
                # calculate horizontal direction change (i.e., turning angle) for spike detection
                my $resultion = .00001; # corresponds to at most 1.11 m
                my ($prev_lat, $prev_lon) = ($LAT[$i - 1], $LON[$i - 1]);
                my $prev_lon_diff = nearest($resultion, $prev_lon - $LON[$i - 2]);
                my $prev_lat_diff = nearest($resultion, $prev_lat - $LAT[$i - 2]);
                my $curr_lon_diff = nearest($resultion,      $lon - $prev_lon   );
                my $curr_lat_diff = nearest($resultion,      $lat - $prev_lat   );
                if ($prev_lon_diff && $prev_lat_diff && $curr_lon_diff && $curr_lat_diff)
                {
                    my $theta1 = atan2($prev_lon_diff, $prev_lat_diff);
                    my $theta2 = atan2($curr_lon_diff, $curr_lat_diff);
                    $theta_diff = ($theta2 - $theta1) * RAD2DEG % 360;
                    $theta_diff -= 360 if $theta_diff >= 180;
                }
                $Spd2 = spd_string($spd2);
            }
        }

        my $Theta_diff = sprintf "%+.0f", $theta_diff;
        my $Comp_spd = spd_string($comp_spd) if $comp_spd ne "";
        if ($comp_spd ne "" && $spd ne "" && $timediff ne "" && $timediff <= MAX_TIMEDIFF_RECORDED_SPEED) {
            my $spd_diff = abs($comp_spd - $spd);
            $spd_prec_len = max($spd_prec_len, length(spd_str($spd_diff))); # used only for spd_string
            $sum_speed_deviation += $spd_diff;
            $sum_speed += $comp_spd + $spd; # will later divide by 2 for average;
            warn_trkpt("before  ",
                       " recorded speed is ".spd_string($spd).", computed speed is $Comp_spd, ".
                       "deviation is " . spd_string($spd_diff) . " km/h" .
                       " (more than " . $MAX_SPEED_DEVIATION . ")") if $spd_diff > ($MAX_SPEED_DEVIATION + 0.5) / MPS2KMPH;
        }
        # from now on, use for $spd and $SPD[$i] the computed speed (average since previous point) if recorded speed is not available or previous point is not very recent
        if ($spd eq "" || $timediff ne "" && $timediff > MAX_TIMEDIFF_RECORDED_SPEED) {
            $SPD[$i] = $spd = $comp_spd;
            $FLG[$i] |= COMPUTED_SPEED if $comp_spd ne "";
        }

        my $Spd      = $spd ne "" ? spd_string($spd) : "";
        my $Spd_txt  = $spd ne "" ? " at speed = $Spd km/h" : "";
        my $Dis      = dis_string($dis);
        my $Rate     = $rate ne "" ? sprintf RAT_PRECISION, $rate : "";
        my $Acc      = $acc ne "" ? sprintf ACC_PRECISION, $acc : "";
        my $Dec      = $acc ne "" ? sprintf ACC_PRECISION, -$acc : "";
        warn_trkpt("before  ", "$Spd_txt distance between points = $Dis (more than ".(WARNING_TPT_DIST / 1000).")") if $dis > WARNING_TPT_DIST;

        # handle case(s) that involve (one or) two points before and may lead to removing point before
        if (MAX_PLAUSIBLE_ANGLE_DIFF < abs($theta_diff)) {
            $num_removals_dir++;
            ignore_trkpt_before($Spd2, "direction change = $Theta_diff° (".($theta_diff >= 0 ? "more than  " : "less than -").MAX_PLAUSIBLE_ANGLE_DIFF."°)");
            $ignore_before = 1;
        }
        report_ignored_in_row();
        if ($ignore_before) {
            $num_removals_in_row++;
            remove_trkpt($i - 1, $i); # also recalculates speed etc. of former point $i relative to its new previous point
            $i--;
        }

        # handle cases that involves point before may lead to removing current point
        $ignore = 1; # tentatively indicate removal of current point
        if ($spd ne "" && $Spd > $MAX_PLAUSIBLE_SPEED) {
            $num_removals_spd++;
            ignore_trkpt($Spd, "speed is higher than ".$MAX_PLAUSIBLE_SPEED);
        } elsif ($acc ne "" &&  $acc > $MAX_PLAUSIBLE_ACCEL &&
                 ($FLG[$i - 1] & INTERPOLATED_TIM) == ($FLG[$i] & INTERPOLATED_TIM)) {
            $num_removals_acc++;
            ignore_trkpt($Comp_spd, "acceleration = $Acc m/s/s (more than $MAX_PLAUSIBLE_ACCEL)");
        } elsif ($acc ne "" && -$acc > $MAX_PLAUSIBLE_DECEL &&
                 ($FLG[$i - 1] & INTERPOLATED_TIM) == ($FLG[$i] & INTERPOLATED_TIM)) {
            $num_removals_dec++;
            ignore_trkpt($Comp_spd, "deceleration = $Dec m/s/s (more than $MAX_PLAUSIBLE_DECEL)");
        } elsif ($rate ne "" && $rate > $MAX_PLAUSIBLE_ELE_GAIN) {
            $num_removals_gain++;
            ignore_trkpt($Spd, " ascent rate = $Rate m/h (more than  $MAX_PLAUSIBLE_ELE_GAIN)");
        } elsif ($rate ne "" && $rate < -$MAX_PLAUSIBLE_ELE_LOSS) {
            $num_removals_loss++;
            ignore_trkpt($Spd, "descent rate = $Rate m/h (less than -$MAX_PLAUSIBLE_ELE_LOSS)");
        } elsif ($timediff ne "" && $timediff < $MIN_TIMEDIFF &&
                 ($FLG[$i - 1] & INTERPOLATED_TIM) == ($FLG[$i] & INTERPOLATED_TIM))
        {
            my $inter = $FLG[$i] & INTERPOLATED_TIM ? "interpolated " : "";
            $num_removals_diff++;
            ignore_trkpt($Spd, $inter."time difference = $timediff sec (less than $MIN_TIMEDIFF)");
            #" over a distance of $Dis" if $timediff > 1.001
        } else {
            $ignore = 0;
            if (!$ignore_before && $timediff ne "" && $spd ne "" && $spd >= MIN_SPEED_MOVING / MPS2KMPH)
            {
                $sum_timediff_mov0 += $timediff; # used for smoothing
                $num_pts_mov++;                  # used for smoothing
            }
        }
    }

    if ($ignore) {
        $num_removals_in_row++;
        remove_trkpt($i, $i); # also recalculates speed etc. of former point $i + 1 relative to its new previous point
        $i--;
    }
    if ($ignore_before) {
        if ($timediff ne "") {
            $timediff += $prev_timediff if $prev_timediff ne "";
        } else {
            $timediff = $prev_timediff;
        }
        if ($dis ne "") {
            $dis += $prev_dis if $prev_dis ne "";
        } else {
            $dis = $prev_dis;
        }
    }
    ($prev_ignore, $prev_timediff, $prev_dis) = ($ignore, $timediff, $dis);
}
my $num_removals_in_row_final = $IGN[$#TIM + 1] // 0;
# warning("ignored $num_removals_in_row_final points in a row") if $num_removals_in_row_final > 1;
abort("FATAL: internal inconsistency on reporting number of final removals in a row: ".
      "$num_removals_in_row vs. $num_removals_in_row_final")
    if $num_removals_in_row != $num_removals_in_row_final;
warning("ignored $num_removals_in_row points in a row") if $num_removals_in_row > 1;
# note that in the GPX output information on points sanitzed at the end of the track will get lost

$avg_timediff = $num_pts_mov ? $sum_timediff_mov0 / $num_pts_mov : 0; # used for smoothing
# $sum_timediff_mov will be recalculated thereafter, since points may have been ignored or smoothened
} # end TODO re-format

abort("FATAL: no trackpoint (possibly after ignoring some)") if $#TIM < 0;


sub check_waypoints {
    for (my $j = 0; $j <= $#WSEC; $j++) {
        $sec = $WSEC[$j];
        unless (defined $sec) {
            warning("waypoint $WSTR[$j] does not have time information; skipping proximity check");
            next;
        }
        if ($j > 0 && (diff_defined($sec, $WSEC[$j - 1]) // 0) < 0) {
            warning("waypoint $WSTR[$j] has earlier time than the waypoint found before: $WSTR[$j - 1]");
        }
        if ($#TIM < 0) { # can not happen due to above check
            warning("no trackpoint found for checking waypoints");
            last;
        }
        # find trackpoint $i2 at or just after wpt
        my $i2 = 0; # would be more efficient to do this just before the wpt loop, but then cannot deal with wpts not in time order
        my $i1; # most recent trackpoint having time info, otherwise undefined; ulimately becomes same as $i2 if no such trackpoint exists
        while ($i2 <= $#TIM && (!defined $SEC[$i2] || $SEC[$i2] < $sec))
        {
            $i1 = $i2 if defined $SEC[$i2];
            $i2++;
        }
        $i2 = $#TIM if $i2 > $#TIM;
        $i1 = $i2 unless defined $i1;

        my ($wlat, $wlon, $wele) = ($WLAT[$j], $WLON[$j], $WELE[$j]);
        next if $LAT[$i1] == $wlat && $LON[$i1] == $wlon && $ELE[$i1] eq $wele; # late finishing point
        next if $LAT[$i2] == $wlat && $LON[$i2] == $wlon && $ELE[$i2] eq $wele; # early starting point
        # due to time possibly carried over across segement end and start of next segment, wpt may match next trkpt:
        next if $i2 < $#TIM && $SEC[$i2] == $sec && defined $SEC[$i2 + 1] && $SEC[$i2 + 1] == $sec
            && $LAT[$i2 + 1] == $wlat && $LON[$i2 + 1] == $wlon && $ELE[$i2 + 1] eq $wele;
        warning("no trackpoint found at same time or later than waypoint $WSTR[$j]; will ".
                ($i1 < $i2 ? "extrapolate distance from the one before" : "take the difference from the last one"))
            if $i2 == $#TIM;

        # calculate and report distance to nearest trackpoint
        my $diff_sec_i2_i1 = diff_defined($SEC[$i2], $SEC[$i1]);
        my $linear_factor = $diff_sec_i2_i1 ? ($sec - $SEC[$i1]) / $diff_sec_i2_i1 : 0;
        $lat = $LAT[$i1] + ($LAT[$i2] - $LAT[$i1]) * $linear_factor;
        $lon = $LON[$i1] + ($LON[$i2] - $LON[$i1]) * $linear_factor;
        my $ele2 = $ELE[$i2] eq "" ? ($WELE[$j] eq "" ? $ELE[$i1] : $WELE[$j]) : $ELE[$i2];
        my $ele1 = $ELE[$i1] eq "" ? $ele2 : $ELE[$i1];
        $ele = $ele1 eq "" || $ele2 eq "" ? ""
            : $ele1 + ($ele2 - $ele1) * $linear_factor;
        my $dis = distance_curr($wlat, $wlon, $wele);
        $tim = "NO"; # do not print time for interpolated positon, since done already for wpt
        warn_trkpt("according to its time information, waypoint $WSTR[$j] appears not close to track "
              . "(interpolated distance = ".(sprintf "%.0f", $dis)." m > " . WARNING_WPT_DIST . "); "
              . "it should be approximately at", "")
          if $dis > WARNING_WPT_DIST;
    }
}
check_waypoints();

## smoothen trackpoints

# smoothen each point, by weightened average with (smoothened) previous point and (original) next point
sub average {

    sub weight {
        #   my $d = 1.5*$avg_timediff; # max dist of influence
        #   return max(0, ($d-$_[0])/$d);
        return 1 / (1 + $_[0] / $avg_timediff);
    }
    my $x1 = $_[0];
    my $x  = $_[1];
    my $x2 = $_[2];
    my $diff_time1 = $_[3];
    my $diff_time2 = $_[4];

    #return $x;
    return ($x1 * weight($diff_time1) + $x + $x2 * weight($diff_time2)) /
      (weight($diff_time1) + 1 + weight($diff_time2));
}

if ($smoothing) {
    my $pending_recalculation = 0;
    my $i;
    for ($i = 1; $i < $#TIM; $i++) {
        my $sec = $SEC[$i];
        my $diff_time1 = diff_defined($sec, $SEC[$i - 1]);
        my $diff_time2 = diff_defined($SEC[$i + 1], $sec);
        if (defined $diff_time1 && defined $diff_time2 && !$SEG[$i] && !$SEG[$i + 1] && max($diff_time1, $diff_time2) <= SMOOTHING_MAX_GAP) {
            my ($prev_ele, $ele, $next_ele) = ($ELE[$i - 1], $ELE[$i], $ELE[$i + 1]);
            $LAT[$i] = average($LAT[$i - 1], $LAT[$i], $LAT[$i + 1], $diff_time1, $diff_time2);
            $LON[$i] = average($LON[$i - 1], $LON[$i], $LON[$i + 1], $diff_time1, $diff_time2);
            $ELE[$i] = average($prev_ele   , $ele    , $next_ele   , $diff_time1, $diff_time2)
                if $prev_ele ne "" && $ele ne "" && $next_ele ne "";
            recalculate_all($i);
            $pending_recalculation = 1;
            # individiual points are not marked as smoothened; this is done globally
            $num_smoothened++;
        } elsif ($pending_recalculation) {
            recalculate_all($i);
            $pending_recalculation = 0;
        }
    }
    recalculate_all($i) if $pending_recalculation;
}

## perform general statistics, optionally also for parts (segements or days)
## with optional ascent/descent phase analysis and optional energy calculation

my $num_energy_missing = 0;
my $energy_missing_ele = 0;
my $energy_missing_spd = 0;
sub energy { # calculate energy difference between trackpoints  # TODO simplify provisioning of parameters using index
    my $i  = $_[0];                # index of end of the current span between points with assumed linear movement
    my $t0 = $_[1];                # start time in s (relative to begin of track)
    my $t1 = $_[2];                # end   time in s (relative to begin of track)
    my $dt = $t1 - $t0;            # duration in s
    my $d  = $_[3];                # 3-dimensional distance in m
    my $h0 = $_[4];                # altitude before in m
    my $h1 = $_[5];                # altitude after  in m
    if ($h0 eq "" || $h1 eq "") {
        # $h0 = $h1 = 500;         # default altitude in m assumed for calculating density
        warn_trkpt_i($i, "no altitude   near", "; cannot calculate energy") if $energy_missing_ele < 2;
        $energy_missing_ele++;
        $num_energy_missing++;
        return 0;
    }
    my $dh =  $h1 - $h0;           # altitude difference (or 0 if default elevation used)
    my $h  = ($h0 + $h1) / 2;      # average altitude, used for air density
    my $v0 = $_[6];                # speed before in m/s
    my $v1 = $_[7];                # speed after  in m/s
    if ($v0 eq "" || $v1 eq "") {  # $v1 eq "" cannot happen because times are present, lat/lon are guaranteed to be there, just ele may be missing
        # $v0 = $v1 = 0;           # default speed in m/s assumed for calculating acceleration and air drag
        warn_trkpt_i($i, "no speed info near", "; cannot calculate energy") if $energy_missing_spd < 2;
        $energy_missing_spd++;
        $num_energy_missing++;
        return 0;
    }
    my $v  = ($v0 + $v1) / 2;      # average speed, used for air drag, assumed with no wind (i.e., calm air)
    my $g = 9.81;                  # gravity constant in m/(s^2)

# values and formulas adapted from https://www.sheldonbrown.com/rinard/aero/formulas.html
    my $m = $weight;               # total mass including vehicle and rider in kg
    my $cr = 0.003;                # coefficient of rolling friction for racing bike      - adapt
    my $cdA = 0.39;                # coefficient of wind resistance * frontal area in m^2 - adapt
    my $r = 1.2;                   # air density on average weather (20 °C) at sea level in kg/(m^3)
    my $density = $r - (0.55 * $r) * $h / 5000; # roughly corrected air density depending on altitude

    # energy components and their sum along the distance $d in Joule
    my $roll  = $cr * $m * $g * $d;
    my $slope = $m * $g * $dh;
    my $accel = $m / 2 * ($v1 * $v1 - $v0 * $v0);
    my $drag  = $density * $cdA / 2 * $v * $v * $d;
    my $sum   = $roll + $slope + $accel + $drag;

    ## my $debug_inputs = "dt=" . int($dt) . " d=" . int($d) . " dh=" . int($dh) . " v0=" . int($v0) . " v1=" . int($v1);
    ## my $debug_outputs = "roll:" . int($roll) . " + slope:" . int($slope) . " + accel:" . int($accel) . " + drag:" . int($drag) . " = sum:" . int($sum);
    ## debug "energy @ time=$t  $debug_inputs   =>   $debug_outputs";

    return $sum;
}

sub push_phase {
    my $start_index    = $_[0];
    my $end_index      = $_[1];
    my $sec1           = $SEC[$start_index];
    my $sec2           = $SEC[$end_index];
    my $duration        = diff_defined($sec2, $sec1);
    my $diff_ele       = $ELE[$end_index] - $ELE[$start_index];
    my $dist           = 0;
    my $rate           = 0;
    my $spd_           = 0;
    my $max_rate       = 0;
    my $max_rate_index;
    my $max__spd       = 0;
    my $max__spd_index;

    for (my $i = $start_index + 1; $i <= $end_index; $i++) {
        $dist += $DIS[$i];
        $rate  = $RAT[$i];
        $spd_ = $SPD[$i];
        ($max_rate, $max_rate_index) = ($rate, $i) if $rate ne "" && ($diff_ele >= 0 ? $rate > $max_rate : $rate < $max_rate);
        ($max__spd, $max__spd_index) = ($spd_, $i) if $spd_ ne "" && $spd_ > $max__spd;
    }
    my $avg_spd  = $duration ? $dist / $duration : "";
    my $avg_rate = rate($diff_ele, $duration);
    push @PHASE_DURATION,       $duration;
    push @PHASE_DIFF,           $diff_ele;
    push @PHASE_DIST,           $dist;
    push @PHASE_SPD,            $avg_spd;
    push @PHASE_RATE,           $avg_rate;
    push @PHASE_MAX_SPD_INDEX,  $max__spd_index;
    push @PHASE_MAX_RATE_INDEX, $max_rate_index;
    push @PHASE_END_INDEX,      $end_index;
}

# prepare optional statistics for parts (segements or days)
$part_start  = 1 unless defined $part_start;
$part_offset = 0 unless defined $part_offset;
my $part;
my $part_or_all = my $all = $part_start - 1;
sub next_part {
    $part = $part_or_all = $_[0]          if $_[0] >= $part_start;
    ($part, $part_or_all) = (undef, $all) if defined $part_end && $_[0] > $part_end;
}
my $seg = 0 if $segs;
my $day = 0, my $prev_date, my $date if $days;
my ($part_start_sec, $part_end_sec);

for (my $direction, my $prev_sec, my $timediff,
     my $prev_turn_index, my $prev_turn_ele, my $prev_turn_sec,
     my $local_max_index = 0, my $local_min_index = 0,
     my $local_max_sec, my $local_min_sec,
     my $local_max_ele = "", my $local_min_ele = "",
     my $i = 0; $i <= $#TIM; $i++) {
    ($lat    , $lon    , $ele    , $tim    , $sec , my $dis , my $spd    ) =
    ($LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i], $DIS[$i], $SPD[$i]);
    if (!$SEG[$i]) {
        $prev_sec = $SEC[$i - 1];
        $timediff = diff_defined($sec, $prev_sec) // "";
    }

    # local inititialization of optional statistics for parts (segements or days)
    my $new_part = 0;
    $date = $1 if $days && $tim =~ m/^(.*?)T/;
    $new_part = 1
        if ($days && ($i == 0 || (defined $date && defined $prev_date
                                  && $date ne $prev_date))); # assuming that dates, as far as available, are ascending
    $new_part = 1 if $segs && $SEG[$i];
    $DURATION[$part] = diff_defined($part_end_sec, $part_start_sec)
        if defined $part && ($new_part || $i == $#TIM); # implies $i != 0
    next_part(++$day) if $new_part && $days;
    next_part(++$seg) if $new_part && $segs;
    if (defined $part && $new_part) {
        $PART_START_INDEX[$part] = $i; # so far unused
        $part_start_sec = $part_end_sec = $SEC[$i];
    } else {
        $part_start_sec = $part_end_sec = $SEC[$i] unless defined $part_start_sec;
    }
    # preliminary values are updated on each iteration:
    $part_end_sec = $SEC[$i] if defined $SEC[$i];
    $PART_END_INDEX[$all ] = $i;
    $PART_END_INDEX[$part] = $i if defined $part;

    if ($SEG[$i]) { # track segment start (which includes the start: $i == 0)
        # (re-)start climb phase recognition
        $direction       = 0;
        $prev_turn_ele   = $local_max_ele   = $local_min_ele = "";
    }
    if ($ele ne "") {
        ($prev_turn_ele, $prev_turn_index) = ($ele, $i) if $prev_turn_ele eq "";
        ($local_max_ele, $local_max_index) = ($ele, $i) if $direction >= 0
            && ($local_max_ele eq "" || $ele > $local_max_ele);
        ($local_min_ele, $local_min_index) = ($ele, $i) if $direction <= 0
            && ($local_min_ele eq "" || $ele < $local_min_ele);
    }
    if (!$SEG[$i]) { # not at segment start
      check_next:
        $prev_turn_sec = $SEC[$prev_turn_index];
        $local_max_sec = $SEC[$local_max_index];
        $local_min_sec = $SEC[$local_min_index];
        my $at_end = $i == $#TIM || $SEG[$i + 1] || $ELE[$i + 1] eq ""; # at track or segment end or just before missing altitude data
        if ($direction >= 0 && $local_max_index > $prev_turn_index
             && ($at_end || $ele ne "" && $ele <= $local_max_ele - ELE_THRESHOLD))
        {    # at end or when actually starting going down
            my $diff_ele = $local_max_ele - $prev_turn_ele;
            if ($diff_ele >= ELE_THRESHOLD) {
                if ($phases && $diff_ele >= $PHASES_REPORT_THRESHOLD) {
                    push_phase($prev_turn_index, $local_max_index);
                } else {
                    $ascent__phases_suppressed++;
                }
                $SUM__ASCENT[$all ] += $diff_ele;
                $SUM__ASCENT[$part] += $diff_ele if defined $part;
                if (defined $local_max_sec && defined $prev_turn_sec) {
                    my $diff_sec = $local_max_sec - $prev_turn_sec;
                    $TIME__ASCENT[$all ] += $diff_sec;
                    $TIME__ASCENT[$part] += $diff_sec if defined $part;
                } else {
                    $MISSING__ASCENT_TIME[$all ]++;
                    $MISSING__ASCENT_TIME[$part]++ if defined $part;
                }
                $LAST_GAIN_INDEX[$all] =
                $LAST_GAIN_INDEX[$part_or_all] = $local_max_index;
            }
            ($prev_turn_ele, $prev_turn_index) = ($local_max_ele, $local_max_index);
            ($local_min_ele, $local_min_index) = ($ele, $i);
            $direction = -1;
            goto check_next;
        } elsif ($direction <= 0 && $local_min_index > $prev_turn_index
            && ($at_end || $ele ne "" && $ele >= $local_min_ele + ELE_THRESHOLD))
        {    #  at end or when actually starting going up
            my $diff_ele = $local_min_ele - $prev_turn_ele;
            if (-$diff_ele >= ELE_THRESHOLD) {
                if ($phases && -$diff_ele >= $PHASES_REPORT_THRESHOLD) {
                    push_phase($prev_turn_index, $local_min_index);
                } else {
                    $descent_phases_suppressed++;
                }
                $SUM_DESCENT[$all ] += $diff_ele;
                $SUM_DESCENT[$part] += $diff_ele if defined $part;
                my $diff_sec = diff_defined($local_min_sec, $prev_turn_sec);
                if (defined $diff_sec) {
                    $TIME_DESCENT[$all ] += $diff_sec;
                    $TIME_DESCENT[$part] += $diff_sec if defined $part;
                } else {
                    $MISSING_DESCENT_TIME[$all ]++;
                    $MISSING_DESCENT_TIME[$part]++ if defined $part;
                }
                $LAST_LOSS_INDEX[$all] =
                $LAST_LOSS_INDEX[$part_or_all] = $local_min_index if $ele ne "";
            }
            ($prev_turn_ele, $prev_turn_index) = ($local_min_ele, $local_min_index);
            ($local_max_ele, $local_max_index) = ($ele, $i);
            $direction = 1;
            goto check_next;
        }
    }
    if (!$SEG[$i]) { # not at segment start, implies $i >= 1
        if ($debug) {
            (my $diff_ele_unused, my $td, my $rate, my $dis, my $comp_spd_unused, my $acc_unused) = comp_diffs($i);
            my $rate_str = $rate eq "" ? "" : sprintf "%.3f", $rate;
            debug_log "phase analysis ".point_str($i)." dis=".(sprintf "%.3f", $dis)." rate=$rate_str spd=".spd_or_none($spd);
            my $msg = "FATAL: internal inconsistency on ";
            abort("$msg time difference: '$timediff' vs. '$td'") if $timediff ne $td;
            abort("$msg distance value:". " $DIS[$i] vs. $dis" ) if abs($DIS[$i] -  $dis) > 0.001;
            abort("$msg rate" ." value: '$RAT[$i]' vs. '$rate'") if $RAT[$i] ne $rate;
        }

        if ($weight) {
            unless (defined $sec && defined $prev_sec) {
                warn_trkpt_i($i, "no time     ".(defined $sec ? "before" : "    at"), "; cannot calculate energy here");
                $num_energy_missing++;
            } else {
                my $start_sec = $SEC[0] // 0; # used just for smaller time arguments to sub energy()
                $sum_energy += energy($i, $prev_sec - $start_sec, $sec - $start_sec,
                                      $dis, $ELE[$i - 1], $ele, $SPD[$i - 1], $spd);
            }
        }
    }

    # perform general statistics, optionally also for parts (segements or days)
    $min_lat = $lat if $i == 0 || $min_lat > $lat;
    $max_lat = $lat if $i == 0 || $max_lat < $lat;
    $min_lon = $lon if $i == 0 || $min_lon > $lon;
    $max_lon = $lon if $i == 0 || $max_lon < $lon;
    $min_tim = $tim if $min_tim eq ""    || defined $sec && $sec < $min_sec;
    $min_sec = $sec if !defined $min_sec || defined $sec && $sec < $min_sec;
    $max_tim = $tim if $max_tim eq ""    || defined $sec && $sec > $max_sec;
    $max_sec = $sec if !defined $max_sec || defined $sec && $sec > $max_sec;
    if ($ele ne "") {
        ($MIN_ELE[$all ], $MIN_ELE_INDEX[$all ]) = ($ele , $i) if !defined $MIN_ELE[$all ] || $MIN_ELE[$all ] > $ele;
        ($MAX_ELE[$all ], $MAX_ELE_INDEX[$all ]) = ($ele , $i) if !defined $MAX_ELE[$all ] || $MAX_ELE[$all ] < $ele;
        if (defined $part) {
        ($MIN_ELE[$part], $MIN_ELE_INDEX[$part]) = ($ele , $i) if !defined $MIN_ELE[$part] || $MIN_ELE[$part] > $ele;
        ($MAX_ELE[$part], $MAX_ELE_INDEX[$part]) = ($ele , $i) if !defined $MAX_ELE[$part] || $MAX_ELE[$part] < $ele;
        }
    }
    if ($spd ne "") { # may be meaningful also at segment start: recorded speed
        ($MAX_SPD[$all ], $MAX_SPD_INDEX[$all ]) = ($spd, $i) if (!defined $MAX_SPD[$all ] || $MAX_SPD[$all ] < $spd);
        ($MAX_SPD[$part], $MAX_SPD_INDEX[$part]) = ($spd, $i) if defined $part
                                                              && (!defined $MAX_SPD[$part] || $MAX_SPD[$part] < $spd);
    }
    if (!$SEG[$i]) {
        $SUM_DIS[$all ] += $dis;
        $SUM_DIS[$part] += $dis if defined $part;
        if ($spd ne "" && $timediff ne "" && $spd >= MIN_SPEED_MOVING / MPS2KMPH) {
            $sum_dis_mov      += $dis;
            $sum_timediff_mov += $timediff;
        }
        my $rate = $RAT[$i];
        if ($rate ne "") {
            ($MAX_GAIN[$all ], $MAX_GAIN_INDEX[$all ]) = ($rate, $i) if $rate > 0 && (!defined $MAX_GAIN[$all ] ||  $MAX_GAIN[$all ] <  $rate);
            ($MAX_LOSS[$all ], $MAX_LOSS_INDEX[$all ]) = ($rate, $i) if $rate < 0 && (!defined $MAX_LOSS[$all ] || -$MAX_LOSS[$all ] < -$rate);
            if (defined $part) {
            ($MAX_GAIN[$part], $MAX_GAIN_INDEX[$part]) = ($rate, $i) if $rate > 0 && (!defined $MAX_GAIN[$part] ||  $MAX_GAIN[$part] <  $rate);
            ($MAX_LOSS[$part], $MAX_LOSS_INDEX[$part]) = ($rate, $i) if $rate < 0 && (!defined $MAX_LOSS[$part] || -$MAX_LOSS[$part] < -$rate);
            }
        }
    }
}
$lat_prec_len = max(length(lat_str($max_lat)), length(lat_str($min_lat)));
$lon_prec_len = max(length(lon_str($max_lon)), length(lon_str($min_lon)));

#$sec_diff = $SEC[$max_ele_index] - $SEC[$min_ele_index];
#$avg_gain = rate($max_ele - $min_ele, $sec_diff);


## optional elevation correction by geoid height

sub neg_geoid_height {    # potentially $updates $found_corr and $ele_corr
    my $lat = $_[0];
    my $lon = $_[1];
    return $ele_corr if !GEOID_ELE_CORRECTION;
    (my $fh, my $tmp_GeoidEval) = tempfile();
    system "wget --quiet -O $tmp_GeoidEval "
      . "http://geographiclib.sourceforge.net/cgi-bin/GeoidEval?input=$lat+$lon";
    open G, $tmp_GeoidEval;
    while (<G>) {
        if (m#EGM84</a>\s*=\s*<font.*?>\s*(-?[\.\d]+)\s*</font>#i) {
            $found_corr = 1;
            $ele_corr   = -$1;
        }
    }
    close G;
    if ($found_corr) {
        info_trkpt("   at    ", " geoid height is $ele_corr m");
    } else {
        warn_trkpt("at    ", " geoid height is assumed $ele_corr m");
    }
    return $ele_corr;
}

sub linear_ele_correction {
    return 0;                                   # linear correction not wanted
    my $sec  = $_[0];
    my $sec1 = 1296543617;                      #start time
    my $sec2 = 1296569335;                      #end   time
    return 0 unless ($sec1 <= $sec && $sec <= $sec2);   # linear correction not in scope
    my $ele1 = 4720 - 4677;                     #actual and wanted start value
    my $ele2 = 1925 - 1635;                     #actual and wanted end   value
    return
      int(($sec - $sec1) / ($sec2 - $sec1) * ($ele2 - $ele1) + $ele1);
}

sub correct_ele {    # may update $ele_corr; uses $ele_corr
    my $j = $_[0];    # index of waypoint if >= 0
    my $i = $_[1];    # otherwise, index of trackpoint or < 0 for none
    return "" if $j < 0 && $i < 0;
    my ($lat, $lon, $ele, $sec) =
      $j >= 0
      ? ($WLAT[$j], $WLON[$j], $WELE[$j], $WSEC[$j])
      : ( $LAT[$i],  $LON[$i],  $ELE[$i],  $SEC[$i]);
    return "" if $ele eq "";
    $ele_corr = neg_geoid_height($lat, $lon) if ($j >= 0 || $i == 0 || defined $SEC[$i - 1]) ;
    # do expensive operation only at specific points or beginning of track segment

    $ele += $ele_corr + linear_ele_correction($sec) if $ele_corr && $ele ne "" && defined $sec;
    return $ele;
}


## prepare output header

$HEAD =~ s|(<gpx)([ >])|$1 version="1.1"$2|     unless $HEAD =~ m|<gpx.*? version\s*=.*?>|s;
$HEAD =~ s|(<gpx)([ >])|$1 creator="$TOOL_ID"$2| unless $HEAD =~ m|<gpx.*? creator\s*=.*?>|s;
# $HEAD =~ s|(<gpx[ >])|$1xmlns:x="http://www.garmin.com/xmlschemas/TrackPointExtension/v2" |; # would not fit for our simple speed extension, and if so, should not be duplicated
#$speed_extension = '<xsd:element name="speed" type="xsd:decimal" minOccurs="0"><xsd:annotation><xsd:documentation>The current speed relative to the previous point, in meters per second</xsd:documentation></xsd:annotation></xsd:element>';
#$HEAD =~ s|(( )*</metadata>)|$2$2<extensions>$speed_extension</extensions>\n$1|s if $speed_extension ne ""; # add declaration for speed extension

$HEAD =~ s|(<gpx.*?>)(\s*)|$1$2<metadata></metadata>$2|s unless $HEAD =~ m|<gpx.*?>\s*<metadata>.*?</metadata>|s;
if ($HEAD =~ m|(\r?\n?[ \t]*)</metadata>|s) { # match multiple lines with 's' option
    my $indent = $1;

    my $bounds = '<bounds'
      .  ' minlat="' . lat_str($min_lat)
      . '" minlon="' . lon_str($min_lon)
      . '" maxlat="' . lat_str($max_lat)
      . '" maxlon="' . lon_str($max_lon) . '"/>';
    $HEAD =~ s|\r?\n?[ \t]*<bounds .*?/>||sg;                # remove any pre-existing bounds entry
    abort("FATAL: cannot add <bounds> to header")
        unless $HEAD =~ s|(\r?\n?[ \t]*<extensions>)|$indent$bounds$1|s
        ||     $HEAD =~ s|(\r?\n?[ \t]*</metadata>)|$indent$bounds$1|s;

    if ($min_tim ne "") {
        $min_tim = round_tim($min_tim);
        $HEAD =~ s|\r?\n?[ \t]*<time>.*?</time>||sg;   # remove any pre-existing time entry
        abort("FATAL: cannot add <time> to header")
            unless $HEAD =~ s|(\r?\n?[ \t]*<keywords>)|$indent<time>$min_tim</time>$1|s
            ||     $HEAD =~ s|(\r?\n?[ \t]*<bounds[ >])|$indent<time>$min_tim</time>$1|s;
    }
} else {
    abort("FATAL: cannot find </metadata> in header");
}
$HEAD =~ s/(\r?\n)*[ \t]*(<trk>)/$1$2/sg; # remove empty lines (after metadata) and indentation before <trk>
$HEAD =~ s/ *$//;

# statistics must be generated before interpolating, which may shift indexes

my $stat_points = "";
add_stat_point(0, "start");

sub wpt {
    my $j = $_[0]; # index of waypoint
    my ($ele, $tim) = (correct_ele($j, -1), $WTIM[$j]);
    return '<wpt lat="' . lat_str($WLAT[$j]) . '" ' . 'lon="' . lon_str($WLON[$j]) . '">'
        .($ele eq "" ? "     " .(" " x $ele_prec_len) ."      "  : "<ele>" .ele_string($ele_prec_len, $ele) . "</ele>")
        .($tim eq "" ? "      "."                    "."       " : "<time>".round_tim($tim)                 ."</time>")
      . $WTXT[$j] . "</wpt>\n";
}

sub point {
    my ($i, $text) = @_;
    my $ele      = correct_ele(-1, $i);
    my $ele_val  = $ele     eq "" ? "NONE".(" " x max(0, $ele_prec_len - length("NONE"))) : ele_string($ele_prec_len, $ele);
    my $time_val = $TIM[$i] eq "" ? "NONE".(" " x max(0,      $tim_len - length("NONE"))) : round_tim($TIM[$i]);
    return "At lat,lon,ele = " . lat_string($LAT[$i]) . "," . lon_string($LON[$i]).",$ele_val time = $time_val: $text\n";
}

sub add_stat_point { # generate trackpoint-related statistics output and waypoint with same data
    my ($i, $txt, $extra) = @_; # $i is index of trackpoint containing the location and time
    return unless defined $i;

    $stat_points .= point($i, $txt);

    # adapt text to be used as name in statistics wpt
    $txt .= $extra if defined $extra;
    $txt =~ s/\n/; /g;
    $txt =~ s/; $//;
    $txt =~ s/\s+/ /g;
    $txt = "<name>[$txt]</name>" if $txt ne "";

    # insert wpt in existing array, avoiding duplicates,
    # in ascending time order, where missing time is considered infinit,
    # assuming that the array is already ordered
    my $sec_or_inf = $SEC[$i] // $MAX_UNDEF_TIME;

    my  ($lat    , $lon    , $ele    , $tim    , $sec    ) =
        ($LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i]);
    my $j = 0;
    while ($j <= $#WSEC && ($WSEC[$j] // $MAX_UNDEF_TIME) < $sec_or_inf) {
        $j++
    }
    while ($j <= $#WSEC && ($WSEC[$j] // $MAX_UNDEF_TIME) == $sec_or_inf) {
        return if # do not add duplicates
            $WLAT[$j] eq $lat && $WLON[$j] eq $lon && $WELE[$j] eq $ele &&
            $WTIM[$j] eq $tim && $WTXT[$j] eq $txt;
        $j++
    }
    splice @WLAT, $j, 0, $lat;
    splice @WLON, $j, 0, $lon;
    splice @WELE, $j, 0, $ele;
    splice @WTIM, $j, 0, $tim;
    splice @WSEC, $j, 0, $sec;
    splice @WTXT, $j, 0, $txt;
    splice @WSTR, $j, 0, undef;
}

# add overall statistics and for parts

my $part_last = $part_end // $part // $all;
for (my $i = $all; $i <= $part_last; $i++) {
    my $Part = $i == $all ? "" : ($segs ? "segment" : "day")." ".(' ' x (length($part_last) - length($i))).($i + $part_offset)." ";
    my $Min_ele      = defined $MIN_ELE_INDEX[$i] ? sprintf ELE_PRECISION, correct_ele(-1, $MIN_ELE_INDEX[$i]) : "";
    my $Max_ele      = defined $MAX_ELE_INDEX[$i] ? sprintf ELE_PRECISION, correct_ele(-1, $MAX_ELE_INDEX[$i]) : "";
    my $Max_spd      = defined $MAX_SPD_INDEX [$i] ? " ".spd_full($SPD[$MAX_SPD_INDEX [$i]]) : "";
    my $Max_gain_spd = defined $MAX_GAIN_INDEX[$i] ?     spd_str ($SPD[$MAX_GAIN_INDEX[$i]]) : "";
    my $Max_loss_spd = defined $MAX_LOSS_INDEX[$i] ?     spd_str ($SPD[$MAX_LOSS_INDEX[$i]]) : "";
    while (substr($Max_gain_spd, 0, 1) eq " " &&
           substr($Max_loss_spd, 0, 1) eq " ")
    {
        $Max_gain_spd = substr($Max_gain_spd, 1);
        $Max_loss_spd = substr($Max_loss_spd, 1);
    }

    my $Max_gain = sprintf RAT_PRECISION, $MAX_GAIN[$i] // 0;
    my $Max_loss = sprintf RAT_PRECISION, $MAX_LOSS[$i] // 0;
    $Max_loss =~ s/\+0/-0/;

    #my $Avg_gain=sprintf RAT_PRECISION, $avg_gain;
    sub sum_avg_rate {
        my ($sum, $time, $miss) = @_;
        my $avg_rate = rate($sum, $time);
        my $Avg_rate = $avg_rate ne "" ? " = ".(sprintf RAT_PRECISION, $avg_rate)." m/h"
            . ($miss ? " with ".points($miss)." not having time information" : "")
            : "unknown due to missing time";
        return (sprintf DIF_PRECISION, $sum // 0)." m; avg rate $Avg_rate";
    }
    my $text__ascent = sum_avg_rate($SUM__ASCENT[$i], $TIME__ASCENT[$i], $MISSING__ASCENT_TIME[$i]);
    my $text_descent = sum_avg_rate($SUM_DESCENT[$i], $TIME_DESCENT[$i], $MISSING_DESCENT_TIME[$i]);
    $text_descent =~ s/\+0/-0/g;

    my $max_spd_text  = $Part."max speed        = $Max_spd km/h";    # may use "" if not defined
    my $min_ele_text  = $Part."min altitude     = $Min_ele m";       # may use "" if not defined
    my $max_ele_text  = $Part."max altitude     = $Max_ele m";       # may use "" if not defined
    my $ascent_text   = $Part."total  ascent    = $text__ascent";
    my $descent_text  = $Part."total descent    = $text_descent";
    my $max_gain_text = $Part."max  ascent rate = $Max_gain m/h at $Max_gain_spd km/h"; # relevant only if defined $MAX_GAIN_INDEX[$i]
    my $max_loss_text = $Part."max descent rate = $Max_loss m/h at $Max_loss_spd km/h"; # relevant only if defined $MAX_LOSS_INDEX[$i]
    my $part_end_text = $Part."end";
    $part_end_text .= "; length = ".dis_string($SUM_DIS[$i]) if defined $SUM_DIS[$i];
    $part_end_text .= "; duration = ".timediff_string($DURATION[$i]) if $DURATION[$i];
    add_stat_point($MAX_SPD_INDEX  [$i], $max_spd_text );
    add_stat_point($MIN_ELE_INDEX  [$i], $min_ele_text );
    add_stat_point($MAX_ELE_INDEX  [$i], $max_ele_text );
    add_stat_point($LAST_GAIN_INDEX[$i], $ascent_text  );
    add_stat_point($LAST_LOSS_INDEX[$i], $descent_text );
    add_stat_point($MAX_GAIN_INDEX [$i], $max_gain_text);
    add_stat_point($MAX_LOSS_INDEX [$i], $max_loss_text);
    add_stat_point($PART_END_INDEX [$i], $part_end_text."\n") unless $i == $all;
}
#average ".($avg_gain >= 0 ?  "ascent rate between lowest and highest"
#	                  : "descent rate between highest and lowest")." point = $Avg_gain m/h

# add statistics for phases

sub order_postfix {
    my $i = $_[0];
    my $d = $i % 10;
    return 11 <= $i && $i <= 13 ? "th" :
        $d == 1 ? "st" :
        $d == 2 ? "nd" :
        $d == 3 ? "rd" :
        "th";
}
sub phase_text {
    my $i = $_[0] + 1;
    my $d = $i % 10;
    return (" " x max(0, length($#PHASE_END_INDEX + 1) - length($i)))
        .$i.order_postfix($i)." ";
}

for (my $i = 0; $i <= $#PHASE_END_INDEX; $i++) {
    my $type = $PHASE_DIFF[$i] >= 0 ? "ascent " : "descent";
    my $Len = phase_text($i) . "$type   = " . (sprintf DIF_PRECISION, $PHASE_DIFF[$i]) . "  m;   "
      . "distance   =".($PHASE_DIST[$i] / 1000 >= 10 ? "" : " ").dis_string($PHASE_DIST[$i]);
    my $duration = $PHASE_DURATION[$i];
    $Len .= "; duration = " . timediff_string($duration) if $duration;
    my $max_spd_idx = $PHASE_MAX_SPD_INDEX[$i];
    my $Spd = phase_text($i)
        . "max speed =  ".spd_full($SPD[$max_spd_idx])." km/h; "
        . "avg speed  = ".spd_full($PHASE_SPD[    $i])." km/h"
        if defined $max_spd_idx;
    my $max_rate_idx = $PHASE_MAX_RATE_INDEX[$i];
    my $Rate = phase_text($i)
        . "max rate  =" . (sprintf RAT_PRECISION2, $RAT[$max_rate_idx]) . "  m/h; "
        . "avg rate   =" . (sprintf RAT_PRECISION, $PHASE_RATE[$i]    ) . "  m/h"
        if defined $max_rate_idx;
    add_stat_point($PHASE_END_INDEX     [$i], $Len );
    add_stat_point($PHASE_MAX_SPD_INDEX [$i], $Spd ) if defined $max_spd_idx;
    add_stat_point($PHASE_MAX_RATE_INDEX[$i], $Rate) if defined $max_rate_idx;
}

my $end_text = "";
if (defined $SUM_DIS[$all]) {
    $end_text .= "total track length   = ".dis_string($SUM_DIS[$all])."\n";
    $end_text .= "total track duration = ".timediff_string(diff_defined($max_sec, $min_sec) // 0)."\n";
}
if ($sum_timediff_mov) {
    $end_text .= "total moving time    = ".timediff_string($sum_timediff_mov).", with speed being at least ${\MIN_SPEED_MOVING} km/h\n";
    $end_text .= "average moving speed = ".(sprintf AVG_PRECISION, MPS2KMPH * $sum_dis_mov / $sum_timediff_mov)." km/h\n";
}
if ($weight) {
    $end_text .= "total biking energy  = ".(sprintf "%.0f", $sum_energy / 1000)." kJ";
    $end_text .= ", leaving out ".points($num_energy_missing)." where time or altitude information is missing" if $num_energy_missing;
    $end_text .= "\n";
}
add_stat_point($#TIM, "end", "; $end_text");


## fill long time gaps as far as needed for exiftool etc. by inserting intermediate points with linear interpolation of data

# must not be called in between computing and using max/min etc. index values as these may get invalidated by inserting points
sub insert_points_in_gap {
    my ($num_inserted_trkpts, $num_duplicated_trkpts) = (0, 0);
    for (my $i = 1; $i <= $#TIM; $i++) {
        ($lat    , $lon    , $ele    , $tim    ) =
        ($LAT[$i], $LON[$i], $ELE[$i], $TIM[$i]); # needed also for print_trkpt
        my ($sec    , $dis    ) =
           ($SEC[$i], $DIS[$i]);
        my $diff_time = diff_defined($sec, $SEC[$i - 1]) // 0;
        my $dis_text = dis_str(DIS_PRECISION2, $dis);
        ## debug_log "at ".point_str($i).", considering gap of $diff_time seconds and $dis_text";
        if ($diff_time > INSERTION_MAX_GAP) {
            # note that this is done only between adjacent track points that both have time information
            my $lin_spd = $dis / $diff_time;
            my $gap_text = "  long time gap = ".timediff_str("%2d", $diff_time)." over a distance of $dis_text";
            if (MPS2KMPH * $lin_spd > $INSERTION_MAX_SPEED) {
                warn_trkpt("before", "$gap_text; not inserting points because linear speed would be ".spd_str($lin_spd)." km/h, higher than $INSERTION_MAX_SPEED");
                next;
            }
            # insert equidistant points with interpolated data, plus
            # in case of new segment: an extra trkpt that equals the end of the previous segment and one that equals the start of the next segment
            my $n_spans  = int($diff_time / INSERTION_MAX_GAP) + ($diff_time % INSERTION_MAX_GAP == 0 ? 0 : 1);
            my $seg = INSERT_SEGMENT ? $SEG[$i] : 0; # if gap was at segment start, optionally have segment starts just before and after inserted points
            my $start = $seg ? 0 : 1;
            my $n_end = $n_spans - ($seg ? 0 : 1);

            my $p = $i - 1;
            my $flags_before = $FLG[$p];
            my $flags_after  = $FLG[$i];
            my ($lat_curr, $lon_curr, $ele_curr, $sec_curr) = ($LAT[$p], $LON[$p], $ELE[$p], $SEC[$p]);
            my $dis_delta  = $dis / $n_spans;
            my $lat_delta = ($lat - $lat_curr) / $n_spans;
            my $lon_delta = ($lon - $lon_curr) / $n_spans;
            my $sec_delta = $diff_time / $n_spans; # 0 < $sec_delta <= INSERTION_MAX_GAP
            my $ele_delta = diff_nonempty($ele, $ele_curr);
            $ele_delta /= $n_spans if defined $ele_delta;
            warn_trkpt("before", "$gap_text; inserting ".points($n_spans - 1)." after each ".(sprintf SEC_PRECISION, $sec_delta)." seconds");

            # point $i will become the point past the insertion (possibly with duplication before and after segment)
            # need to move info about previous ignored points from point past the insertion to first new point
            my $ign = $IGN[$i];
            # for the point that will be the one past the insertion:
            $IGN[$i] = 0;
            $DIS[$i] = $seg ? 0 : $dis_delta; # recalculate distance
            # ascent/decent rate as well as speed stays the same, due to linear interpolation

            for (my $n = 0; $n <= $n_end; $n++) {
                if ($n >= $start) {
                    my $flags;
                    if ($n == 0) {
                        # place a new segment start, with contents to be duplicated from previous point (at segment end just before)
                        $flags = $flags_before | DUPLICATED_POINT;
                        $num_duplicated_trkpts++;
                    } elsif ($n == $n_spans) {
                        $flags = $flags_after | DUPLICATED_POINT;
                        # place a new segment end, with contents duplicated from next point at segment start just after insertion
                        $num_duplicated_trkpts++;
                    } else {
                        $flags = INSERTED_POINT;
                        $num_inserted_trkpts++;
                    }
                    splice @IGN, $i, 0, $n == $start ? $ign : 0;
                    splice @SEG, $i, 0, $n == 0;
                    splice @FLG, $i, 0, $flags;
                    splice @LAT, $i, 0, $lat_curr;
                    splice @LON, $i, 0, $lon_curr;
                    splice @ELE, $i, 0, $ele_curr;
                    splice @TIM, $i, 0, epoch_to_str($sec_curr);
                    splice @SEC, $i, 0, $sec_curr;
                    splice @DIS, $i, 0, $n == 0 ? 0 : $dis_delta;
                    splice @RAT, $i, 0, "";
                    splice @SPD, $i, 0, "";
                    splice @CMT, $i, 0, "";
                    splice @SRC, $i, 0, "";
                    splice @FIX, $i, 0, "";
                    splice @EXT, $i, 0, "";
                    $i++;
                }
                $lat_curr += $lat_delta;
                $lon_curr += $lon_delta;
                $ele_curr += $ele_delta if defined $ele_delta;
                $sec_curr += $sec_delta;
            }
        }
    }
    return ($num_inserted_trkpts, $num_duplicated_trkpts);
}
my ($num_inserted_trkpts, $num_duplicated_trkpts) = $insert_points ? insert_points_in_gap() : (0, 0);


### generate final output

my $final_text = $end_text;
$final_text .= "average deviation between recorded and computed speed (for points at most ".MAX_TIMEDIFF_RECORDED_SPEED." seconds apart) = ".
    int(0.5 + 100 * $sum_speed_deviation / ($sum_speed / 2))." %\n" if $sum_speed;
$final_text .= plural($num_pruned_wpts,         "waypoint")    . " pruned\n" if $num_pruned_wpts;
$final_text .= plural($num_auto_wpts, "automatic waypoint")." pruned\n" if $num_auto_wpts;
$final_text .= plural($num_ignored_hdrs,      "GPX header")." ignored (apart from any included waypoints)\n" if $num_ignored_hdrs;
$final_text .= plural($num_pruned_cmts,              "cmt")." pruned\n" if $num_pruned_cmts;
$final_text .= plural($num_pruned_descs,     "description")." pruned\n" if $num_pruned_descs;
$final_text .= plural($num_pruned_links,            "link")." pruned\n" if $num_pruned_links;
$final_text .= plural($num_pruned_exts,        "extension")." pruned\n" if $num_pruned_exts;
$final_text .= points($num_ignored_before)." with time before ".epoch_to_str($begin_sec)." filtered out\n" if defined $begin_sec;
$final_text .= points($num_ignored_after )." with time after  ".epoch_to_str($end_sec  )." filtered out\n" if defined $end_sec;
$final_text .= points($num_elem_above    )." with $max_elem above $max_elem_limit"      ." filtered out\n" if $max_elem;
$final_text .= points($num_elem_below    )." with $min_elem below $min_elem_limit"      ." filtered out\n" if $min_elem;
$final_text .= points($num_removals_ele  )." ignored due to altitude less than "            .MIN_PLAUSIBLE_ELE                                      ." m\n" if $num_removals_ele;
$final_text .= points($num_removals_dir  )." ignored due to direction change out of range -".MAX_PLAUSIBLE_ANGLE_DIFF."°..+".MAX_PLAUSIBLE_ANGLE_DIFF."°\n" if $num_removals_dir;
$final_text .= points($num_removals_spd  )." ignored due to speed out of range 0..$MAX_PLAUSIBLE_SPEED km/h\n"    if $num_removals_spd;
$final_text .= points($num_removals_acc  )." ignored due to acceleration more than $MAX_PLAUSIBLE_ACCEL m/s/s\n"  if $num_removals_acc;
$final_text .= points($num_removals_dec  )." ignored due to deceleration more than $MAX_PLAUSIBLE_DECEL m/s/s\n"  if $num_removals_dec;
$final_text .= points($num_removals_gain )." ignored due to ascent rate more than $MAX_PLAUSIBLE_ELE_GAIN m/s\n"  if $num_removals_gain;
$final_text .= points($num_removals_loss )." ignored due to descent rate more than $MAX_PLAUSIBLE_ELE_LOSS m/s\n" if $num_removals_loss;
$final_text .= points($num_removals_diff )." ignored due to time difference less than $MIN_TIMEDIFF sec\n"        if $num_removals_diff;
$final_text .= plural($num_ext_below, "extension element")." with name '$min_ext' and value below $min_ext_limit pruned\n" if $min_ext;
$final_text .= plural($num_ext_above, "extension element")." with name '$max_ext' and value above $max_ext_limit pruned\n" if $max_ext;
$final_text .= ($smoothing ? points($num_smoothened)." being at most ${ \SMOOTHING_MAX_GAP } seconds apart smoothened\n" : "");
$final_text .= points($num_inserted_trkpts)." inserted ".(INSERT_SEGMENT ? "and ".points($num_duplicated_trkpts)." duplicated " : "").
    "due to time gaps > ".INSERTION_MAX_GAP." seconds\n" if $insert_points;
$final_text .= "elevation ". (!GEOID_ELE_CORRECTION ? "not corrected" :
                               "corrected by " . ($found_corr ? "last retrieved" : "assumed") . " geoid height = $ele_corr m") . "\n";

my $num_sanitized = $num_removals_ele + $num_removals_dir + $num_removals_spd + $num_removals_acc
    + $num_removals_dec + $num_removals_gain + $num_removals_loss + $num_removals_diff;
my $sanitized_text = $num_sanitized ? plural($num_sanitized, "sanitized trackpoint")." nor " : "";
my $stats = "GPXConv statistics (not including $sanitized_text"."periods between segments)\n"
  . $stat_points
  .($phases && $PHASES_REPORT_THRESHOLD > ELE_THRESHOLD ?
    "$ascent__phases_suppressed ascent phases and $descent_phases_suppressed descent phases " .
    "not reported because they are below the threshold of +/-$PHASES_REPORT_THRESHOLD m\n" : "")
    .$final_text.
"GPXConv statistics end";

print_line(""); # empty line
info($stats);

my $all_wpts = "";
for (my $j = 0; $j <= $#WTIM; $j++) {
    $all_wpts .= wpt($j);
}
$HEAD =~ s/(<trk>)/$all_wpts$1/s;    # prepend collected and computed waypoints to track

abort("FATAL: end of track header not found") unless $HEAD =~ m/<trk>(.*?)<trkseg>/s;
# add preliminarily empty comment in track; # if not already existing:
abort("FATAL: end of track header not found") unless $1 =~ m/<cmt>/ || $HEAD =~ s|(<trk>(\s*<name>.*?</name>)?)|$1\n<cmt></cmt>|s;
$HEAD =~ s/(<trk>.*?<cmt>)/$1\n$stats\n/s; # prepend stats to track comment


### write final output

print $out $HEAD;                     # includes <gpx> <trk> <trkseg>
for (my $i = 0; $i <= $#TIM ;$i++) {
    ($tim, $spd) = ($TIM[$i], $SPD[$i]);
    print $out '<trkpt lat="' . lat_str($LAT[$i]) . '" lon="' . lon_str($LON[$i]) . '">';
    print $out "<ele>" . ele_string($ele_prec_len, correct_ele(-1, $i)) . "</ele>" if $ELE[$i] ne "";
    print $out "<time>".round_tim($tim)."</time>" if $tim;

    my $cmt = $CMT[$i];
    if (!DISABLE_TRKPT_CMT && $IGN[$i]) {
        my $old_count = ($cmt =~ s#(\d+) previous points? ignored(; )?##s ? $1 : 0); # remove and previous instance of our comment
        my $ign_str = plural(($ARGV =~ m/^(test.*?\.out)\d$/ ? 0 : $old_count) + $IGN[$i], "previous point")." ignored";
        $cmt = $cmt eq "" ? $ign_str : "$ign_str; $cmt";
    }
    print $out "<cmt>$cmt</cmt>" if $cmt ne "";

    if (!DISABLE_TRKPT_SRC) {
        my $src = $SRC[$i];
        my $gap = $FLG[$i] & INSERTED_POINT ? "bridging time gap: inserted point"
            : $FLG[$i] & DUPLICATED_POINT ? "bridging time gap: duplicated point "
            . ($i > 0 && $FLG[$i - 1] & INSERTED_POINT ? "after" : "before") : "";
        # cannot place info on interpolation etc. in <trkseg> element because it cannot hold a comment
        sub append_unless_present { return $_[0] =~ m/$_[1]/ ? "" : ($_[0] eq "" ? "" : "; ") . $_[1]; }
        $src .= append_unless_present($src, $gap) if $gap ne "";
        $src .= append_unless_present($src, "interpolated altitude") if $FLG[$i] & INTERPOLATED_ELE;
        $src .= append_unless_present($src, "interpolated time"    ) if $FLG[$i] & INTERPOLATED_TIM;
        $src .= append_unless_present($src, "substituted altitude" ) if $FLG[$i] & SUBSTITUTED_ELE;
        $src .= append_unless_present($src, "substituted time"     ) if $FLG[$i] & SUBSTITUTED_TIM;
        $src .= append_unless_present($src, "computed speed"       ) if $FLG[$i] & COMPUTED_SPEED && INCLUDE_SPEED;
        print $out "<src>$src</src>" if $src;
    }
    if (!DISABLE_TRKPT_FIX) {
        my $fix = $FIX[$i];
        $fix = "none" if $FLG[$i] & (INSERTED_POINT | DUPLICATED_POINT);
        # TODO check; was before: $fix = $flags == 0 ? "" : ($FLG[$i] & (INSERTED_POINT | INTERPOLATED_TIM | SUBSTITUTED_TIM) == 0 ? "2d" : "none");
        print $out "<fix>$fix</fix>" if $fix;
    }

    my $exts = $EXT[$i];
    $exts =~ s#<gpxtpx:TrackPointExtension>\s*<gpxtpx:speed>.*?</gpxtpx:speed>\s*</gpxtpx:TrackPointExtension>##sg if PRUNE_RECORDED_SPEED;
    if (INCLUDE_SPEED && $spd ne "") { # may be recorded or computed, depending on $FLG[$i] & COMPUTED_SPEED
        my $spdstr = "<speed>".spd_string($spd)."</speed>";
        if ($exts eq "") {
            $exts = "<extensions>$spdstr</extensions>";
        } else {
            $exts =~ s#(</extensions>)#$spdstr$1#s # add new speed extension at the end of existing extensions
                unless $exts =~ s#<speed>.*?</speed>#$spdstr#sg; # substitute previous speed extension at same place
        }
    }
    print $out $exts unless $exts eq "" || $exts =~ m#<extensions>\s*</extensions>#;

    print $out "</trkpt>\n";
    print $out "</trkseg>\n<trkseg>\n" if $SEG[$i + 1] && $i < $#TIM;
}
print $out "</trkseg>\n</trk>\n</gpx>\n";

close $out;   # does not hurt in case STDOUT
exit 0;
