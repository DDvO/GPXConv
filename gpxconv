#!/usr/bin/perl

################################################################################
# GPX converter: post-process routes and tracks typically produced by GPS loggers.
#
# Reads from file(s) given as argument (or STDIN) and writes to STDOUT or a file.
# Can append segments from multiple tracks and files (sequential composition), using the metadata of the first track.
# Can complete gaps in input file(s) by merging data from an alternative GPX file (parallel composition).
# Concatenates all given tracks (or routes) preserving segments, collecting waypoints.
# The metadata (header) of the first input track is used for the output track.
# Reports missing data and by default sanitizes points containing implausible data.
# Optionally filters out points before or after given time limits.
# Optionally filters out points with an element value below or above given limits.
# Optionally prunes comments, extensions, or elements with value below or above given limits.
# Optionally fills in altitude and time data by interpolation within segments.
# Optionally interpolates points in long gaps (by default, > 3600 seconds).
# Optionally corrects elevation and smoothens tracks.
# (Orthometric height = GPS ellipsoidal height - geoid height,
#  see http://www.unavco.org/edu_outreach/tutorial/geoidcorr.html)
# Produces statistics, optionally including ascent/descent rates of climbing phases.
# Optionally produces additional statistics on a per-segment or per-day basis.
# Optionally calculates approx. total energy spent by biking along the resulting track.
# Prints information (if enabled), any warnings (if enabled), and errors to STDERR.
#
my $usage =
"Usage:  gpxconv <option(s) and infile(s)> [> <outfile>]

Command-line options:
  -swim, -walk, -cycle, -drive, -fly - type of recorded activity, default: drive
  -no_sanitize                 - do not sanitize trackpoints with implausible data
  -smooth                      - smoothen tracks
  -phases                      - analyze ascent/descent phases
  -segs <n>                    - produce additional statistics per segment, start with n
  -days <n>                    - produce additional statistics per day, counted from n
  -merge <file>                - complete gaps in infile(s) by data from given GPX file
  -weight <value>              - calculate biking energy for given weight in kg
  -begin <time>                - ignore points before given time
  -end <time>                  - ignore points after given time
  -max <name> <limit>          - ignore points with element value above limit
  -min <name> <limit>          - ignore points with element value below limit
  -max_ext <name> <limit>      - prune extension elements with value above limit
  -min_ext <name> <limit>      - prune extension elements with value below limit
  -prune_wpts                  - remove waypoints
  -prune_cmts                  - remove comments
  -prune_exts                  - remove extensions
  -nw                          - do not print warnings
  -ni                          - do not print information
  -o <outfile>                 - output the resulting track to <outfile>
Other options can be set by changing values of the configuration variables.

(c) 2012-2023 David von Oheimb - License: MIT - Version 2.7.1";
################################################################################

use strict;
use warnings;
# use feature 'signatures'; # https://perldoc.perl.org/perlsub#Signatures

### configuration variables

my $activity = "-drive"; # default

# basic output control
use constant PRUNE_WPTS           => 0; # by default do not ignore waypoints
use constant PRUNE_AUTOMATIC_WPTS => 1; # ignore waypoints containing <name><!\[CDATA\[\d*\]\]></name>
use constant PRUNE_CMTS           => 0; # by default do not remove comments
use constant PRUNE_DESCS          => 0; # do not remove descriptions
use constant PRUNE_LINKS          => 0; # do not remove links
use constant PRUNE_EXTENSIONS     => 0; # by default do not remove extensions
use constant INCLUDE_COMP_SPEED   => 1; # include speed extensions with computed speed
use constant DISABLE_TRKPT_CMT    => 0; # do not add 'cmt' entries to trackpoints, e.g., comments on ignored points
use constant DISABLE_TRKPT_SRC    => 0; # do not add 'src' entries to trackpoints, e.g., on time gaps and interpolated data
use constant DISABLE_TRKPT_FIX    => 0; # do not add 'fix' entries to trackpoints, e.g., on points added by interpolation

# control filling in missing altitude and/or time
use constant CARRY_OVER_ELE    => 1; # copy altitude from last available value or begin of following segment
use constant CARRY_OVER_TIME   => 1; # copy time from end of previous segment or begin of following segment
use constant FILL_MISSING_ELE  => 1; # interpolate missing altitude
use constant FILL_MISSING_TIME => 1; # interpolate missing time

# control use of recorded vs. computed speed
use constant MAX_TIMEDIFF_RECORDED_SPEED => 2; # maximum number of seconds for which recorded speed is used

# analysis control
use constant MIN_SPEED_MOVING =>  1; # threshold for detecting movement (in km/h)
use constant MIN_SPEED_MOVING =>  1; # threshold for detecting movement (in km/h)
use constant ANALYZE_PHASES   =>  0; # by default do not analyze ascent/descent phases
use constant ELE_THRESHOLD    => 25; # threshold for detecting/accepting ascent or descent (in m);
                                     # should be larger than short-term altitude measurement error
my $PHASES_REPORT_THRESHOLD = ELE_THRESHOLD; # default

# smoothing control
use constant MERGE_FILL_GAP    => 60; # minimum gap duration in seconds to be filled by merging
use constant ENABLE_SMOOTHING  =>  0; # by default disable smoothing
use constant SMOOTHING_MAX_GAP => 60; # maximum number of seconds between trackpoint to be smoothened and its neighbors

# control interpolation of points over long (time) gaps
use constant INTERPOLATE_POINTS    =>    1; # enable inserting interpolated points in long time gaps
use constant INTERPOLATION_MAX_GAP => 3600; # in seconds between neighboring trackpoints before
                                            # interpolation should be used (3600 for both exiftool and TrailGuru)

# warning output control
use constant PRINT_WARNINGS      =>    1; # whether printing warnings is enabled by default
use constant PRINT_INFO          =>    1; # whether printing information is enabled by default
use constant WARNING_TPT_DIST    => 2000; # threshold for trackpoint distance warning (in meters)
use constant WARNING_WPT_DIST    =>  100; # threshold for waypoint distance warning (in meters)
use constant MAX_SPEED_DEVIATION =>    2; # threshold for speed measuring deviation warning (in km/h)
# using absolute value for MAX_SPEED_DEVIATION because we compute speed from absolute values (coordinates and time)

# sanitization control
use constant   SANITIZE_TRKPTS   =>    1; # whether trackpoint sanitization is enabled by default
my $sanitize = SANITIZE_TRKPTS;
my $MIN_TIMEDIFF          ; # in seconds
my $MAX_PLAUSIBLE_SPEED   ; # maximal speed in km/h
my $MAX_PLAUSIBLE_ACCEL   ; # maximal acceleration m/s/s
my $MAX_PLAUSIBLE_DECEL   ; # maximal deceleration m/s/s
my $MAX_PLAUSIBLE_ELE_GAIN; # maximal ascent rate in m/h
my $MAX_PLAUSIBLE_ELE_LOSS; # maximal descent rate in m/h
use constant MAX_PLAUSIBLE_ANGLE_DIFF =>  170; # maximal plausible turning angle above speed threshold
use constant MAX_PLAUSIBLE_ANGLE_SPD_THRESHOLD => 2; # speed threshold for maximal plausible turning angle: 7.2 km/h
use constant MIN_PLAUSIBLE_ELE        => -450; # minimal plausible altitude; actual elevation values on Earth may be as low as -450 m at Dead Sea

# time correction control
use constant TIME_CORRECTION => 0; # number of seconds to add to time stamps in trkpt and wpt

# elevation correction control
use constant GEOID_ELE_CORRECTION   => 0; # whether to correct elevation wrt. geoid height retrieved online
use constant DEFAULT_ELE_CORRECTION => 0; # 47; # if used should be -(average geoid height)

### other constants

use constant METERS_PER_DEGREE_LAT => 10000 * 1000 / 90; # on Earth, by definition
use constant LAT_PRECISION  =>   "%.5f"; #  latitude resolution = 0.00001° (<= 1.11 meters)
use constant LON_PRECISION  =>   "%.5f"; # longitude resolution = 0.00001° (<= 1.11 meters)
use constant ELE_PRECISION  =>  "%5.0f"; #  altitude resolution = 1 meters
use constant ELE_PRECISION0 =>   "%.0f";
use constant DIF_PRECISION  => "%+5.0f"; #  altitude difference          resolution = 1 meters
use constant RAT_PRECISION  => "%+5.0f"; #  altitude ascent/descent rate resolution = 1 meters
use constant RAT_PRECISION2 => "%+6.0f"; #  altitude ascent/descent rate resolution = 1 meters
use constant DIS_PRECISION  =>    ".2f"; #  distance resolution = 0.01 km
use constant SEC_PRECISION  =>   "%.0f"; #   seconds resolution = 1 second
use constant SPD_PRECISION  =>  "%4.0f"; #     speed resolution = 1 km/h
use constant AVG_PRECISION  =>   "%.1f"; # avg speed resolution = 0.1 km/h
use constant SPD_PRECISION0 =>   "%.0f";
use constant ACC_PRECISION  =>   "%.1f"; # acceleration resolution = 0.1 m/s/s

# trkpt flags
use constant DUPLICATED_POINT   => 1 << 0;
use constant INTERPOLATED_POINT => 1 << 1;
use constant INTERPOLATED_ELE   => 1 << 2;
use constant INTERPOLATED_TIM   => 1 << 3;
use constant SUBSTITUTED_ELE    => 1 << 4;
use constant SUBSTITUTED_TIM    => 1 << 5;
use constant COMPUTED_SPEED     => 1 << 6;

# global option variables

my $merge;
my $num_ignored_hdrs   = 0;
my $begin_sec          = 0;
my $num_ignored_before = 0;
my $end_sec            = 0;
my $num_ignored_after  = 0;
my $max_elem;
my $max_elem_limit;
my $num_elem_above  = 0;
my $min_elem;
my $min_elem_limit;
my $num_elem_below  = 0;
my $max_ext;
my $max_ext_limit;
my $num_ext_above  = 0;
my $min_ext;
my $min_ext_limit;
my $num_ext_below  = 0;
my $ele_corr         = DEFAULT_ELE_CORRECTION;
my $smoothing        = ENABLE_SMOOTHING;
my $phases           = ANALYZE_PHASES;
my $weight;
my $prune_wpts       = PRUNE_WPTS;
my $num_pruned_wpts  = 0;
my $num_auto_wpts    = 0;
my $prune_cmts       = PRUNE_CMTS;
my $num_pruned_cmts  = 0;
my $num_pruned_descs = 0;
my $num_pruned_links = 0;
my $prune_exts       = PRUNE_EXTENSIONS;
my $num_pruned_exts  = 0;
my $print_warnings   = PRINT_WARNINGS;
my $print_info       = PRINT_INFO;

# trackpoint data

my @IGN;
my @SEG;
my @FLG;
my @LAT;
my @LON;
my @ELE;
my @TIM;
my @SEC; # computed from @TIM, possibly adapted
my @DIS;
my @SPD; # as recorded or computed
my @CMT;
my @EXT;

# waypoint data

my @WLAT;
my @WLON;
my @WELE;
my @WTIM;
my @WSEC; # computed from @WTIM, possibly adapted
my @WTXT; # inner waypoint text after </time>
my @WSTR; # full original (but indented) waypoint text

# ascent/descent phase data

my @PHASE_DURATION;
my @PHASE_DIFF;
my @PHASE_DIST;
my @PHASE_SPD;
my @PHASE_RATE;
my @PHASE_MAXSPD_INDEX;
my @PHASE_MAXRATE_INDEX;
my @PHASE_END_INDEX;
my @DIST;
my @RATE;
my $ascent__phases_suppressed = 0;
my $descent_phases_suppressed = 0;

# global state variables

my $HEAD;
my $found_corr = 0;

my $lat, my $lon, my $ele, my $tim, my $sec, my $spd; # TODO make local
my $prev_lat, my $prev_lon, my $prev_ele, my $prev_tim, my $prev_sec, my $prev_spd, my $prev_rate, my $prev_acc; # TODO make local

my $min_lat, my $max_lat;
my $min_lon, my $max_lon;

my ($min_tim, $min_sec) = ("", 0);
my ($max_tim ,$max_sec) = ("", 0);

my ($days, $segs);
my $part;  # will be index, defined   if -days or -segs option is given
my $parts; # will be the argument of the -days or -segs option if given, else 1
# in the following arrays, index ($parts - 1) will be used for the overall values
my (@MAX_SPD      , @MIN_ELE      , @MAX_ELE      , @MAX_GAIN      , @MAX_LOSS      );
my (@MAX_SPD_INDEX, @MIN_ELE_INDEX, @MAX_ELE_INDEX, @MAX_GAIN_INDEX, @MAX_LOSS_INDEX);
my (@LAST_GAIN_INDEX, @LAST_LOSS_INDEX, @PART_END_INDEX);
my (@SUM__ASCENT, @TIME__ASCENT,
    @SUM_DESCENT, @TIME_DESCENT);

my $sum_dis         = 0;
my $avg_timediff;

 # for calculating relative deviation between recorded and computed speed
my $sum_speed = 0;
my $sum_speed_deviation = 0;

my $sum_timediff_mov = 0;
my $sum_energy = 0;

my $out = *STDOUT;  # https://stackoverflow.com/questions/10478884/are-there-rules-which-tell-me-what-form-of-stdout-stderr-sdtin-i-have-to-choose

### various subprocedures

#http://www.perlmonks.org/?node_id=406883
#sub max { return $_[0] > $_[1] ? $_[0] : $_[1]; }
use List::Util qw[min max];

# http://stackoverflow.com/questions/178539/how-do-you-round-a-floating-point-number-in-perl
use Math::Round qw( nearest );
use Math::Trig qw( deg2rad pi2 );   # use Math::Trig 'great_circle_distance';
use File::Temp qw/ tempfile /;

# use DateTime::Format::ISO8601;
use Time::ParseDate ();

# use Time::PrintDate;
use Time::gmtime qw( gmtime );

use Scalar::Util qw( looks_like_number );

# str_to_epoch("1970-01-01T00:00:00Z") = 0
sub str_to_epoch {
    my $s = $_[0];

# return DateTime::Format::ISO8601->parse_datetime($s)->epoch();
# # not used due to Perl library bug on Mac OS X: "dyld: lazy symbol binding failed: Symbol not found: _Perl_newSVpvn_flags"
# # http://www.en8848.com.cn/Reilly%20Books/perl3/cookbook/ch03_08.htm
# use Time::Local;
# $date is "1998-06-03" (YYYY-MM-DD form).
# ($yyyy, $mm, $dd) = ($date =~ /(\d+)-(\d+)-(\d+)/;
# # calculate epoch seconds at midnight on that day in this timezone
# $epoch_seconds = timegm(0, 0, 0, $dd, $mm, $yyyy);
    $s =~ s/-/\//g;
    $s =~ s/(T\d+)Z/$1:00Z/; # workaround for the case that only hour is given
    $s =~ s/T/ /;
    $s =~ s/Z/+0000/;
    my $sec = Time::ParseDate::parsedate($s);
    $sec += $1 if $s =~ m/:\d\d(\.\d+)/;    # fractional seconds
    return $sec;
}

sub epoch_to_str {

# use DateTime; # not used due to Perl library bug on Mac OS X:
                # "dyld: lazy symbol binding failed: Symbol not found: _Perl_newSVpvn_flags"
#  my $dt = DateTime->from_epoch( epoch => $_[0] );
#  return $dt->ymd."T".$dt->hms."Z";
#use Date::Manip qw(ParseDate UnixDate);
#$date = ParseDate("18 Jan 1973, 3:45:50");
#  return UnixDate($_[0], "%Y-%m-%dT%H:%M:%SZ");
    my $sec = shift;
    my $millisec = nearest(.001, $sec - int($sec)); # fractional seconds
    my $tm = gmtime($sec);
    return sprintf(
        "%04d-%02d-%02dT%02d:%02d:%02d%sZ",
        $tm->year + 1900,
        $tm->mon + 1,
        $tm->mday, $tm->hour, $tm->min, $tm->sec,
        $millisec == 0 ? "" : substr(substr($millisec, 1)."00", 0, 4)
    );
}

sub round_tim { # round to nearest second
    my $tim = shift;
    # $tim =~ s/(:\d\d)(\.\d+)/$1/;  # strip fractional seconds
    return $tim =~ m/\.(\d+)Z$/ && $1 != 0 ? epoch_to_str(nearest(1, str_to_epoch($tim))) : $tim;
}

sub timediff_string {
    my $t = $_[0] + 0.5; # for rounding to nearest second
    my $s = $t % 60;
    $t = ( $t - $s ) / 60;
    my $m = $t % 60;
    $t = ( $t - $m ) / 60;
    return sprintf( "%2d:%02d:%02d h", $t, $m, $s );
}

sub ele_string {
    my $len = $_[0];
    my $ele = $_[1];
    $ele = (sprintf ELE_PRECISION0, $ele) if $len >= 0;
    return ( " " x max( 0, abs($len) - length($ele) ) ) . $ele;
}

my $spd_prec_len = 1; # used only for spd_string
sub spd_full { return sprintf SPD_PRECISION, 3.6 * $_[0]; }
sub spd_str { return sprintf SPD_PRECISION0, 3.6 * $_[0]; }
sub spd_string {
    my $s = spd_str($_[0]);
    return " " x ($spd_prec_len - length($s)) . $s;
}

my $lat_prec_len = my $lat_full_len =
my $lon_prec_len = my $lon_full_len =
my $ele_prec_len = my $ele_full_len = my $tim_len = 1; # used only for formatting
sub lat_str { return sprintf LAT_PRECISION, $_[0]; }
sub lon_str { return sprintf LON_PRECISION, $_[0]; }
sub lat_string {
    my $s = lat_str($_[0]);
    return " " x max(0, $lat_prec_len - length($s)) . $s;
}
sub lon_string {
    my $s = lon_str($_[0]);
    return " " x max(0, $lon_prec_len - length($s)) . $s;
}


sub parse_point {
    my $str = $_[0];
    my $is_trkpt = $str =~ m/^<trkpt /;

    my $lat, my $lon;
    if ($str =~ s#lat=\s*"(-?[\.\d]+)"\s*lon=\s*"(-?[\.\d]+)"\s*>##s) {
        $lat     = $1;
        $lon     = $2;
    } elsif ($str =~ s#lon=\s*"(-?[\.\d]+)"\s*lat=\s*"(-?[\.\d]+)"\s*>##s) {
        $lat     = $2;
        $lon     = $1;
    } else {
        abort("FATAL: Cannot parse point: $str\n");
    }
    $lat_full_len = max($lat_full_len, length($lat));
    $lon_full_len = max($lon_full_len, length($lon));

    my $ele_str = my $ele = "";
    if ($str =~ s#[ \t]*(<ele>\s*(-?\d*(\.\d+)?)[\.\d]*\s*</ele>)\n?##s) {
        $ele_str = $1;
        $ele = $2; # may be empty or 0, ignores anything past any second decimal dot, e.g, takes ".12" on ".12.34" input
        $ele_prec_len = max($ele_prec_len, length((sprintf ELE_PRECISION0, $ele)));
        $ele_full_len = max($ele_full_len, length($ele));
        $ele = "" if !$ele_str && !$sec; # for routes generated, e.g., using Google My Maps
    }

    my $tim = "", my $sec = 0;
    if ($str =~ s#[ \t]*(<time>\s*([-:.T\dZ]+)\s*</time>)\n?##s) {
        $tim = $2;
        $tim =~ s/\.0+Z/Z/;
        $tim_len = max( $tim_len, length($tim) );
        $sec = str_to_epoch($tim);    # or within a day: $7+60*($6+60*$5); # may be 0
        $sec += 0.001 if ($tim =~ m/\.999Z/); # for some reason, at least OruxMaps on Android often reports 0.001 seconds less than a full second
        if ( $sec && TIME_CORRECTION ) {
            $sec += TIME_CORRECTION;
            $tim = epoch_to_str($sec);
        } else {
            $tim =~ s/(T\d\d)Z/$1:00Z/;
            $tim =~ s/(T\d\d:\d\d)Z/$1:00Z/;
        }
        $min_tim = $tim if $sec && $sec < $min_sec || $min_tim eq "";
        $min_sec = $sec if $sec && $sec < $min_sec || $min_sec == 0;
        $max_tim = $tim if $sec && $sec > $max_sec || $max_tim eq "";
        $max_sec = $sec if $sec && $sec > $max_sec || $max_sec == 0;
    }

    my $spd = "";
    if ($str =~ m#<(\w+:)?speed>\s*(-?[\.\d ]+)\s*</(\w+:)?speed>#s) {
        # we assume that recorded speed takes altitude into accouont (i.e., is not just horizontal/lateral speed),
        # see also https://forums.geocaching.com/GC/index.php?/topic/209525-gps-speed-3d-or-2d/
        $spd = $2;
        $spd /= 3.6 unless $1; # usuallly, speed is given m/s, while our abbreviated extension uses km/h
        $spd_prec_len = max($spd_prec_len, length(spd_str($spd))); # used only for spd_string
    }

    my $cmt = "";
    if ($is_trkpt && $str =~ s#[ \t]*(<cmt>.*?</cmt>)\n?##s) {
        $cmt = $1;
        $cmt =~ s#\n##sg;
    }

    my $ext = "";
    if ($str =~ s#[ \t]*(<extensions>.*?</extensions>)\n?##s) {
        $ext = $1;
        $ext =~ s#\n##sg;
    }

    my $rest = $str;
    $rest =~ s#\n##sg;
    $rest =~ s#>[ \t]+<#><#g;
    # clean up potential errors in input:
    $rest =~ s#<ele></ele>##;
    $rest =~ s#<time></time>##;

    my $ignore = 0;
    $ignore = 1 if
        ( $begin_sec && $sec && $sec < $begin_sec && ++$num_ignored_before ||
          $end_sec   && $sec && $end_sec < $sec   && ++$num_ignored_after  ||
          $max_elem  && $str =~ m#<$max_elem>\s*(-?[\.\d]+)\s*</$max_elem>#s && $1 > $max_elem_limit && ++$num_elem_above ||
          $min_elem  && $str =~ m#<$min_elem>\s*(-?[\.\d]+)\s*</$min_elem>#s && $1 < $min_elem_limit && ++$num_elem_below
        );
    $ext     =~ s#<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>##s if $max_ext &&
        $ext =~ m#<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>#s && $1 > $max_ext_limit && ++$num_ext_above;
    $ext     =~ s#<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>##s if $min_ext &&
        $ext =~ m#<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>#s && $1 < $min_ext_limit && ++$num_ext_below;
    $ext =~ s#<gpxtpx:TrackPointExtension></gpxtpx:TrackPointExtension>##sg;
    $ext =~ s#<extensions></extensions>##sg;

    return ( $lat, $lon, $ele, $tim, $sec, $spd, $rest, $cmt, $ext, $ignore );
}

sub print_line { print STDERR "$_[0]\n"; }

sub warning {
    print_line("WARNING: $_[0]") if $print_warnings;
}

sub info {
    print_line("INFO   : $_[0]") if $print_info;
}

sub abort {
    print_line("$_[0]aborting");
    exit 1;
}

sub debug {
    print_line("### DEBUG: $_[0]");
}

sub plural { my ($n, $str) = @_; return "$n $str".($n == 1 ? "" : "s"); }
sub points { return plural ($_[0], "point"); }

sub info_trkpt  { info_trkpt_i( -1, $_[0], $_[1] ); }
sub warn_trkpt  { warn_trkpt_i( -1, $_[0], $_[1] ); }
sub print_trkpt { print_trkpt_i( -1, $_[0], $_[1] ); }

sub info_trkpt_i {
    print_trkpt_i( $_[0], "INFO   : $_[1]", $_[2] ) if $print_info;
}

sub warn_trkpt_i {
    print_trkpt_i( $_[0], "WARNING: $_[1]", $_[2] ) if $print_warnings;
}

sub print_trkpt_i {
    my $i    = $_[0];
    my $head = $_[1];    # may be empty
    my $tail = $_[2];    # may be empty
    my ( $lati, $long, $elev, $t ) =
      $i < 0
      ? ( $lat, $lon, $ele, $tim )
      : ( $LAT[$i], $LON[$i], $ELE[$i], $TIM[$i] );

    # using original precision here for better traceability
    # $lati = lat_str($lati);
    # $long = lon_str($long);
    if ( $elev eq "" ) {
        $elev         = "NONE";
        $ele_prec_len = max( $ele_prec_len, length($elev) );
        $ele_full_len = max( $ele_full_len, length($elev) );
    }
    elsif ( $ele_full_len > $ele_prec_len ) {
        my $decimals = -1;
        $decimals = length($1) if $elev =~ m/\.(\d+)/;
        my $n_spaces = $ele_full_len - $ele_prec_len - $decimals - 1;
        $elev .= ' ' x $n_spaces if $n_spaces > 0;
    }
    my $time = $t ne "" ? $t : "NONE";
    print_line("$head "
      . "<trkpt"
      . ' lat="' . ( $lati . '"' . ( ' ' x max( 0, $lat_full_len - length($lati) ) ) )
      . ' lon="' . ( $long . '"' . ( ' ' x max( 0, $lon_full_len - length($long) ) ) )
      . " <ele>" . ele_string(-$ele_full_len, $elev)
      . ( $t ne "NO" ? " <time>" . ( $time . ( " " x max( 0, $tim_len - length($time) ) ) ) : "" )
      . "$tail");
    abort("") if ( $head =~ "^FATAL:" );
}

sub remove_trkpt {
    my $i = $_[0];
    $IGN[ $i + 1 ] = $IGN[$i] + 1; # indicate that previous point has been ignored, in addition to any previous ignores
    $SEG[ $i + 1 ] = 1 if $SEG[$i] && $i < $#SEG;  # take over any segment start
    $DIS[ $i + 1 ] = distance($LAT[ $i + 1 ], $LON[ $i + 1 ], $ELE[ $i + 1 ],
                              $LAT[ $i - 1 ], $LON[ $i - 1 ], $ELE[ $i - 1 ]) if $i > 0;
    splice @IGN, $i, 1;
    splice @SEG, $i, 1;
    splice @FLG, $i, 1;
    splice @LAT, $i, 1;
    splice @LON, $i, 1;
    splice @ELE, $i, 1;
    splice @TIM, $i, 1;
    splice @SEC, $i, 1;
    splice @DIS, $i, 1;
    splice @SPD, $i, 1;
    splice @CMT, $i, 1;
    splice @EXT, $i, 1;
}

sub distance {
    my $lat      = $_[0];
    my $lon      = $_[1];
    my $ele      = $_[2];
    my $prev_lat = $_[3];
    my $prev_lon = $_[4];
    my $prev_ele = $_[5];
    my $diff_lat = ( $lat - $prev_lat ) * METERS_PER_DEGREE_LAT;
    my $diff_lon = ( $lon - $prev_lon ) * METERS_PER_DEGREE_LAT *
      cos( deg2rad( ( $lat + $prev_lat ) / 2 ) );

#my$diff_lon = ($lon * cos(deg2rad($lat)) - $prev_lon * cos(deg2rad($prev_lat))) * METERS_PER_DEGREE_LAT;
    my $diff_ele = ( $ele ne "" && $prev_ele ne "" ? $ele - $prev_ele : 0 );

    # assuming no altitude change if no altitude available
    return sqrt( $diff_lat * $diff_lat + $diff_lon * $diff_lon + $diff_ele * $diff_ele );

#$distance = Math::Trig::great_circle_distance( #does not account for $diff_ele!
#						  deg2rad($lon)     , deg2rad(90 - $lat     ),
#						  deg2rad($prev_lon), deg2rad(90 - $prev_lat),
#						  40*1000*1000/pi/2); #http://perldoc.perl.org/Math/Trig.html
## debug "diff_lat=$diff_lat, diff_lon=$diff_lon, dis=$dis, distance=$distance";
}

sub distance_curr {    # of $lat, $lon, $ele
    return distance( $lat, $lon, $ele, $_[0], $_[1], $_[2] );
}

sub comp_diffs()
{ # of $lat, $lon, $ele relative to $prev_lat, $prev_lon, $prev_ele, so speed is relative to previous point
    # $prev_spd is assumed to be average speed computed between previous points
    my $dis = distance_curr( $prev_lat, $prev_lon, $prev_ele );
    # re-calculating distance since coordinates may have been filled in or smoothened
    my $diff_ele = ( $ele ne "" && $prev_ele ne "" ? $ele - $prev_ele : "" );

    #http://forums.howwhatwhy.com/showflat.php?Cat=&Board=scigen&Number=-208125
    my $timediff = ( $sec && $prev_sec ? $sec - $prev_sec : "" );
    my $rate = $diff_ele ne "" && $timediff ne ""
        ? ( $timediff > 0 ? 3600 * $diff_ele / $timediff : $prev_rate )
        : "";
    my $speed = ( $timediff ne ""
                  ? ( $timediff > 0 ? $dis / $timediff : $prev_spd )
                  : "" );
    $spd_prec_len = max($spd_prec_len, length(spd_str($speed))) if $speed ne ""; # used only for spd_string
    my $acc = ( $speed ne "" && $prev_spd ne "" && $timediff ne ""
                ? ( $timediff > 0 ? ( $speed - $prev_spd ) / $timediff : $prev_acc )
                : "" );
    return ( $diff_ele, $timediff, $rate, $dis, $speed, $acc );
}

### parse command line
# TODO clean up use of ARGV

for (my $i = 0; $#ARGV - $i >= 0; ) {
    my $opt  = $ARGV[$i];
    my $arg1 = $ARGV[$i + 1];
    my $arg2 = $ARGV[$i + 2];

    # not checking for duplicate options

    if ($opt eq "-h" || $opt =~ /^-*help$/) {
        print_line($usage);
        exit 0;
    } elsif ($opt eq "-swim"  ||
        $opt eq "-walk"  ||
        $opt eq "-cycle" ||
        $opt eq "-drive" ||
        $opt eq "-fly" ) {
        $activity = $opt;
    }
    elsif ( $opt eq "-no_sanitize" ) {
        $sanitize = !SANITIZE_TRKPTS;
    }
    elsif ( $opt eq "-smooth" ) {
        $smoothing = 1;
    }
    elsif ( $opt eq "-phases" ) {
        $phases = 1;
    }
    elsif ( $opt eq "-merge" ) {
        abort("missing file argument for -$opt option\n") if $#ARGV - $i < 1;
        $merge = $arg1;
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ($opt eq "-segs") {
        abort("cannot use both -days and -$opt option\n") if defined $days;
        abort("missing number argument for -$opt option\n") if $#ARGV - $i < 1;
        abort("not an integer argument for -$opt option: $arg1\n") unless $arg1 =~ m/^\d+$/;
        $segs = $parts = $arg1;
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ($opt eq "-days") {
        abort("cannot use both -segs adn -$opt option\n") if defined $segs;
        abort("missing number argument for -$opt option\n") if $#ARGV - $i < 1;
        abort("not an integer argument for -$opt option: $arg1\n") unless $arg1 =~ m/^\d+$/;
        $days = $parts = $part = $arg1;
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ( $opt eq "-weight" ) {
        abort("missing value argument for -$opt option\n") if $#ARGV - $i < 1;
        abort("cannot parse value argument in '$opt $arg1'\n") unless looks_like_number($arg1);
        $weight = $arg1 + 0;
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ( $opt eq "-begin" || $opt eq "-end") {
        abort("missing time argument for $opt option\n") if $#ARGV - $i < 1;
        my $sec = str_to_epoch($arg1);
        abort("cannot parse time argument in '$opt $arg1'\n") unless $sec;
        $begin_sec = $sec if $opt eq "-begin";
        $end_sec   = $sec if $opt eq "-end";
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ( $opt eq "-max" || $opt eq "-min" ) {
        abort("missing element name argument for $opt option\n") if $#ARGV - $i < 1;
        abort("missing limit argument for -$opt option\n") if $#ARGV - $i < 2;
        abort("cannot parse limit argument in '$opt $arg1 $arg2'\n") unless looks_like_number($arg2);
        ( $max_elem, $max_elem_limit ) = ( $arg1, $arg2 + 0 ) if $opt eq "-max";;
        ( $min_elem, $min_elem_limit ) = ( $arg1, $arg2 + 0 ) if $opt eq "-min";;
        splice @ARGV, $i + 1, 2;    # remove from ARGV the option arguments
    }
    elsif ( $opt eq "-max_ext" || $opt eq "-min_ext" ) {
        abort("missing extension name argument for $opt option\n") if $#ARGV - $i < 1;
        abort("missing limit argument for -$opt option\n") if $#ARGV - $i < 2;
        abort("cannt parse limit argument in '$opt $arg1 $arg2'\n") unless looks_like_number($arg2);
        ( $max_ext, $max_ext_limit ) = ( $arg1, $arg2 + 0 ) if $opt eq "-max_ext";
        ( $min_ext, $min_ext_limit ) = ( $arg1, $arg2 + 0 ) if $opt eq "-min_ext";
        splice @ARGV, $i + 1, 2;    # remove from ARGV the option arguments
    }
    elsif ( $opt eq "-prune_wpts" ) {
        $prune_wpts = 1;
    }
    elsif ( $opt eq "-prune_cmts" ) {
        $prune_cmts = 1;
    }
    elsif ( $opt eq "-prune_exts" ) {
        $prune_exts = 1;
    }
    elsif ( $opt eq "-nw" ) {
        $print_warnings = 0;
    }
    elsif ( $opt eq "-ni" ) {
        $print_info = 0;
    }
    elsif ( $opt eq "-o" ) {

     # not checking for operlap with shell-level redirection of STDOUT using '>'
        abort("missing outfile argument for -o option\n") if $#ARGV - $i < 1;
        open( $out, "> $arg1" );
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ( $opt =~ m/^-/ ) {
        abort("unknown option: $opt\n");
    }
    else {
        $i++;
        next;                   # infile
    }
    splice @ARGV, $i, 1;        # remove from ARGV the option just handled
}
if ( $prune_exts ) {
    warning("-max_ext option has little effect since -prune_exts is given") if $max_ext;
    warning("-min_ext option has little effect since -prune_exts is given") if $min_ext;
}
$parts = 1 unless defined $parts;
my $all = $parts - 1;

if ( $activity eq "-swim" ) {
    $MIN_TIMEDIFF           = 4;
    $MAX_PLAUSIBLE_SPEED    = 7;
    $MAX_PLAUSIBLE_ACCEL    = 1;
    $MAX_PLAUSIBLE_DECEL    = 2;
    $MAX_PLAUSIBLE_ELE_GAIN = 1;
    $MAX_PLAUSIBLE_ELE_LOSS = 1;
}
elsif ( $activity eq "-walk" ) {
    $MIN_TIMEDIFF           = 4;
    $MAX_PLAUSIBLE_SPEED    = 20;
    $MAX_PLAUSIBLE_ACCEL    = 0.5;
    $MAX_PLAUSIBLE_DECEL    = 1;
    $MAX_PLAUSIBLE_ELE_GAIN = 1800;
    $MAX_PLAUSIBLE_ELE_LOSS = 3600;
}
elsif ( $activity eq "-cycle" ) {
    $MIN_TIMEDIFF           = 2;
    $MAX_PLAUSIBLE_SPEED    = 80;
    $MAX_PLAUSIBLE_ACCEL    = 4;
    $MAX_PLAUSIBLE_DECEL    = 8;
    $MAX_PLAUSIBLE_ELE_GAIN = 3000;
    $MAX_PLAUSIBLE_ELE_LOSS = 9000;
}
elsif ( $activity eq "-drive" ) { # default
    $MIN_TIMEDIFF           = 2;     # in seconds
    $MAX_PLAUSIBLE_SPEED    = 200;   # maximal speed in km/h
    $MAX_PLAUSIBLE_ACCEL    = 5;     # maximal acceleration m/s/s
    $MAX_PLAUSIBLE_DECEL    = 10;    # maximal deceleration m/s/s
    $MAX_PLAUSIBLE_ELE_GAIN = 20000; # maximal ascent rate in m/h
    $MAX_PLAUSIBLE_ELE_LOSS = 20000; # maximal descent rate in m/h
    $PHASES_REPORT_THRESHOLD = 100;
}
elsif ( $activity eq "-fly" ) {
    $MIN_TIMEDIFF           = 1;
    $MAX_PLAUSIBLE_SPEED    = 1200;
    $MAX_PLAUSIBLE_ACCEL    = 10;
    $MAX_PLAUSIBLE_DECEL    = 10;
    $MAX_PLAUSIBLE_ELE_GAIN = 30000;
    $MAX_PLAUSIBLE_ELE_LOSS = 50000;
    $PHASES_REPORT_THRESHOLD = 100;
} else {
    abort("unknown activity: $activity\naborting\n");
}

### main loops

## read all trackpoints from all track segments, optionally completing them

{ # TODO re-format
my $ele_miss_start  = 0; # first index of recent stretch with missing ele ; TODO restrict scope
my $tim_miss_start  = 0; # first index of recent stretch with missing time; TODO restrict scope
my $num_no_ele      = 0;
my $ele_gap_length  = 0;
my $num_no_time     = 0;
my $time_gap_length = 0;
my $prev_tim        = "";
my $prev_sec        = 0;
# $prev_avail_tim = "";
push @DIST, 0;
push @RATE, 0;

$/ = "<trkpt ";
if ($merge) {
    open M, $merge || abort("FATAL: Cannot open alternative GPX source file $merge: $.\n") if $#TIM < 0;
    <M>; # first item is before "<trktpt"
}
my ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $cmt1, $exts1) if $merge; # current end of gap to be merged
my ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $cmt2, $exts2) if $merge; # current trkpt from alternative input
sub next_trkpt2() {
    my $trkpt2;
    my $ignore2 = 1;
    while ($ignore2 && defined($trkpt2 = <M>)) {
        $trkpt2 =~ m#(.*?</trkpt>)#s;
        $trkpt2 = $1;
        ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, my $rest_unused2, $cmt2, $exts2, $ignore2) = parse_point("<trkpt $trkpt2") if $trkpt2;
    }
    ## debug "read non-ignored point   from alt input with lat=$lat2 lon=$lon2 ele=$ele2 tim=$tim2 sec=$sec2 spd=".($spd2 eq "" ? "" : spd_str($spd2)) if $trkpt2;
    return $trkpt2;
}
my $in_merge = 0; # if set, using trkpt from $merge
if ($merge && !next_trkpt2()) {
    abort("FATAL: no trkpt found in alternative input $merge\n");
    $merge = 0;
    close M;
}

# TODO before further complicating input handling, split file reading and parsing from any further processing
for ( my $state = 0,
      my $prev_avail_sec  = 0, my $prev_avail_ele  = "",
      my $ele_miss_length = 0, my $tim_miss_length = 0,
      my $i = 0;
      $in_merge ? (next_trkpt2() ? 1
                   : ($in_merge = -$in_merge, $in_merge != -2 && defined($_ = <>))) # EOF in $merge
                : (defined($_ = <>) ||
                   # EOF in infile(s)
                   ($merge && (info("infile(s) ended before alternative input"), 1)
                       ? ($in_merge = 2, 1) : 0));
    ) {
    # anywhere (in headers, tracks, waypoints, trackpoints, ...):
    $num_pruned_cmts  += s#[ \t]*<cmts>.*?</cmt>\n?##sg              if $prune_cmts;
    $num_pruned_descs += s#[ \t]*<desc>.+?</desc>\n?##sg             if PRUNE_DESCS;
    $num_pruned_links += s#[ \t]*<link.*?>.+?</link>\n?##sg          if PRUNE_LINKS;
    $num_pruned_exts  += s#[ \t]*<extensions>.*?</extensions>\n?##sg if $prune_exts;

    #collect waypoints, possibly in later infile(s) headers
    my $prev_wpt_time_stripped = "";
    while (!$in_merge && s#(<wpt .+?)(</wpt>)\n?##s)
    {
        my $wpt = $1 . $2;
        # workaround for OruxMaps partly duplicating waypoints of <type>Finishing Point</type> when manually starting new segment
        my $wpt_time_stripped = $wpt;
        $wpt_time_stripped =~ s#<time>.*</time>##;
        next if $wpt_time_stripped eq $prev_wpt_time_stripped;
        $prev_wpt_time_stripped = $wpt_time_stripped;

        ( $lat, $lon, $ele, $tim, my $sec, my $spd, my $rest, my $cmt_unused, my $exts, my $ignore ) = parse_point($wpt); # collect some basic data even if pruned
        $rest =~ s#^<wpt[ \t]*##;
        $rest =~ s#</wpt>$##;
        ++$num_pruned_wpts if $prune_wpts;
        if (!$ignore && !$prune_wpts
            && !( PRUNE_AUTOMATIC_WPTS &&
                  $rest =~ m#<name><!\[CDATA\[\d*\]\]></name># && ++$num_auto_wpts )
            && !( $rest =~ m#\[(start|end.*?)\]# )
            && # waypoint with statistics added previously by this tool:
            !($rest =~ m#\[((max|min)\s+(altitude|elevation|height)|max\s+speed|max\s+(climb|ascent|descent)\s+rate|total\s+(ascent|descent|gain|loss))\s+=\s+[+-]?[\.\d]+ k?m(\/h)?( at -?[\.\d]+ km/h|;\s+avg\s+rate\s+=\s+[+-]?[\d.]+ m/h)?\]#))
        {
            push @WLAT, $lat;
            push @WLON, $lon;
            push @WELE, $ele;
            push @WTIM, $tim;
            push @WSEC, $sec;
            push @WTXT, $rest . $exts;
            $wpt =~ s/(^|\n)/\n  /sg;
            push @WSTR, $wpt;
        }
    }

    if ( $state == 0 ) {
        # processing first header (of first input file)

        # well, the following extension pruning may affect also header elements outside extensions
        s#[ \t]*<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>\n?##s if $max_ext
           && m#<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>#s && $1 > $max_ext_limit && ++$num_ext_above;
        s#[ \t]*<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>\n?##s if $min_ext
           && m#<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>#s && $1 < $min_ext_limit && ++$num_ext_below;

        if (s#\nGPXConv statistics (.*?)GPXConv statistics end\n##s)
        {    #remove any earlier statistics section
            my $stats = $1;
            warning("smoothing apparently has already been done on input")
              if $smoothing && $stats =~ m#smoothened#;
        }
        if (m#$/#s) {
            s#$/##s;    #remove trailing "<trkpt "
        }
        else {
            s#(^.*</type>).*#$1\n<trkseg>\n#s; #ignore rest of (header-only) file having no trkpt
        }
        s#[\s]+\n$#\n#s;    #remove any trailing spaces on line before
        s#[ \t]*(<trkseg>)#$1#s;
        $HEAD  = $_;
        $state = 1;         # expecting the very first trkpt
    }
    elsif (!$in_merge && m#(<gpx )#s) { # processing further track file
        ++$num_ignored_hdrs;
        if ($smoothing && m#\nGPXConv statistics (.*?)smoothened(.*?)GPXConv statistics end\n#)
        {
            warning("smoothing apparently has already been done on input");
        }
        if ( $#TIM >= 0 ) { # typically, new file
            info_trkpt_i( $i - 1, "end of segment at", "" ) if $i > 0;
            info("further track, from file $ARGV");
        }
        $state = 2 if $state > 2;    # expecting new trkseg
    }
    else {
        # when $state == 1 || $state == 2: processing first trkpt in new trkseg
        # when $state == 3: processing further trkpt in trkseg
        my ($sec, $spd, $cmt, $exts);
        if (!$in_merge) {
            m#(.*?</trkpt>)#s;
            my $trkpt = $1;
            ( $lat, $lon, $ele, $tim, $sec, $spd, my $rest_unused, $cmt, $exts, my $ignore ) = parse_point("<trkpt $trkpt");
            next if $ignore;
            ## debug "read non-ignored point $i from infile(s) with lat=$lat lon=$lon ele=$ele tim=$tim sec=$sec spd=".($spd eq "" ? "" : spd_str($spd))."; state = $state";
        } elsif ($merge) {
            ( $lat, $lon, $ele, $tim, $sec, $spd, $exts) =
                $in_merge == -1 ? ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $cmt1, $exts1) # EOF in $merge during infile(s)
                                : ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $cmt2, $exts2);
        }
        my $diff_time = $sec && $prev_avail_sec ? $sec - $prev_avail_sec : 0;

        if ($merge) {
            if (!$in_merge) {
                if (($diff_time >= MERGE_FILL_GAP || $state == 1)
                        && $sec && $sec2 && $sec2 < $sec) { # $merge currently is before infiles(s)
                    $in_merge = 1;
                    if ($state == 1) {
                        info("alternative input starts before infile(s)");
                    } else { # certainly $i > 0
                        info_trkpt_i( $i - 1, "start using alternative input on ".timediff_string($diff_time)." gap after", "" );
                    }
                    ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $cmt1, $exts1) =
                    ($lat , $lon , $ele , $tim , $sec , $spd , $cmt , $exts );
                    ($lat , $lon , $ele , $tim , $sec , $spd , $cmt , $exts ) =
                    ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $cmt2, $exts2);
                } else {
                    while ($merge && $sec && $sec2 && $sec2 <= $sec) {
                        # advance $merge as far as possible to catch up with infile(s)
                        ($merge = 0, close M) unless next_trkpt2();
                    }
                }
            } else { # $in_merge != 0
                if ($sec && $in_merge != 2 && $sec1 && $sec1 <= $sec) { # $merge is not before infiles(s)
                    ($lat , $lon , $ele , $tim , $sec , $spd , $cmt , $exts ) =
                    ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $cmt1, $exts1);
                    $in_merge = 0;
                    info_trkpt_i( $i - 1, "end using alternative input at", "" );
                }
            }
            $diff_time = $sec && $prev_avail_sec ? $sec - $prev_avail_sec : 0; # re-compute
        }
        if ( $state == 1 ) {
            info("initial track, from file $ARGV");
            info_trkpt( "first   segment at", "" );
        }
        else {
            print_trkpt("FATAL: before", " negative time difference (-".timediff_string(-$diff_time).")")
                if $diff_time < 0; # this implies $sec && $prev_sec
            if ($sec && $prev_sec && $diff_time == 0) {
                print_trkpt("FATAL: point before",
                            " has same time ($prev_tim) but different position ($prev_lat, $prev_lon)")
                    if $lat != $prev_lat || $lon != $prev_lon;
                print_trkpt("FATAL: point before",
                            " has same time ($prev_tim) but different altitude ($prev_ele m)")
                    if $ele != $prev_ele;
            }
        }

        my $flags = 0;
        my $dis = $state == 1 ? 0 : distance_curr( $prev_lat, $prev_lon, $prev_ele );
        if ( $state < 3 ) {    # the first point in trkseg
            if ( CARRY_OVER_ELE && $ele ne "" ) {
                if ( $i > 0 && $ELE[ $i - 1 ] eq "" ) {
                    $FLG[ $i - 1 ] |= SUBSTITUTED_ELE;
                    $ELE[ $i - 1 ] = $ele;
                    warn_trkpt_i($i - 1, "at segment end    ",
                                 " no altitude was given; using value from begin of next segment");
                }
            }
            elsif ($ele_miss_start) {
                warn_trkpt_i($i - 1, "             up to",
                             " was unable to interpolate missing altitude within segment");
                $ele_miss_start = 0;
            }
            if ( CARRY_OVER_TIME && $tim ne "" ) {
                if ( $i > 0 && $TIM[ $i - 1 ] eq "" ) {
                    $FLG[ $i - 1 ] |= SUBSTITUTED_TIM;
                    $TIM[ $i - 1 ] = $tim;
                    $SEC[ $i - 1 ] = $sec;
                    warn_trkpt_i($i - 1, "at segment end    ",
                                 " no time      was given; using value from begin of next segment");
                }
            }
            elsif ($tim_miss_start) {
                warn_trkpt_i($i - 1, "             up to",
                    " was unable to interpolate missing time within segment");
                $tim_miss_start = 0;
            }
            if ( $state == 2 ) {
                my $Dis = sprintf "%4" . DIS_PRECISION, $dis / 1000;
                my $Gap = timediff_string($diff_time);
                $Gap =~ s/^\s+//;
                info_trkpt( "further segment at", " after a gap of $Gap and $Dis km" );
            }

            my $resolution;
            if ( $ele eq "" ) {
                if ( $prev_avail_ele eq "" ) { # $prev_ele
                    $resolution = " and no previous value available";
                }
                elsif (CARRY_OVER_ELE) {
                    $ele = $prev_avail_ele; # $prev_ele; # will become $ELE[$i]
                    $resolution = "; using previous available value";
                    $flags |= SUBSTITUTED_ELE;
                }
                else {
                    $resolution = " and carrying over previous available value is disabled";
                }
                warn_trkpt( "at segment start  ",
                    " no altitude ".($resolution =~ / using / ? "was " : "")."given$resolution" );
            }
            if ( $tim eq "" ) {
                if ( $prev_tim eq "" ) {
                    $resolution = " and no previous value available";
                }
                elsif (CARRY_OVER_TIME) {
                    $tim = $prev_tim;    # will become $TIM[$i]
                    $sec = $prev_sec;    # will become $SEC[$i]
                    $flags |= SUBSTITUTED_TIM;
                    $resolution = "; using previous value";
                }
                else {
                    $resolution = " and carrying over previous value is disabled";
                }
                warn_trkpt( "at segment start  ",
                    " no time      ".($resolution =~ / using / ? "was " : "")."given$resolution" );
            }
        }
        else {    # state == 3, further (i.e., not the first) point in trkseg
            if ($ele eq "" && FILL_MISSING_ELE && ($ele_miss_start || $prev_ele ne "")) { # $prev_avail_ele
                ( $ele_miss_start, $ele_miss_length ) = ( $i, 0 )
                  if !$ele_miss_start; # $i is > 0
                $ele_miss_length += $dis;
            }
            if ( !$sec && $prev_sec && $spd ne "" && $spd > 0 ) {
                my $comp_sec = $prev_sec + $dis / $spd;
                # substitute time using recorded speed and distance from previous point
                $tim = epoch_to_str($comp_sec);    # will become $TIM[$i]
                $sec = $comp_sec;                  # will become $SEC[$i]
                warn_trkpt("at                ", " no time recognized, " .
                           " filled in using time difference calculated by distance / speed");
                $FLG[$i] |= SUBSTITUTED_TIM;
            }
            if ($tim eq "" && FILL_MISSING_TIME && ($tim_miss_start ||
                                                    $prev_tim ne "")) # not $prev_avail_tim, which may be an earlier time
            {
                ($tim_miss_start, $tim_miss_length) = ($i, 0) if $tim_miss_start == 0; # $i is > 0
                $tim_miss_length += $dis;
            }
        }
        if ( $ele ne "" && $ele_miss_start ) { # fill in missing altitude
            my $i_end = $i;
            if ( $state < 3 )
            {    # have been carrying over ele to end of last section
                $i_end--;
            }
            else {   # state == 3, further (i.e., not the first) point in trkseg
                $ele_miss_length += $dis;
            }
            my $ele_curr = $ELE[ $ele_miss_start - 1 ]; # $prev_avail_ele
            my $ele_gradient =
              $ele_miss_length > 0
              ? ( $ele - $ele_curr ) / $ele_miss_length
              : 0;
            for ( my $j = $ele_miss_start ; $j < $i_end ; $j++ ) {
                $ele_curr += $DIS[$j] * $ele_gradient;
                $ELE[$j] = sprintf "%.0f", $ele_curr;

# not changing $ele nor $prev_ele such that below time interpolation is not affected
                $FLG[$j] |= INTERPOLATED_ELE;
                ## debug "interpolating missing ele at point $j with ele=$ELE[$j]";
            }
            $ele_miss_start = 0;
        }
        if ($tim ne "" && $tim_miss_start) {    # fill in missing time by interpolation
            my $i_end = $i;
            if ( $state < 3 )
            {    # have been carrying over time to end of last section
                $i_end--;
            }
            else {   # state == 3, further (i.e., not the first) point in trkseg
                $tim_miss_length += $dis;
            }
            my $sec_curr = $SEC[ $tim_miss_start - 1 ]; # corresponds to $prev_tim
            my $sec_diff = $sec - $sec_curr;
            my $sec_gradient = $tim_miss_length > 0 ? $sec_diff / $tim_miss_length : 0;
            ## debug("over ".($tim_miss_length / 1000)." km, sec_diff = $sec_diff);
            for ( my $j = $tim_miss_start ; $j < $i_end ; $j++ ) {
                $sec_curr += $DIS[$j] * $sec_gradient;
                $SEC[$j] = $sec_curr;
                $TIM[$j] = epoch_to_str($sec_curr);
                $FLG[$j] |= INTERPOLATED_TIM;
                ## debug "interpolating missing time at point $j with time=$TIM[$j]";
            }
            $tim_miss_start = 0;
        }

        push @IGN, 0;
        push @SEG, $state < 3;
        push @FLG, $flags;
        push @LAT, $lat;
        push @LON, $lon;
        push @ELE, $ele;
        push @TIM, $tim;
        push @SEC, $sec;
        push @DIS, $dis;
        push @SPD, $spd; # initially as recorded, else ""
        push @CMT, $cmt;
        push @EXT, $exts;

        # detect and report missing time and/or altitude
        my $ele_solution  = "cannot calculate ascent/descent";
        $ele_solution  = "trying to interpolate altitude" if $ele_miss_start;
        my $time_solution = "cannot calculate speed and acceleration";
        $time_solution = "trying to interpolate time" if $tim_miss_start;
        if ( $ele eq "" ) {
            $num_no_ele++;
            $ele_gap_length += $dis;
            warn_trkpt( "no altitude     at", "; $ele_solution" )
              if $num_no_ele == 1;
        }
        elsif ($num_no_ele) {
            my $Len = sprintf "%4" . DIS_PRECISION, $ele_gap_length / 1000;
            warn_trkpt_i($i - 1, "no altitude  up to", " for ".points($num_no_ele)." over a distance of $Len km");
            $num_no_ele     = 0;
            $ele_gap_length = 0;
        }
        if (!$sec) {
            $num_no_time++;
            $time_gap_length += $dis;
            warn_trkpt( "no time         at", "; $time_solution" ) if $num_no_time == 1;
        }
        elsif ($num_no_time) {
            my $Len = sprintf "%4" . DIS_PRECISION, $time_gap_length / 1000;
            warn_trkpt_i($i - 1, "no time      up to", " for ".points($num_no_time)." over a distance of $Len km");
            $num_no_time     = 0;
            $time_gap_length = 0;
        }
        my $sec_str = $sec ? epoch_to_str($sec) : "";
        abort("FATAL: inconsistent time data for trkpt ".($i + 1).": tim=$tim != $sec_str (=$sec)\n")
            if $tim ne $sec_str && !($tim =~ m/\.999Z/ && $tim eq epoch_to_str($sec - 0.001));

        # will go wrong if previous trkpt gets ignored: $ELE[$#ELE] = $ELE[$#ELE-1] if $ele eq "" && !$SEG[$#ELE]; # implies $#ELE > 0
        $i++;
        ( $prev_lat, $prev_lon, $prev_ele, $prev_tim, $prev_sec, $prev_spd ) =
          ( $lat, $lon, $ele, $tim, $sec, $spd );
        $prev_avail_ele = $ele if $ele ne "";

     # Commenting out $prev_avail_tim as it is currently unused, but referred to
     # in another comment
     # $prev_avail_tim = $tim if $tim ne "";

        $prev_avail_sec = $sec if $sec; # enables checking negative time difference also across missing time entries
        $state = 3; # ready to process further trkpt(s) in trkseg (or new trkseg or new track)
    }
    if (!$in_merge && m#</trkseg>.*<trkseg>#s) {
        info_trkpt_i( $i - 1, "end of  segment at", "" ) if $i > 0;
        $state = 2; # starting new trkseg
        # reset intra-segment values
        $prev_spd = "";
    }
    if ($i > 0 && !$in_merge && m#<trk>#) { # further track
        ++$num_ignored_hdrs;
        info("further track, again from file $ARGV") unless m#<gpx #s;
    }
    if ($in_merge < 0) {
        $in_merge = $merge = 0;
        close M;
    }
}
my $Len = sprintf "%4" . DIS_PRECISION, $ele_gap_length / 1000; # TODO restrict scope
warn_trkpt_i($#TIM, "no altitude  up to",
             " for " . $num_no_ele . " points over a distance of $Len km") if $num_no_ele > 1;
$Len = sprintf "%4" . DIS_PRECISION, $time_gap_length / 1000;
warn_trkpt_i($#TIM, "no time      up to",
             " for " . $num_no_time . " points over a distance of $Len km") if $num_no_time > 1;
info_trkpt("last   segment end", "") if $#TIM >= 0;
warn_trkpt("                at",
           " was unable to interpolate missing altitude by end of last segment") if $ele_miss_start;
warn_trkpt("                at",
           " was unable to interpolate missing time by end of last segment") if $tim_miss_start;
} # end TODO re-format


## sanitize trackpoints with implausible data

my ($num_removals_ele, $num_removals_dir, $num_removals_spd, $num_removals_acc, $num_removals_dec,
    $num_removals_gain, $num_removals_loss, $num_removals_diff) = (0, 0, 0, 0, 0, 0, 0, 0);
if ($sanitize) { # TODO re-format
my $num_removals_in_row = 0;
my $last_ignore = 0;
my $sum_timediff_mov0 = 0;
my $num_pts_mov       = 0;
my ($timediff_before, $dis_before, $dis);
my $timediff = "";
my $spd_before;
$spd = "";
for ( my $acc, my $rate,
      my $i = 0 ; $i <= $#TIM ; $i++ ) {
    $spd_before = $spd;
    ( $lat, $lon, $ele, $tim, $sec, $spd ) =
      ( $LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i], $SPD[$i] );

    ## debug "sanitizing point $i with lat=$lat lon=$lon ele='$ele' tim='$tim' sec=$sec spd=".($spd eq "" ? "" : spd_str($spd));
    my ($ignore, $ignore_before) = (0, 0);
    sub ignore_trkpt        { ignoring_trkpt(  -1, @_); }
    sub ignore_trkpt_before { ignoring_trkpt($i-1, @_); }
    sub ignoring_trkpt { my ($index, $Spd, $reason) = @_;
        my $Spd_txt = $Spd eq "" ? "" : " at speed = $Spd km/h";
        warn_trkpt_i($index, "ignoring", "$Spd_txt because $reason");
    }

    if ($ele ne "" && $ele < MIN_PLAUSIBLE_ELE) {
        $num_removals_ele++;
        $ignore = 1;
        ignore_trkpt("", "altitude is less than ".MIN_PLAUSIBLE_ELE);
    }

    my $comp_spd = "";
    if ( $SEG[$i] ) { # at segment start
        $acc = $rate = ""; # keep any recorded speed, but reset acceleration and climb/descent rate
    }
    else {
        ( my $diff_ele, $timediff, $rate, $dis, $comp_spd, $acc ) = comp_diffs();
        my ($theta_diff, $Spd2) = (0, "");
        if (!$SEG[$i - 1]) { # previous point not at segment start, implies $i >= 2 here
            my $timediff2 = $timediff_before eq "" || $timediff eq "" ? 0 : $timediff_before + $timediff;
            my      $dis2 =      $dis_before eq "" ||      $dis eq "" ? 0 :      $dis_before +      $dis;
            my $spd2 = $timediff2 <= 0 || $dis2 <= 0 ? "" : $dis2 / $timediff2; # average speed between three most recent points
            $spd_prec_len = max($spd_prec_len, length(spd_str($spd2))) if $spd2 ne ""; # used only for spd_string
            if ($spd2 ne "" && $spd2 > MAX_PLAUSIBLE_ANGLE_SPD_THRESHOLD) {
                # calculate horizontal direction change (i.e., turning angle) for spike detection
                my $prev_lon_diff = nearest(.00001, $prev_lon) - nearest(.00001, $LON[$i - 2]);
                my $prev_lat_diff = nearest(.00001, $prev_lat) - nearest(.00001, $LAT[$i - 2]);
                my $curr_lon_diff = nearest(.00001,      $lon) - nearest(.00001, $prev_lon   );
                my $curr_lat_diff = nearest(.00001,      $lat) - nearest(.00001, $prev_lat   );
                if ($prev_lon_diff && $prev_lat_diff && $curr_lon_diff && $curr_lat_diff)
                {
                    my $theta1 = atan2($prev_lon_diff, $prev_lat_diff) * 360 / pi2;
                    my $theta2 = atan2($curr_lon_diff, $curr_lat_diff) * 360 / pi2;
                    $theta_diff = ($theta2 - $theta1) % 360;
                    $theta_diff -= 360 if $theta_diff >= 180;
                }
                $Spd2 = spd_string($spd2);
            }
        }
        my $Theta_diff = sprintf "%+.0f", $theta_diff;
        my $Comp_spd = spd_string($comp_spd) if $comp_spd ne "";
        if ($comp_spd ne "" && $spd ne "" && $timediff ne "" && $timediff <= MAX_TIMEDIFF_RECORDED_SPEED) {
            my $spd_diff = abs($comp_spd - $spd);
            $spd_prec_len = max($spd_prec_len, length(spd_str($spd_diff))); # used only for spd_string
            $sum_speed_deviation += $spd_diff;
            $sum_speed += $comp_spd + $spd; # will later divide by 2 for average;
            warn_trkpt("           before ",
                       "recorded speed is ".spd_string($spd).", computed speed is $Comp_spd km/h ".
                       "deviation is " . spd_string($spd_diff) . " km/h" .
                       " (more than " . MAX_SPEED_DEVIATION . ")") if $spd_diff > (MAX_SPEED_DEVIATION + 0.5) / 3.6;
        }
        if ($spd eq "" || $timediff ne "" && $timediff > MAX_TIMEDIFF_RECORDED_SPEED) {
            $spd = $comp_spd; # $SPD[$i] will be set later if needed
        }
        my $Spd      = $spd ne "" ? spd_string($spd) : "";
        my $Spd_txt  = $spd ne "" ? " at speed = $Spd km/h" : "";
        my $Dis      = sprintf "%4" . DIS_PRECISION, $dis / 1000;
        my $Warn_dis = sprintf "%" . DIS_PRECISION,  WARNING_TPT_DIST / 1000;
        my $Rate     = $rate ne "" ? sprintf RAT_PRECISION, $rate : "";
        my $Acc      = $acc ne "" ? sprintf ACC_PRECISION, $acc : "";
        my $Dec      = $acc ne "" ? sprintf ACC_PRECISION, -$acc : "";
        warn_trkpt("           before ", "$Spd_txt distance between points = $Dis km (more than $Warn_dis)") if $dis > WARNING_TPT_DIST;

        $ignore = 1; # tentatively remove point before
        if (MAX_PLAUSIBLE_ANGLE_DIFF < abs($theta_diff)) {
            $num_removals_dir++;
            ignore_trkpt_before($Spd2, "direction change = $Theta_diff° (".($theta_diff >= 0 ? "more than  " : "less than -").MAX_PLAUSIBLE_ANGLE_DIFF."°)");
        } else {
            $ignore = 0;
        }
        if ($ignore) {
            $num_removals_in_row++;
            remove_trkpt(--$i);
            # maybe should re-compute speed etc. relative to new previous point
            $ignore_before = 1;
            $ignore = 0;
        }
        $ignore = 1; # tentatively remove current point
        if ($spd ne "" && $Spd > $MAX_PLAUSIBLE_SPEED) {
            $num_removals_spd++;
            ignoring_trkpt("", "speed = $Spd km/h more than ".$MAX_PLAUSIBLE_SPEED);
        }
        elsif ($acc ne "" &&  $acc > $MAX_PLAUSIBLE_ACCEL && ($FLG[$i - 1] & INTERPOLATED_TIM) == ($FLG[$i] & INTERPOLATED_TIM)) {
            $num_removals_acc++;
            ignore_trkpt($Comp_spd, "acceleration = $Acc m/s/s (more than $MAX_PLAUSIBLE_ACCEL)");
        }
        elsif ($acc ne "" && -$acc > $MAX_PLAUSIBLE_DECEL && ($FLG[$i - 1] & INTERPOLATED_TIM) == ($FLG[$i] & INTERPOLATED_TIM)) {
            $num_removals_dec++;
            ignore_trkpt($Comp_spd, "deceleration = $Dec m/s/s (more than $MAX_PLAUSIBLE_DECEL)");
        }
        elsif ($rate ne "" && $rate > $MAX_PLAUSIBLE_ELE_GAIN) {
            $num_removals_gain++;
            ignore_trkpt($Spd, " ascent rate = $Rate m/h (more than  $MAX_PLAUSIBLE_ELE_GAIN)");
        }
        elsif ($rate ne "" && $rate < -$MAX_PLAUSIBLE_ELE_LOSS) {
            $num_removals_loss++;
            ignore_trkpt($Spd, "descent rate = $Rate m/h (less than -$MAX_PLAUSIBLE_ELE_LOSS)");
        }
        elsif ($timediff ne "" && $timediff < $MIN_TIMEDIFF && ($FLG[$i - 1] & INTERPOLATED_TIM) == ($FLG[$i] & INTERPOLATED_TIM))
        {
            my $inter = ( $FLG[$i] & INTERPOLATED_TIM ) ? "interpolated " : "";
            $num_removals_diff++;
            ignore_trkpt($Spd, $inter."time difference = ".int($timediff).
                         " sec (less than $MIN_TIMEDIFF) over a distance of $Dis km") if $timediff > 1.001;
        } else {
            $ignore = 0;
            if (!$ignore_before && $spd ne "" && $spd >= MIN_SPEED_MOVING / 3.6) # implies $timediff ne ""
            {
                $sum_timediff_mov0 += $timediff; # used for smoothing
                $num_pts_mov++;                  # used for smoothing
            }
        }
    }
    if ($ignore) {
        if (!$ignore_before && $last_ignore == -1) { # must delay output by one point because current point may be ignored in next iteration
            warning("ignored $num_removals_in_row points in a row") if $num_removals_in_row > 1;
            $num_removals_in_row = 0;
        }
        $num_removals_in_row++;
        remove_trkpt($i--);
        # will re-compute speed etc. relative to same previous point as before
    }
    elsif (!$ignore_before) {
        if ($last_ignore != 1) { # must delay output by one point because current point may be ignored in next iteration
            warning("ignored $num_removals_in_row points in a row") if $num_removals_in_row > 1;
            $num_removals_in_row = 0;
        }
        ( $prev_lat, $prev_lon, $prev_ele,  $prev_tim,
          $prev_sec, $prev_spd, $prev_rate, $prev_acc )
            = ( $lat, $lon, $ele, $tim, $sec, $comp_spd, $rate, $acc );
    }
    if ($ignore_before) {
        ($prev_lat, $prev_lon, $prev_ele, $prev_tim, $prev_sec, $prev_spd, $prev_rate, $prev_acc) =
        (     $lat,      $lon,      $ele,      $tim,      $sec, $comp_spd, $prev_rate, $prev_acc);
        $timediff += $timediff_before;
        $dis += $dis_before;
    }
    ($timediff_before, $dis_before) = ($timediff, $dis);
    $last_ignore = $ignore ? 1 : $ignore_before ? -1 : 0;
}
warning("ignored $num_removals_in_row points in a row") if $num_removals_in_row > 1;

$avg_timediff = $num_pts_mov ? $sum_timediff_mov0 / $num_pts_mov : 0; # used for smoothing
# $sum_timediff_mov will be re-computed thereafter, since points may have been ignored or smoothened
} # end TODO re-format

abort("FATAL: No trackpoint (possibly after ignoring some)\n") if $#TIM < 0;


## check waypoints

for ( my $j = 0 ; $j <= $#WSEC ; $j++ ) {
    $sec = $WSEC[$j];
    unless ($sec) {
        warning("waypoint '$WSTR[$j]\n' does not have time information; skipping proximity check");
        next;
    }
    if ( $j > 0 && $WSEC[ $j - 1 ] && $sec - $WSEC[ $j - 1 ] < 0 ) {
        warning("waypoint '$WSTR[$j]\n' is before previous waypoint: $WSTR[$j-1]");
    }
    if ( $#TIM < 0 ) { # can not happen due to above check
        warning("no trackpoint found for checking waypoints");
        last;
    }
    else {
        # find trackpoint at or just after wpt
        my $i2 = 0; # would be more efficient to do this just before the wpt loop, but then cannot deal with wpts not in time order
        while ( $i2 <= $#TIM && $SEC[$i2] < $sec && ( $i2 == 0 || $SEC[ $i2 - 1 ] != 0 ) )
        {
            $i2++;
        }
        my $i1 = ( $i2 > 0 ? $i2 - 1 : $i2 )
          ; # trackpoint just before, if any, else same as the one just determined
        next
          if $LAT[$i1] == $WLAT[$j]
          && $LON[$i1] == $WLON[$j]
          && $ELE[$i1] == $WELE[$j];    # late finishing point
        next
          if $LAT[$i2] == $WLAT[$j]
          && $LON[$i2] == $WLON[$j]
          && $ELE[$i2] == $WELE[$j];    # early starting point
        if ( $i2 > $#TIM ) {
            warning("no trackpoint found at same time or later than waypoint '$WSTR[$j]\n';" .
                    " will extrapolate distance from the one before"
            );
        }
        my $linear_factor = ( $SEC[$i2] - $SEC[$i1] <= 0 ? 0
                              : ( $sec - $SEC[$i1] ) / ( $SEC[$i2] - $SEC[$i1] ) );
        $lat = $LAT[$i1] + ( $LAT[$i2] - $LAT[$i1] ) * $linear_factor;
        $lon = $LON[$i1] + ( $LON[$i2] - $LON[$i1] ) * $linear_factor;
        my $ele2 = $ELE[$i2] eq "" ? ( $WELE[$j] eq "" ? $ELE[$i1] : $WELE[$j] ) : $ELE[$i2];
        my $ele1 = $ELE[$i1] eq "" ? $ele2 : $ELE[$i1];
        $ele  = $ele1 eq "" || $ele2 eq "" ? "" : $ele1 + ( $ele2 - $ele1 ) * $linear_factor;
        my $dis = distance_curr( $WLAT[$j], $WLON[$j], $WELE[$j] );
        $tim = "NO"; # do not print time for interpolated point, since done already for wpt
        my $Dis = sprintf "%.0f", $dis;
        warn_trkpt("according to its time information, waypoint '$WSTR[$j]\n' appears not close to track "
              . "(interpolated distance = $Dis m > " . WARNING_WPT_DIST . "); "
              . "it should be approximately at", "")
          if $dis > WARNING_WPT_DIST;
    }
}

## smoothen trackpoints

# smoothen each point, by weightened average with (smoothened) previous point and (original) next point
sub average {

    sub weight {
        #   my $d = 1.5*$avg_timediff; # max dist of influence
        #   return max(0, ($d-$_[0])/$d);
        return 1 / ( 1 + $_[0] / $avg_timediff );
    }
    my $x1 = $_[0];
    my $x  = $_[1];
    my $x2 = $_[2];
    my $diff_time1 = $_[3];
    my $diff_time2 = $_[4];

    #return $x;
    return ( $x1 * weight($diff_time1) + $x + $x2 * weight($diff_time2) ) /
      ( weight($diff_time1) + 1 + weight($diff_time2) );
}

if ( $smoothing ) {
    for ( my $i = 0 ; $i <= $#TIM ; $i++ ) {
        ( $tim, $sec ) = ( $TIM[$i], $SEC[$i] );
        if ( 0 < $i && $i < $#SEC && $SEC[ $i - 1 ]
             && $sec && $SEC[ $i + 1 ] && !$SEG[$i] && !$SEG[ $i + 1 ] )
        {
            my $diff_time1 = $sec - $SEC[ $i - 1 ];
            my $diff_time2 = $SEC[ $i + 1 ] - $sec;
            if ( max( $diff_time1, $diff_time2 ) <= SMOOTHING_MAX_GAP ) {
                $LAT[$i] = average( $prev_lat * 0 + $LAT[ $i - 1 ], $LAT[$i], $LAT[ $i + 1 ] , $diff_time1 , $diff_time2 );
                $LON[$i] = average( $prev_lon * 0 + $LON[ $i - 1 ], $LON[$i], $LON[ $i + 1 ] , $diff_time1 , $diff_time2 );
                $ELE[$i] = average( $prev_ele * 0 + $ELE[ $i - 1 ], $ELE[$i], $ELE[ $i + 1 ] , $diff_time1 , $diff_time2 )
                    if $prev_ele ne ""  && $ELE[ $i - 1 ] ne "" && $ELE[$i] ne "" && $ELE[ $i + 1 ] ne "";
                # speed will be re-computed later
                # individiual points are not marked as smoothed; this is done globally
            }
        }
        ( $prev_lat, $prev_lon, $prev_ele ) = ( $LAT[$i], $LON[$i], $ELE[$i] );
    }
}

## perform analysis/statistics

my $energy_missing_ele = 0;
my $energy_missing_spd = 0;
sub energy { # calculate energy difference between trackpoints  # TODO simplify provisioning of parameters using index
    my $t  = $_[0];                # start date and time
    my $t0 = $_[1];                # start time relative to begin of track in s
    my $t1 = $_[2];                # end   time relative to begin of track in s
    my $dt = $t1 - $t0;            # duration in s
    my $d  = $_[3];                # 3-dimensional distance in m
    my $h0 = $_[4];                # altitude before in m
    my $h1 = $_[5];                # altitude after  in m
    my $default_ele = 500;         # default altitude in m assumed for calculating density
    if ($h0 eq "" || $h1 eq "" ) {
        $h0 = $h1 = $default_ele;
        warning("missing altitude information for calculating energy, at least at $t") unless $energy_missing_ele;
        $energy_missing_ele = 1;
    }
    my $dh =  $h1 - $h0;           # altitude difference, or 0 if $default_ele used
    my $h  = ( $h0 + $h1 ) / 2;    # average altitude, used for air density
    my $v0 = $_[6];                # speed before in m/s
    my $v1 = $_[7];                # speed after  in m/s
    my $default_spd = 0;           # default speed in m/s assumed for calculating acceleration and air drag
    if ($v0 eq "" || $v1 eq "") {
        $v0 = $v1 = $default_spd;
        warning("missing speed information for calculating energy, at least at $t") if $energy_missing_spd < 2;
        $energy_missing_spd++;
    }
    my $v  = ( $v0 + $v1 ) / 2;    # average speed, used for air drag, assumed with no wind (i.e., calm air)
    my $g = 9.81;                  # gravity constant in m/(s^2)

# values and formulas adapted from https://www.sheldonbrown.com/rinard/aero/formulas.html
    my $m = $weight;               # total mass including vehicle and rider in kg
    my $cr = 0.003;                # coefficient of rolling friction for racing bike      - adapt
    my $cdA = 0.39;                # coefficient of wind resistance * frontal area in m^2 - adapt
    my $r = 1.2;                   # air density on average weather (20 °C) at sea level in kg/(m^3)
    my $density = $r - ( 0.55 * $r ) * $h / 5000; # roughly corrected air density depending on altitude

    # energy components and their sum along the distance $d in Joule
    my $roll  = $cr * $m * $g * $d;
    my $slope = $m * $g * $dh;
    my $accel = $m / 2 * ( $v1 * $v1 - $v0 * $v0 );
    my $drag  = $density * $cdA / 2 * $v * $v * $d;
    my $sum   = $roll + $slope + $accel + $drag;

    ## my $debug_inputs = "dt=" . int($dt) . " d=" . int($d) . " dh=" . int($dh) . " v0=" . int($v0) . " v1=" . int($v1);
    ## my $debug_outputs = "roll:" . int($roll) . " + slope:" . int($slope) . " + accel:" . int($accel) . " + drag:" . int($drag) . " = sum:" . int($sum);
    ## debug "energy @ time=$t  $debug_inputs   =>   $debug_outputs";

    return $sum;
}

sub push_phase {
    my $start_index    = $_[0];
    my $end_index      = $_[1];
    my $sec1           = $SEC[$start_index];
    my $sec2           = $SEC[$end_index];
    my $duration       = -1;
    my $diff_ele       = $ELE[$end_index] - $ELE[$start_index];
    my $dist           = 0;
    my $rate           = 0;
    my $spd_           = 0;
    my $max_rate       = 0;
    my $max_rate_index = 0;
    my $max__spd       = 0;
    my $max__spd_index = 0;

    for ( my $i = $start_index + 1 ; $i <= $end_index ; $i++ ) {
        $dist += $DIST[$i];
        $rate = $RATE[$i];
        $spd_ = $SPD[$i];
        ( $max_rate, $max_rate_index ) = ( $rate, $i ) if $rate ne "" && ( $diff_ele >= 0 ? $rate > $max_rate : $rate < $max_rate );
        ( $max__spd, $max__spd_index ) = ( $spd_, $i ) if $spd_ ne "" && $spd_ > $max__spd;
    }
    my $avg_spd  = "";
    my $avg_rate = 0;
    if ( $sec1 && $sec2 && $sec2 > $sec1 ) {
        $duration = $sec2 - $sec1;
        $avg_spd  = $dist / $duration;
        $avg_rate = 3600 * $diff_ele / $duration;
    }
    push @PHASE_DURATION,      $duration;
    push @PHASE_DIFF,          $diff_ele;
    push @PHASE_DIST,          $dist;
    push @PHASE_SPD,           $avg_spd;
    push @PHASE_RATE,          $avg_rate;
    push @PHASE_MAXSPD_INDEX,  $max__spd_index;
    push @PHASE_MAXRATE_INDEX, $max_rate_index;
    push @PHASE_END_INDEX,     $end_index;
}

for( my $rate, my $spd, my $direction,
     my $prev_turn_index, my $prev_turn_ele, my $prev_turn_sec,
     my $local_max_index = 0, my $local_min_index = 0,
     my $local_max_sec = 0, my $local_min_sec = 0,
     my $local_max_ele = 0, my $local_min_ele = 0,
     my $prev_date = "", my $date,
     my $seg = 0, my $part_or_all = $all,
     my $i = 0 ; $i < $#TIM + 1 ; $i++ ) {
    if ( $i <= $#TIM ) {
        ( $lat, $lon, $ele, $tim, $sec, $spd ) =
          ( $LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i], $SPD[$i] );
        $date = $tim =~ m/(.?)T/ ? $1 : "";
        if (defined $days) {
            $part++ if $date ne "" && $prev_date ne "" && $date ne $prev_date;
            $part_or_all = $part;
        }
    }
    else {
        $ele = $prev_turn_ele;
    }
    if ($SEG[$i]) { # track segment start (which includes the start: $i == 0)
        $seg++;
        $part = $part_or_all = $seg if defined $segs && $seg >= $segs;

        # (re-)start climb phase recognition
        $direction       = 0;
        $prev_turn_ele   = $local_max_ele   = $local_min_ele = "";
    }
    if ($i <= $#TIM) {
        $PART_END_INDEX[$all ] = $i;
        $PART_END_INDEX[$part] = $i if defined $part;
    }
    if ($ele ne "") {
        ( $prev_turn_ele, $prev_turn_index ) = ( $ele, $i ) if ( $prev_turn_ele eq "" );
        ( $local_max_ele, $local_max_index ) = ( $ele, $i ) if $direction >= 0
            && ( $local_max_ele eq "" || $ele > $local_max_ele );
        ( $local_min_ele, $local_min_index ) = ( $ele, $i ) if $direction <= 0
            && ( $local_min_ele eq "" || $ele < $local_min_ele );
    }
    if ( !$SEG[$i] && $ele ne "" ) {    # not at segment start
      check_next:
        $prev_turn_sec = $SEC[$prev_turn_index];
        $local_max_sec = $SEC[$local_max_index];
        $local_min_sec = $SEC[$local_min_index];
        my $seg_end       = $i == $#TIM || $SEG[ $i + 1 ];
        if ( $direction >= 0 && $local_max_index > $prev_turn_index
             && ( $ele <= $local_max_ele -ELE_THRESHOLD || $seg_end ) )
        {    # when actually starting going down, or at end
            my $diff_ele = $local_max_ele - $prev_turn_ele;
            if ( $diff_ele >= ELE_THRESHOLD ) {
                if ($phases && $diff_ele >= $PHASES_REPORT_THRESHOLD) {
                    push_phase($prev_turn_index, $local_max_index);
                } else {
                    $ascent__phases_suppressed++;
                }
                my $diff_sec = $local_max_sec - $prev_turn_sec;
                 $SUM__ASCENT[$all ] += $diff_ele;
                $TIME__ASCENT[$all ] += $diff_sec;
                 $SUM__ASCENT[$part] += $diff_ele if defined $part;
                $TIME__ASCENT[$part] += $diff_sec if defined $part;
                $LAST_GAIN_INDEX[$all] =
                $LAST_GAIN_INDEX[$part_or_all] = $local_max_index if $ele ne "";
            }
            ( $prev_turn_ele, $prev_turn_index ) = ( $local_max_ele, $local_max_index );
            ( $local_min_ele, $local_min_index ) = ( $ele, $i );
            $direction = -1;
            goto check_next;
        }
        elsif ($direction <= 0 && $local_min_index > $prev_turn_index
            && ( $ele >= $local_min_ele + ELE_THRESHOLD || $seg_end ) )
        {    # when actually starting going up, or at end
            my $diff_ele = $local_min_ele - $prev_turn_ele;
            if ( -$diff_ele >= ELE_THRESHOLD ) {
                if ($phases && -$diff_ele >= $PHASES_REPORT_THRESHOLD) {
                    push_phase($prev_turn_index, $local_min_index);
                } else {
                    $descent_phases_suppressed++;
                }
                my $diff_sec = $local_min_sec - $prev_turn_sec;
                 $SUM_DESCENT[$all ] += $diff_ele;
                $TIME_DESCENT[$all ] += $diff_sec;
                 $SUM_DESCENT[$part] += $diff_ele if defined $part;
                $TIME_DESCENT[$part] += $diff_sec if defined $part;
                $LAST_LOSS_INDEX[$all] =
                $LAST_LOSS_INDEX[$part_or_all] = $local_min_index if $ele ne "";
            }
            ( $prev_turn_ele, $prev_turn_index ) =
              ( $local_min_ele, $local_min_index );
            ( $local_max_ele, $local_max_index ) = ( $ele, $i );
            $direction = 1;
            goto check_next;
        }
    }
    if ( $i <= $#TIM ) {
        ( my $diff_ele_unused, my $timediff, $rate, my $dis, $spd, my $acc_unused ) =
          $SEG[$i] ? ( "", "", "", 0, "", "" ) : comp_diffs();
        $sum_dis += $dis;
        if ($SPD[$i] eq "" || ($timediff ne "" && $timediff > MAX_TIMEDIFF_RECORDED_SPEED)) # set computed speed if recorded speed is not available or over unusually long time
        {
            $SPD[$i] = $spd;
            $FLG[$i] |= COMPUTED_SPEED if $spd ne "";
        }
        $spd = $SPD[$i];
        push @DIST, $dis;
        push @RATE, $rate;
        if ($spd ne "" && $timediff ne "" && $spd >= MIN_SPEED_MOVING / 3.6) {
            $sum_timediff_mov += $timediff;
        }
        if ( $weight && !$SEG[$i] ) { # not at segment start
            my $tim_start = round_tim($TIM[$i - 1]);
            $tim_start = "<unknown time>" if $tim_start eq ""; # TODO improve, using index
            my $start_sec = $#TIM < 0 ? 0 : $SEC[0];
            $sum_energy += energy($tim_start,
                                  $prev_sec - $start_sec,
                                  $sec - $start_sec,
                                  $dis, $prev_ele, $ele,
                                  $prev_spd, $spd);
        }
    }

    $min_lat = $lat if $i == 0 || $min_lat > $lat;
    $max_lat = $lat if $i == 0 || $max_lat < $lat;
    $min_lon = $lon if $i == 0 || $min_lon > $lon;
    $max_lon = $lon if $i == 0 || $max_lon < $lon;
    $max_sec = $sec if            $max_sec < $sec; # may be 0
    if ($spd ne "") {
        ($MAX_SPD[$all ], $MAX_SPD_INDEX[$all ]) = ($spd, $i) if (!defined $MAX_SPD[$all ] || $MAX_SPD[$all ] < $spd);
        ($MAX_SPD[$part], $MAX_SPD_INDEX[$part]) = ($spd, $i) if defined $part
                                                              && (!defined $MAX_SPD[$part] || $MAX_SPD[$part] < $spd);
    }
    if ($ele ne "") {
        ($MIN_ELE[$all ], $MIN_ELE_INDEX[$all ]) = ($ele , $i) if !defined $MIN_ELE[$all ] || $MIN_ELE[$all ] > $ele;
        ($MAX_ELE[$all ], $MAX_ELE_INDEX[$all ]) = ($ele , $i) if !defined $MAX_ELE[$all ] || $MAX_ELE[$all ] < $ele;
        if (defined $part) {
        ($MIN_ELE[$part], $MIN_ELE_INDEX[$part]) = ($ele , $i) if !defined $MIN_ELE[$part] || $MIN_ELE[$part] > $ele;
        ($MAX_ELE[$part], $MAX_ELE_INDEX[$part]) = ($ele , $i) if !defined $MAX_ELE[$part] || $MAX_ELE[$part] < $ele;
        }
    }
    if ($rate ne "") {
        my $gain = max($rate, 0);
        my $loss = min($rate, 0);
        ($MAX_GAIN[$all ], $MAX_GAIN_INDEX[$all ]) = ($gain, $i) if !defined $MAX_GAIN[$all ] ||  $MAX_GAIN[$all ] <  $rate;
        ($MAX_LOSS[$all ], $MAX_LOSS_INDEX[$all ]) = ($loss, $i) if !defined $MAX_LOSS[$all ] || -$MAX_LOSS[$all ] < -$rate;
        if (defined $part) {
        ($MAX_GAIN[$part], $MAX_GAIN_INDEX[$part]) = ($gain, $i) if !defined $MAX_GAIN[$part] ||  $MAX_GAIN[$part] <  $rate;
        ($MAX_LOSS[$part], $MAX_LOSS_INDEX[$part]) = ($loss, $i) if !defined $MAX_LOSS[$part] || -$MAX_LOSS[$part] < -$rate;
        }
    }

    ($prev_lat, $prev_lon, $prev_ele, $prev_date, $prev_sec, $prev_spd) =
        ( $lat,      $lon,      $ele,      $date,      $sec,      $spd) if $i < $#TIM;
}
$lat_prec_len = max(length(lat_str($max_lat)), length(lat_str($min_lat)));
$lon_prec_len = max(length(lon_str($max_lon)), length(lon_str($min_lon)));

#$sec_diff = $SEC[$max_ele_index] - $SEC[$min_ele_index];
#$avg_gain = $sec_diff != 0 ? ($max_ele - $min_ele) / $sec_diff * 3600 : 0;


## optional elevation correction by geoid height

sub neg_geoid_height {    # potentially $updates $found_corr and $ele_corr
    my $lat = $_[0];
    my $lon = $_[1];
    return $ele_corr if !GEOID_ELE_CORRECTION;
    ( my $fh, my $tmp_GeoidEval ) = tempfile();
    system "wget --quiet -O $tmp_GeoidEval "
      . "http://geographiclib.sourceforge.net/cgi-bin/GeoidEval?input=$lat+$lon";
    open G, $tmp_GeoidEval;
    while (<G>) {
        if (m#EGM84</a>\s*=\s*<font.*?>\s*(-?[\.\d]+)\s*</font>#i) {
            $found_corr = 1;
            $ele_corr   = -$1;
        }
    }
    close G;
    if ($found_corr) {
        info_trkpt( "   at    ", " geoid height is $ele_corr m" );
    }
    else {
        warn_trkpt( "at    ", " geoid height is assumed $ele_corr m" );
    }
    return $ele_corr;
}

sub linear_ele_correction {
    return 0;                                   # linear correction not wanted
    my $sec  = $_[0];
    my $sec1 = 1296543617;                      #start time
    my $sec2 = 1296569335;                      #end   time
    return 0 unless ( $sec1 <= $sec && $sec <= $sec2 );   # linear correction not in scope
    my $ele1 = 4720 - 4677;                     #actual and wanted start value
    my $ele2 = 1925 - 1635;                     #actual and wanted end   value
    return
      int( ( $sec - $sec1 ) / ( $sec2 - $sec1 ) * ( $ele2 - $ele1 ) + $ele1 );
}

sub correct_ele {    # may update $ele_corr; uses $ele_corr
    my $j = $_[0];    # index of waypoint if >= 0
    my $i = $_[1];    # otherwise, index of trackpoint or < 0 for none
    return "" if $j < 0 && $i < 0;
    my ( $lat, $lon, $ele, $sec ) =
      $j >= 0
      ? ( $WLAT[$j], $WLON[$j], $WELE[$j], $WSEC[$j] )
      : ( $LAT[$i], $LON[$i], $ELE[$i], $SEC[$i] );
    return "" if $ele eq "";
    $ele_corr = neg_geoid_height( $lat, $lon ) if ( $j >= 0 || $i == 0 || $SEC[ $i - 1 ] ) ;
    # do expensive operation only at specific points or beginning of track segment
    if ( $ele_corr && $ele ne "" ) {
        $ele += $ele_corr + linear_ele_correction($sec);
    }
    return $ele;
}

## prepare output header

# TODO make below decls local
#must be done before interpolating, which may shift indexes
my $Min_lat     = lat_str($min_lat);
my $Min_lon     = lon_str($min_lon);
my $Max_lat     = lat_str($max_lat);
my $Max_lon     = lon_str($max_lon);
my $Sum_dis    = sprintf "%" . DIS_PRECISION, $sum_dis / 1000;
my $Sum_energy = sprintf "%.0f", $sum_energy / 1000 if $weight;
my $Avg_spd    = sprintf AVG_PRECISION, 3.6 * $sum_dis / $sum_timediff_mov if $sum_timediff_mov;
my $Sum_timediff_mov = timediff_string($sum_timediff_mov);
   $Sum_timediff_mov =~ s/^\s+//;
my $Speed_deviation_text = $sum_speed ? ("average deviation between recorded and computed speed (for points at most ".MAX_TIMEDIFF_RECORDED_SPEED." seconds apart) = ".
                                         int(0.5 + 100 * $sum_speed_deviation / ($sum_speed / 2))." %\n") : "";

$HEAD =~ s/(<gpx )/$1creator="GPXConv" /
  unless $HEAD =~ m/<gpx.*? creator\s*=.*?>/;
$HEAD =~ s/(<gpx )/$1version="1.1" / unless $HEAD =~ m/<gpx.*? version\s*=.*?>/;
$HEAD =~ s|(<gpx )|$1xmlns:x="http://www.garmin.com/xmlschemas/TrackPointExtension/v2" |;

# http://docstore.mik.ua/orelly/perl/cookbook/ch06_07.htm match multiple lines with 's' option
if ($HEAD =~ m|(\r?\n?[ \t]*)</metadata>|s) { # TODO insert metadata if not present
    my $indent = $1;
    $indent .= ($indent =~ m/ $/ ? '    ' : "\t");
    if ( $min_tim ne "" ) {
        $min_tim = round_tim($min_tim);
        $HEAD =~ s|\r?\n?[ \t]*<time>.*?</time>||sg;   # remove any pre-existing time entry
        $HEAD =~ s|(\r?\n?[ \t]*</metadata>)|$indent<time>$min_tim</time>$1|s; # add new time
    }
    my $bounds = '<bounds'
      .  ' minlat="' . $Min_lat
      . '" minlon="' . $Min_lon
      . '" maxlat="' . $Max_lat
      . '" maxlon="' . $Max_lon . '"/>';
    $HEAD =~ s|\r?\n?[ \t]*<bounds .*?/>||sg;                # remove any pre-existing bounds entry
    $HEAD =~ s|(\r?\n?[ \t]*</metadata>)|$indent$bounds$1|s; # add new bounds
}
#$speed_extension = '<xsd:element name="speed" type="xsd:decimal" minOccurs="0"><xsd:annotation><xsd:documentation>The current speed relative to the previous point, in meters per second</xsd:documentation></xsd:annotation></xsd:element>';
#$HEAD =~ s|(( )*</metadata>)|$2$2<extensions>$speed_extension</extensions>\n$1|s if $speed_extension ne ""; # add declaration for speed extension
$HEAD =~ s/\n?\n *(<trk>)/\n$1/g; # remove any double empty line (after metadata) before trk
$HEAD =~ s/ *$//;

sub wpt {
    my $j = $_[0];    # index of waypoint if >= 0
    my $i = $_[1];    # otherwise, index of trackpoint or < 0 for no wpt
    my $n = $_[2];    # text to be attributed to trackpoint
    return "" if $j < 0 && $i < 0;
    if ( $j < 0 ) {
        $n =~ s/\n/; /g;
        $n =~ s/; $//;
        $n =~ s/\s+/ /g;
    }
    my ( $lat, $lon, $tim ) = $j >= 0
      ? ( $WLAT[$j], $WLON[$j], $WTIM[$j] )
      : ( $LAT[$i], $LON[$i], $TIM[$i] );
    $tim = round_tim($tim);
    my $ele  = correct_ele( $j, $i );
    my $name_or_orig_text = $j >= 0 ? $WTXT[$j] : $n eq "" ? "" : "<name>[$n]</name>";
    return '<wpt lat="' . lat_string($lat) . '" ' . 'lon="' . lon_string($lon) . '">'
        . ( $ele eq "" ? "     " . (" " x $ele_prec_len ) . "      "
            : "<ele>" . ele_string($ele_prec_len, $ele) . "</ele>" )
        . ( $tim eq "" ? "      " . "                    " . "       "
            : "<time>$tim</time>" )
      . $name_or_orig_text . "</wpt>\n";
}

sub point {
    my $i = $_[0];
    my $n = $_[1];
    return "" if $i < 0;
    my $ele      = correct_ele( -1, $i );
    my $ele_val  = $ele     eq "" ? "NONE".(" " x max(0, $ele_prec_len - length("NONE"))) : ele_string($ele_prec_len, $ele);
    my $time_val = $TIM[$i] eq "" ? "NONE".(" " x max(0,      $tim_len - length("NONE"))) : round_tim($TIM[$i]);
    return "At lat,lon,ele = " . lat_string($LAT[$i]) . "," . lon_string($LON[$i]).",$ele_val time = $time_val: $n\n";
}

sub phase_text {
    my $i = $_[0] + 1;
    my $d = $i % 10;
    return ( " " x max( 0, length( $#PHASE_END_INDEX + 1 ) - length($i) ) )
        . $i .
        ( 11 <= $i && $i <= 13 ? "th"
        : $d == 1 ? "st"
        : $d == 2 ? "nd"
        : $d == 3 ? "rd"
        :           "th" )
      . " ";
}

my $wpts = "";
for ( my $j = 0 ; $j <= $#WTIM ; $j++ ) {
    $wpts .= wpt( $j, -1, "" );
}

my $phase_wpts   = "";
my $phase_points = "";
for ( my $i = 0 ; $i <= $#PHASE_END_INDEX ; $i++ ) {
    my $type = $PHASE_DIFF[$i] >= 0 ? "ascent " : "descent";
    my $Len = phase_text($i) . "$type   = " . ( sprintf DIF_PRECISION, $PHASE_DIFF[$i] ) . "  m;   "
      . "distance   =" . ( $PHASE_DIST[$i] / 1000 >= 10 ? "" : " " )
      . ( sprintf "%" . DIS_PRECISION, $PHASE_DIST[$i] / 1000 ) . " km";
    my $duration = $PHASE_DURATION[$i];
    $Len .= "; duration = " . timediff_string($duration) if $duration >= 0;
    my $max_spd_idx = $PHASE_MAXSPD_INDEX[$i];
    my $Spd = phase_text($i)
        . "max speed =  ".spd_full($SPD[$max_spd_idx])." km/h; "
        . "avg speed  = ".spd_full($PHASE_SPD[    $i])." km/h"
        if $max_spd_idx;
    my $max_rate_idx = $PHASE_MAXRATE_INDEX[$i];
    my $Rate = phase_text($i)
        . "max rate  =" . (sprintf RAT_PRECISION2, $RATE[$max_rate_idx]) . "  m/h; "
        . "avg rate   =" . (sprintf RAT_PRECISION, $PHASE_RATE[$i]     ) . "  m/h"
        if $max_rate_idx;
    $phase_wpts .= wpt(-1, $PHASE_END_INDEX    [$i], $Len );
    $phase_wpts .= wpt(-1, $PHASE_MAXSPD_INDEX [$i], $Spd ) if $max_spd_idx;
    $phase_wpts .= wpt(-1, $PHASE_MAXRATE_INDEX[$i], $Rate) if $max_rate_idx;
    $phase_points .= point($PHASE_END_INDEX    [$i], $Len );
    $phase_points .= point($PHASE_MAXSPD_INDEX [$i], $Spd ) if $max_spd_idx;
    $phase_points .= point($PHASE_MAXRATE_INDEX[$i], $Rate) if $max_rate_idx;
}

my $total_time   = timediff_string($max_sec - $min_sec);
my $part_wpts   = ""; # also used for overall statistics
my $part_points = ""; # also used for overall statistics
for (my $i = $all; $i <= (defined $part ? $part : $all); $i++) {
    my $Part = $i == $all ? "" : (defined $segs ? "segment" : "day")." ".(' ' x (length($part) - length($i)))."$i ";
    my $Min_ele      = sprintf ELE_PRECISION, correct_ele(-1, $MIN_ELE_INDEX[$i]); # may be "" if not defined
    my $Max_ele      = sprintf ELE_PRECISION, correct_ele(-1, $MAX_ELE_INDEX[$i]); # may be "" if not defined
    my $Max_spd      = defined $MAX_SPD_INDEX [$i] ? " ".spd_full($SPD[$MAX_SPD_INDEX [$i]]) : "";
    my $Max_gain_spd = defined $MAX_GAIN_INDEX[$i] ?     spd_str ($SPD[$MAX_GAIN_INDEX[$i]]) : "";
    my $Max_loss_spd = defined $MAX_LOSS_INDEX[$i] ?     spd_str ($SPD[$MAX_LOSS_INDEX[$i]]) : "";
    while (substr( $Max_gain_spd, 0, 1 ) eq " " &&
           substr( $Max_loss_spd, 0, 1 ) eq " " )
    {
        $Max_gain_spd = substr( $Max_gain_spd, 1 );
        $Max_loss_spd = substr( $Max_loss_spd, 1 );
    }

    my $Sum__ascent = sprintf DIF_PRECISION, $SUM__ASCENT[$i] // 0;
    my $Sum_descent = sprintf DIF_PRECISION, $SUM_DESCENT[$i] // 0;
    $Sum_descent =~ s/\+/-/ if $Sum_descent == 0;
    my $Max_gain = sprintf RAT_PRECISION, $MAX_GAIN[$i] // 0;
    my $Max_loss = sprintf RAT_PRECISION, $MAX_LOSS[$i] // 0;
    $Max_loss =~ s/\+/-/ if $Max_loss == 0;

    my $avg__ascent_rate = defined $TIME__ASCENT[$i] ? 3600 * $SUM__ASCENT[$i] / $TIME__ASCENT[$i] : 0;
    my $avg_descent_rate = defined $TIME_DESCENT[$i] ? 3600 * $SUM_DESCENT[$i] / $TIME_DESCENT[$i] : 0;
    #my $Avg_gain=sprintf RAT_PRECISION, $avg_gain;
    my $Avg__ascent_rate = sprintf RAT_PRECISION, $avg__ascent_rate;
    my $Avg_descent_rate = sprintf RAT_PRECISION, $avg_descent_rate;
    $Avg_descent_rate =~ s/\+/-/ if !$avg_descent_rate;

    my $max_spd_text  = $Part."max speed        = $Max_spd km/h";    # may use "" if not defined
    my $min_ele_text  = $Part."min altitude     = $Min_ele m";       # may use "" if not defined
    my $max_ele_text  = $Part."max altitude     = $Max_ele m";       # may use "" if not defined
    my $ascent_text   = $Part."total  ascent    = $Sum__ascent m; avg rate  = $Avg__ascent_rate m/h";
    my $descent_text  = $Part."total descent    = $Sum_descent m; avg rate  = $Avg_descent_rate m/h";
    my $max_gain_text = $Part."max  ascent rate = $Max_gain m/h at $Max_gain_spd km/h"; # may use "" if not defined
    my $max_loss_text = $Part."max descent rate = $Max_loss m/h at $Max_loss_spd km/h"; # may use "" if not defined
    my $part_end_text = $Part."end";
    my $last_gain_index = $LAST_GAIN_INDEX[$i] // $PART_END_INDEX[$i];
    my $last_loss_index = $LAST_LOSS_INDEX[$i] // $PART_END_INDEX[$i];
    $part_wpts = $part_wpts
        . wpt(-1, $MAX_SPD_INDEX  [$i], $max_spd_text )
        . wpt(-1, $MIN_ELE_INDEX  [$i], $min_ele_text )
        . wpt(-1, $MAX_ELE_INDEX  [$i], $max_ele_text )
        . wpt(-1, $last_gain_index    , $ascent_text  )
        . wpt(-1, $last_loss_index    , $descent_text )
        . wpt(-1, $MAX_GAIN_INDEX [$i], $max_gain_text)
        . wpt(-1, $MAX_LOSS_INDEX [$i], $max_loss_text)
        . ($i == $all ? ""
        : wpt(-1, $PART_END_INDEX [$i], $part_end_text));
    $part_points = $part_points
        . point($MAX_SPD_INDEX  [$i], $max_spd_text )
        . point($MIN_ELE_INDEX  [$i], $min_ele_text )
        . point($MAX_ELE_INDEX  [$i], $max_ele_text )
        . point($last_gain_index    , $ascent_text  )
        . point($last_loss_index    , $descent_text )
        . point($MAX_GAIN_INDEX [$i], $max_gain_text)
        . point($MAX_LOSS_INDEX [$i], $max_loss_text)
        . ($i == $all ? ""
        : point($PART_END_INDEX [$i], $part_end_text));
}

#average ".($avg_gain >= 0 ?  "ascent rate between lowest and highest"
#	                  : "descent rate between highest and lowest")." point = $Avg_gain m/h

my $final_text = "\n";
$final_text .= "total track length   = $Sum_dis km\n";
$final_text .= "total recording time = $total_time\n";
$final_text .= "total moving time    = $Sum_timediff_mov\n"  if $sum_timediff_mov;
$final_text .= "total biking energy  = $Sum_energy kJ\n"     if $sum_timediff_mov && $weight;
$final_text .= "average moving speed = $Avg_spd km/h\n"      if defined $Avg_spd;
my $end_text = $final_text;
$final_text .= plural($num_pruned_wpts,         "waypoint")    . " pruned\n" if $num_pruned_wpts;
$final_text .= plural($num_auto_wpts, "automatic waypoint")." pruned\n" if $num_auto_wpts;
$final_text .= plural($num_ignored_hdrs,    "track header")." ignored (apart from any included waypoints)\n" if $num_ignored_hdrs;
$final_text .= plural($num_pruned_cmts,              "cmt")." pruned\n" if $num_pruned_cmts;
$final_text .= plural($num_pruned_descs,     "description")." pruned\n" if $num_pruned_descs;
$final_text .= plural($num_pruned_links,            "link")." pruned\n" if $num_pruned_links;
$final_text .= plural($num_pruned_exts,        "extension")." pruned\n" if $num_pruned_exts;
$final_text .= points($num_ignored_before)." with time before ".epoch_to_str($begin_sec)." filtered out\n" if $begin_sec;
$final_text .= points($num_ignored_after )." with time after  ".epoch_to_str($end_sec  )." filtered out\n" if $end_sec;
$final_text .= points($num_elem_above    )." with $max_elem above $max_elem_limit"      ." filtered out\n" if $max_elem;
$final_text .= points($num_elem_below    )." with $min_elem below $min_elem_limit"      ." filtered out\n" if $min_elem;
$final_text .= points($num_removals_ele  )." ignored due to altitude less than "            .MIN_PLAUSIBLE_ELE                                      ." m\n" if $num_removals_ele;
$final_text .= points($num_removals_dir  )." ignored due to direction change out of range -".MAX_PLAUSIBLE_ANGLE_DIFF."°..+".MAX_PLAUSIBLE_ANGLE_DIFF."°\n" if $num_removals_dir;
$final_text .= points($num_removals_spd  )." ignored due to speed more than $MAX_PLAUSIBLE_SPEED km/h\n"          if $num_removals_spd;
$final_text .= points($num_removals_acc  )." ignored due to acceleration more than $MAX_PLAUSIBLE_ACCEL m/s/s\n"  if $num_removals_acc;
$final_text .= points($num_removals_dec  )." ignored due to deceleration more than $MAX_PLAUSIBLE_DECEL m/s/s\n"  if $num_removals_dec;
$final_text .= points($num_removals_gain )." ignored due to ascent rate more than $MAX_PLAUSIBLE_ELE_GAIN m/s\n"  if $num_removals_gain;
$final_text .= points($num_removals_loss )." ignored due to descent rate more than $MAX_PLAUSIBLE_ELE_LOSS m/s\n" if $num_removals_loss;
$final_text .= points($num_removals_diff )." ignored due to time difference less than $MIN_TIMEDIFF sec\n"        if $num_removals_diff;
$final_text .= plural($num_ext_above, "extension")." with name '$max_ext' and value above $max_ext_limit pruned\n" if $max_ext;
$final_text .= plural($num_ext_below, "extension")." with name '$min_ext' and value below $min_ext_limit pruned\n" if $min_ext;
$final_text .= ($smoothing ? "within each track, points that are at most ${ \SMOOTHING_MAX_GAP } seconds apart have been smoothened\n" : "" ); # not using sub points() here
$final_text .= "elevation ". ( !GEOID_ELE_CORRECTION ? "not corrected" :
                               "corrected by " . ( $found_corr ? "last retrieved" : "assumed" ) . " geoid height = $ele_corr m") . "\n";

$wpts .=
    wpt( -1, 0, "start" )
  . $part_wpts
  . $phase_wpts
  . wpt( -1, $#TIM, "end$end_text" );
$HEAD =~ s/(<trk>)/$wpts$1/s;    # prepend collected and computed waypoints to track

my $num_sanitized = $num_removals_ele + $num_removals_dir + $num_removals_spd + $num_removals_acc
    + $num_removals_dec + $num_removals_gain + $num_removals_loss + $num_removals_diff;
my $sanitized_text = $num_sanitized ? plural($num_sanitized, "sanitized trackpoint")." nor " : "";
my $stats = "GPXConv statistics (not including $sanitized_text"."periods between segments)\n"
  . point( 0,                "start" )
  . $part_points
  . $phase_points
  . point( $#TIM, "end" )
  . $Speed_deviation_text
  .($phases && $PHASES_REPORT_THRESHOLD > ELE_THRESHOLD ?
    "$ascent__phases_suppressed ascent phases and $descent_phases_suppressed descent phases " .
    "not reported because they are below the threshold of +/-$PHASES_REPORT_THRESHOLD m\n" : "")
    . substr( $final_text, 1 ) .
"GPXConv statistics end";

print_line(""); # empty line
info($stats);
$HEAD =~
  s|(<trk>\s*(<name>.*?</name>)?)|$1\n<cmt></cmt>|s # add preliminarily empty comment in track
  unless $HEAD =~ m/<trk>.*?<cmt>/s;                # if not already existing
$HEAD =~ s/(<trk>.*?<cmt>)/$1\n$stats\n/s;    # prepend stats to track comment

## fill long time gaps as far as needed with intermediate points by linear interpolation

for ( my $i = 0 ; INTERPOLATE_POINTS && $i <= $#TIM ; $i++ ) {
    ( $lat, $lon, $ele, $tim, $sec, $spd ) =
      ( $LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i], $SPD[$i] ); # needed also for print_trkpt
    ## debug "checking gap at point $i with lat=$lat lon=$lon ele=$ele tim=$tim sec=$sec spd=".($spd eq "" ? "" : spd_str($spd));
    my $diff_time = $i > 0 && $sec && $SEC[ $i - 1 ] ? int( $sec - $SEC[ $i - 1 ] ) : 0;
    if ( $diff_time > INTERPOLATION_MAX_GAP ) { # implies $i>0
        my $n_spans = int( $diff_time / INTERPOLATION_MAX_GAP ) +
          ( $diff_time % INTERPOLATION_MAX_GAP == 0 ? 0 : 1 );
        my $time_inc = $diff_time / $n_spans;    # 0 < $time_inc <= INTERPOLATION_MAX_GAP
        my $dis = distance_curr( $prev_lat, $prev_lon, $prev_ele );
        # re-calculating distance since coordinates may have been filled in or smoothened
        my $Dis      = sprintf "%4" . DIS_PRECISION, $dis / 1000;
        my $dis_inc  = $dis / $n_spans;
        my $N_points = $n_spans - 1;
        warn_trkpt("before", "  long time gap = ".timediff_string($diff_time)." over a distance of $Dis km; inserting ".points($N_points));
        # by interpolation every ". (sprintf SEC_PRECISION, $time_inc) ." seconds");
        my $seg = $SEG[$i]; # if gap was at segment start, have segment starts just before and after interpolated points
        my $start = $seg ? 0 : 1;
        my $n_end = $n_spans - ( $seg ? 0 : 1 );
        my $flags = $FLG[$i];

        # move info on previous ignored points over to first interpolated point
        my $ign = $IGN[$i];
        $IGN[$i] = 0;
        $DIS[$i] = $dis_inc;

# insert equidistant interpolated points,
# plus in case of new segment: an extra trkpt that equals the end of the previous segment and and one the equals the start of the next segment
        my $p = $i - 1;                 # previous index
        my $t = $seg ? 0 : $time_inc;
        for ( my $n = $start ; $n <= $n_end ; $n++ ) {
            splice @IGN, $i, 0, $n == $start ? $ign : 0;

# if $n == 0, here is a new segment start, with contents duplicated from segment end just before interpolation
# if $n == $n_spans, here is a new segment end, with contents duplicated from segment start just after interpolation
            splice @SEG, $i, 0, $n == 0;
            splice @FLG, $i, 0, $n == 0 ? $FLG[$p] | DUPLICATED_POINT
                : $n == $n_spans ? $flags | DUPLICATED_POINT : INTERPOLATED_POINT;
            splice @LAT, $i, 0, $LAT[$p] + ( $lat - $LAT[$p] ) * $t / $diff_time;
            splice @LON, $i, 0, $LON[$p] + ( $lon - $LON[$p] ) * $t / $diff_time;
            splice @ELE, $i, 0, (   $ELE[$p] ne "" && $ele ne ""
                ? $ELE[$p] + ( $ele - $ELE[$p] ) * $t / $diff_time : "" );
            splice @TIM, $i, 0, epoch_to_str( $SEC[$p] + $t );
            splice @SEC, $i, 0, $SEC[$p] + $t;
            splice @DIS, $i, 0, $dis_inc;
            splice @SPD, $i, 0, $spd;
            splice @CMT, $i, 0, "";
            splice @EXT, $i, 0, "";
            $i++;
            $t += $time_inc;
        }
    }
    ( $prev_lat, $prev_lon, $prev_ele, $prev_sec, $prev_spd ) =
      ( $lat, $lon, $ele, $sec, $spd );
}

## finally write output

print $out $HEAD;                     # includes <gpx> <trk> <trkseg>
for ( my $i = 0 ; $i <= $#TIM ; $i++ ) {
    ( $tim, $spd ) = ( round_tim($TIM[$i]), $SPD[$i] );
    print $out '<trkpt lat="' . lat_string($LAT[$i]) . '" lon="' . lon_string($LON[$i]) . '">';
    print $out "<ele>" . ele_string($ele_prec_len, correct_ele(-1, $i)) . "</ele>" if $ELE[$i] ne "";
    print $out "<time>$tim</time>" if $tim;

    my $cmt = $CMT[$i];
    if (!DISABLE_TRKPT_CMT && $IGN[$i]) {
        if ($cmt eq "") {
            $cmt = "<cmt>".plural($IGN[$i], "previous point")." ignored</cmt>";
        } else {
            my $old_count = ($cmt =~ s#(\d+) previous points? ignored(; )?##s ? $1 : 0); # remove any previous instance of our comment
            my $cmtstr = plural($old_count + $IGN[$i], "previous point")." ignored";
            $cmtstr .= "; " if $cmt ne "<cmt></cmt>";
            $cmt =~ s#(<cmt>)#$1$cmtstr#s;
        }
    }
    print $out $cmt if $cmt ne "";

    if (!DISABLE_TRKPT_SRC) {
        my $src = $FLG[$i] & INTERPOLATED_POINT ? "bridging time gap: interpolated point"
            : $FLG[$i] & DUPLICATED_POINT ? "bridging time gap: duplicated point "
            . ($i > 0 && ($FLG[$i - 1] & INTERPOLATED_POINT) != 0 ? "after" : "before") : "";
        # cannot place interpolation info in <trkseg> element because it cannot hold a comment
        $src .= ( $src eq "" ? "" : "; " ) . "interpolated altitude"  if $FLG[$i] & INTERPOLATED_ELE;
        $src .= ( $src eq "" ? "" : "; " ) . "interpolated time"      if $FLG[$i] & INTERPOLATED_TIM;
        $src .= ( $src eq "" ? "" : "; " ) . "substituted altitude"   if $FLG[$i] & SUBSTITUTED_ELE;
        $src .= ( $src eq "" ? "" : "; " ) . "substituted time"       if $FLG[$i] & SUBSTITUTED_TIM;
        $src .= ( $src eq "" ? "" : "; " ) . "computed speed"         if $FLG[$i] & COMPUTED_SPEED && INCLUDE_COMP_SPEED;
        print $out "<src>$src</src>" if !DISABLE_TRKPT_SRC && $src ne "";
    }
    if ( ( $FLG[$i] & INTERPOLATED_POINT ) != 0 && !DISABLE_TRKPT_FIX) {
        my $fix = "none";   # TODO check
        # was before: my $fix = $flags == 0 ? "": ( $FLG[$i] & ( INTERPOLATED_POINT | INTERPOLATED_TIM | SUBSTITUTED_TIM ) == 0 ? "2d" : "none" );
        print $out "<fix>$fix</fix>";
    }
    my $exts = $EXT[$i];
    if ($spd ne "" && (!($FLG[$i] & COMPUTED_SPEED) || INCLUDE_COMP_SPEED)) {
        my $spdstr = "<speed>".spd_string($spd)."</speed>";
        if ($exts eq "") {
            $exts = "<extensions>$spdstr</extensions>";
        } else {
            $exts =~ s#(<extensions>)#$1$spdstr#s;
        }
    }
    print $out $exts if $exts ne "";
    print $out "</trkpt>\n";
    print $out "</trkseg>\n<trkseg>\n" if $SEG[ $i + 1 ] && $i < $#TIM;
}
print $out "</trkseg>\n</trk>\n</gpx>\n";

close $out;   # does not hurt in case STDOUT
exit 0;
