#!/usr/bin/perl

################################################################################
# GPX converter: post-process routes and tracks typically produced by GPS loggers.
#
# Reads from file(s) given as argument (or STDIN) and writes to STDOUT or a file.
# Can combine multiple tracks and multiple files, using the header of the first track.
# Concatenates all given tracks (or routes) preserving segments, collecting waypoints.
# Reports missing data and ignores points containing non-plausible data.
# Optionally filters out points before or after given time limits.
# Optionally filters out points with an element value below or above given limits.
# Optionally prunes all extensions or elements with value below or above given limits.
# Optionally fills in elevation and time data by interpolation within segments.
# Optionally interpolates points in long gaps (by default, > 3600 seconds).
# Optionally corrects elevation and sanitizes and smoothens tracks.
# (Orthometric height = GPS ellipsoidal height - geoid height,
#  see http://www.unavco.org/edu_outreach/tutorial/geoidcorr.html)
# Produces statistics, optionally including ascent/descent rates of climbing phases.
# Optionally computes approx. total energy spent by biking along the resulting track.
# Prints information (if enabled), any warnings (if enabled), and errors to STDERR.
#
# Usage:
#   gpxconv <option(s) and infile(s)> [> <outfile>]
# Command-line options:
#   -swim, -walk, -cycle, -drive, -fly - type of recorded activity, default: drive
#   -smooth                      - smoothen tracks
#   -phases                      - analyze ascent/descent phases
#   -merge <file>                - complete gaps in infile(s) by data from given GPX file
#   -weight <value>              - compute biking energy for given weight in kg
#   -begin <time>                - ignore points before given time
#   -end <time>                  - ignore points after given time
#   -max <name> <limit>          - ignore points with element value above limit
#   -min <name> <limit>          - ignore points with element value below limit
#   -max_ext <name> <limit>      - prune extension elements with value above limit
#   -min_ext <name> <limit>      - prune extension elements with value below limit
#   -prune_wpts                  - remove waypoints
#   -prune_exts                  - remove track, waypoint, and trackpoint extensions
#   -nw                          - do not print warnings
#   -ni                          - do not print information
#   -o <outfile>                 - output the resulting track to <outfile>
# Other options can be set by changing values of the configuration variables.
# (c) 2012-2023 David von Oheimb - License: MIT - Version 2.7
################################################################################

use strict;
use warnings;

### configuration variables

my $activity = "-drive"; # default

# basic output control
use constant PRUNE_WPTS           => 0; # by default do not ignore waypoints
use constant PRUNE_AUTOMATIC_WPTS => 1; # ignore waypoints containing <name><!\[CDATA\[\d*\]\]></name>
use constant PRUNE_DESCS          => 0; # not not remove descriptions
use constant PRUNE_LINKS          => 0; # not not remove links
use constant PRUNE_EXTENSIONS     => 0; # by default do not remove extensions in waypoints and trackpoints
use constant INCLUDE_CALC_SPEED   => 1; # include speed extensions with calculated speed
use constant DISABLE_TRKPT_CMT    => 0; # do not add 'cmt' entries to trackpoints, e.g., comments on ignored points
use constant DISABLE_TRKPT_SRC    => 0; # do not add 'src' entries to trackpoints, e.g., on time gaps and interpolated data
use constant DISABLE_TRKPT_FIX    => 0; # do not add 'fix' entries to trackpoints, e.g., on points added by interpolation

# control filling in missing elevation and/or time
use constant CARRY_OVER_ELE    => 1; # copy elevation from last available value or begin of following segment
use constant CARRY_OVER_TIME   => 1; # copy time from end of previous segment or begin of following segment
use constant FILL_MISSING_ELE  => 1; # interpolate missing elevation
use constant FILL_MISSING_TIME => 1; # interpolate missing time

# analysis control
use constant MIN_SPEED_MOVING =>  1; # threshold for detecting movement (in km/h)
use constant ANALYZE_PHASES   =>  0; # by default do not analyze ascent/descent phases
use constant ELE_THRESHOLD    => 20; # threshold for detecting/accepting ascent or descent (in m);
                                     # should be larger than short-term elevation measurement error
my $PHASES_REPORT_THRESHOLD = ELE_THRESHOLD; # default

# smoothing control
use constant MERGE_FILL_GAP    => 60; # minimum gap duration in seconds to be filled by merging
use constant ENABLE_SMOOTHING  =>  0; # by default disable smoothing
use constant SMOOTHING_MAX_GAP => 60; # maximum number of seconds between trackpoint to be smoothened and its neighbors

# control interpolation of points over long (time) gaps
use constant INTERPOLATE_POINTS    =>    1; # enable inserting interpolated points in long time gaps
use constant INTERPOLATION_MAX_GAP => 3600; # in seconds between neighboring trackpoints before
                                            # interpolation should be used (3600 for both exiftool and TrailGuru)

# warning output control
use constant PRINT_WARNINGS      =>    1; # whether printing warnings is enabled by default
use constant PRINT_INFO          =>    1; # whether printing information is enabled by default
use constant WARNING_TPT_DIST    => 2000; # threshold for trackpoint distance warning (in meters)
use constant WARNING_WPT_DIST    =>  100; # threshold for waypoint distance warning (in meters)
use constant MAX_SPEED_DEVIATION =>    2; # threshold for speed measuring deviation warning (in km/h)

# pruning control
my $MIN_TIMEDIFF         ; # in seconds
my $MAX_SENSIBLE_SPEED   ; # maximal speed in km/h
my $MAX_SENSIBLE_ACCEL   ; # maximal acceleration m/s/s
my $MAX_SENSIBLE_ELE_GAIN; # maximal ascent rate in m/h
my $MAX_SENSIBLE_ELE_LOSS; # maximal descent rate in m/h
use constant MAX_SENSIBLE_ANGLE_DIFF =>  170; # maximal sensible turning angle above speed threshold
use constant MAX_SENSIBLE_ANGLE_SPD_THRESHOLD => 2; # speed threshold for maximal sensible turning angle: 7.2 km/h
use constant MIN_SENSIBLE_ELE        => -450; # minimal sensible elevation; actual values on Earth may be as low as -450 m at Dead Sea

# time correction control
use constant TIME_CORRECTION => 0; # number of seconds to add to time stamps in trkpt and wpt

# elevation correction control
use constant GEOID_ELE_CORRECTION   => 0; # whether to correct elevation wrt. geoid height retrieved online
use constant DEFAULT_ELE_CORRECTION => 0; # 47; # if used should be -(average geoid height)

### other constants

use constant METERS_PER_DEGREE_LAT => 10000 * 1000 / 90; # on Earth, by definition
use constant LAT_PRECISION =>   "%.5f"; # latitude resolution = 0.00001° (<= 1.11 meters)
use constant LON_PRECISION =>   "%.5f"; # longitude resolution = 0.00001° (<= 1.11 meters)
use constant ELE_PRECISION =>  "%5.0f"; # elevation resolution = 1 meters
use constant DIF_PRECISION => "%+5.0f"; # elevation difference resolution = 1 meters
use constant RAT_PRECISION => "%+5.0f"; # elevation ascent/descent rate resolution = 1 meters
use constant RAT_PRECISION2=> "%+6.0f"; # elevation ascent/descent rate resolution = 1 meters
use constant DIS_PRECISION =>    ".2f"; # distance resolution = 0.01 km
use constant SEC_PRECISION =>   "%.0f"; # seconds resolution = 1 second
use constant SPD_PRECISION =>   "%.0f"; # speed resolution = 1 km/h
use constant SPD_PRECISION2=>  "%4.0f"; # speed resolution = 1 km/h
use constant ACC_PRECISION =>   "%.1f"; # acceleration resolution = 0.1 m/s/s

# trkpt flags
use constant DUPLICATED_POINT   => 1 << 0;
use constant INTERPOLATED_POINT => 1 << 1;
use constant INTERPOLATED_ELE   => 1 << 2;
use constant INTERPOLATED_TIM   => 1 << 3;
use constant SUBSTITUTED_ELE    => 1 << 4;
use constant SUBSTITUTED_TIM    => 1 << 5;
use constant CALCULATED_SPEED   => 1 << 6;

# global option variables

my $merge;
my $num_ignored_hdrs   = 0;
my $begin_sec          = 0;
my $num_ignored_before = 0;
my $end_sec            = 0;
my $num_ignored_after  = 0;
my $max_elem;
my $max_elem_limit;
my $num_elem_above  = 0;
my $min_elem;
my $min_elem_limit;
my $num_elem_below  = 0;
my $max_ext;
my $max_ext_limit;
my $num_ext_above  = 0;
my $min_ext;
my $min_ext_limit;
my $num_ext_below  = 0;
my $ele_corr         = DEFAULT_ELE_CORRECTION;
my $smoothing        = ENABLE_SMOOTHING;
my $phases           = ANALYZE_PHASES;
my $weight;
my $prune_wpts       = PRUNE_WPTS;
my $num_pruned_wpts  = 0;
my $num_auto_wpts    = 0;
my $num_pruned_descs = 0;
my $num_pruned_links = 0;
my $prune_exts       = PRUNE_EXTENSIONS;
my $num_pruned_exts  = 0;
my $print_warnings   = PRINT_WARNINGS;
my $print_info       = PRINT_INFO;

# trackpoint data

my @IGN;
my @SEG;
my @FLG;
my @LAT;
my @LON;
my @ELE;
my @TIM;
my @SEC;
my @DIS;
my @SPD;
my @EXT;

# waypoint data

my @WLAT;
my @WLON;
my @WELE;
my @WTIM;
my @WSEC;
my @WTXT; # inner waypoint text after </time>
my @WSTR; # full original (but indented) waypoint text

# ascent/descent phase data

my @PHASE_DURATION;
my @PHASE_DIFF;
my @PHASE_DIST;
my @PHASE_SPD;
my @PHASE_RATE;
my @PHASE_MAXSPD_INDEX;
my @PHASE_MAXRATE_INDEX;
my @PHASE_END_INDEX;
my @DIST;
my @RATE;
my $ascent__phases_suppressed = 0;
my $descent_phases_suppressed = 0;

# global state variables

my $HEAD;
my $found_corr = 0;

my $lat, my $lon, my $ele, my $tim, my $sec, my $spd; # TODO make local
my $prev_lat, my $prev_lon, my $prev_ele, my $prev_tim, my $prev_sec, my $prev_spd, my $prev_rate, my $prev_acc; # TODO make local

my $min_lat, my $max_lat;
my $min_lon, my $max_lon;

my $min_tim = "", my $min_sec = 0;
my $max_sec = 0; # unused

my $max_spd  = 0; # also in case no data available
my $min_ele  = "";
my $max_ele  = "";
my $max_gain = 0; # also in case no data available
my $max_loss = 0; # also in case no data available

my $max_spd_index   = -1;
my $min_ele_index   = -1;
my $max_ele_index   = -1;
my $last_gain_index = -1;
my $last_loss_index = -1;
my $max_gain_index  = -1;
my $max_loss_index  = -1;


my $sum_dis         = 0;
my $avg_spd;
my $avg_timediff;
my $sum__ascent     = my $sum_descent  = 0;
my $time__ascent    = my $time_descent = 0;

my $sum_timediff_mov = 0;
my $sum_energy = 0;

my $out = *STDOUT;  # https://stackoverflow.com/questions/10478884/are-there-rules-which-tell-me-what-form-of-stdout-stderr-sdtin-i-have-to-choose

### various subprocedures

#http://www.perlmonks.org/?node_id=406883
#sub max { return $_[0] > $_[1] ? $_[0] : $_[1]; }
use List::Util qw[min max];

# http://stackoverflow.com/questions/178539/how-do-you-round-a-floating-point-number-in-perl
use Math::Round qw( nearest );
use Math::Trig qw( deg2rad pi2 );   # use Math::Trig 'great_circle_distance';
use File::Temp qw/ tempfile /;

# use DateTime::Format::ISO8601;
use Time::ParseDate ();

# use Time::PrintDate;
use Time::gmtime qw( gmtime );

use Scalar::Util qw( looks_like_number );

# str_to_epoch("1970-01-01T00:00:00Z") = 0
sub str_to_epoch {
    my $s = $_[0];

# return DateTime::Format::ISO8601->parse_datetime($s)->epoch();
# # not used due to Perl library bug on Mac OS X: "dyld: lazy symbol binding failed: Symbol not found: _Perl_newSVpvn_flags"
# # http://www.en8848.com.cn/Reilly%20Books/perl3/cookbook/ch03_08.htm
# use Time::Local;
# $date is "1998-06-03" (YYYY-MM-DD form).
# ($yyyy, $mm, $dd) = ($date =~ /(\d+)-(\d+)-(\d+)/;
# # calculate epoch seconds at midnight on that day in this timezone
# $epoch_seconds = timegm(0, 0, 0, $dd, $mm, $yyyy);
    $s =~ s/-/\//g;
    $s =~ s/(T\d+)Z/$1:00Z/; # workaround for the case that only hour is given
    $s =~ s/T/ /;
    $s =~ s/Z/+0000/;
    my $sec = Time::ParseDate::parsedate($s);
    $sec += $1 if $s =~ m/:\d\d(\.\d+)/;    # fractional seconds
    return $sec;
}

sub epoch_to_str {

# use DateTime; # not used due to Perl library bug on Mac OS X:
                # "dyld: lazy symbol binding failed: Symbol not found: _Perl_newSVpvn_flags"
#  my $dt = DateTime->from_epoch( epoch => $_[0] );
#  return $dt->ymd."T".$dt->hms."Z";
#use Date::Manip qw(ParseDate UnixDate);
#$date = ParseDate("18 Jan 1973, 3:45:50");
#  return UnixDate($_[0], "%Y-%m-%dT%H:%M:%SZ");
    my $tm = gmtime( $_[0] );
    return sprintf(
        "%04d-%02d-%02dT%02d:%02d:%02dZ",
        $tm->year + 1900,
        $tm->mon + 1,
        $tm->mday, $tm->hour, $tm->min, $tm->sec
    );
}

sub timediff_string {
    my $t = $_[0];
    my $s = $t % 60;
    $t = ( $t - $s ) / 60;
    my $m = $t % 60;
    $t = ( $t - $m ) / 60;
    return sprintf( "%2d:%02d:%02d h", $t, $m, $s );
}

sub ele_string {
    my $len = $_[0];
    my $ele = $_[1];
    return ( " " x max( 0, $len - length($ele) ) ) . $ele;
}

my $max_speed = 0;    # used only for spd_precision
sub spd_string {
    my $s = sprintf SPD_PRECISION, 3.6 * $_[0];
    return " " x max( 0, length( sprintf SPD_PRECISION, 3.6 * $max_speed ) - length($s) ) . $s;
}

my $lat_len = my $lon_len = my $ele_prec_len = my $ele_full_len = my $tim_len = 0;   # used only for formatting
sub parse_point {
    my $str = $_[0];

    my $lat, my $lon;
    #  $str =~ m#lat="(-?\d+\.?\d*)"\s*lon="(-?\d+\.?\d*)">\s*
    #  <ele>(-?\d+\.?\d*)</ele>\s*<time>(.*?T(\d\d):(\d\d):(\d\d)Z?)</time>#s
    if ( $str =~ s#lat=\s*"(-?[\.\d]+)"\s*lon=\s*"(-?[\.\d]+)"\s*>##s ) {
        $lat     = $1;
        $lon     = $2;
    } elsif ( $str =~ s#lon=\s*"(-?[\.\d]+)"\s*lat=\s*"(-?[\.\d]+)"\s*>##s ) {
        $lat     = $2;
        $lon     = $1;
    } else {
        abort("FATAL: Cannot parse point: $str\n");
    }
    $lat_len = max( $lat_len, length($lat) ); # sprintf LAT_PRECISION,
    $lon_len = max( $lon_len, length($lon) ); # sprintf LON_PRECISION,

    my $ele_str = my $ele = "";
    if ( $str =~ s#[ \t]*(<ele>\s*(-?[\.\d]+)\s*</ele>)\n?##s ) {
        $ele_str = $1;
        $ele = $2; # may be empty or 0
        $ele_prec_len = max( $ele_prec_len, length( int($ele) ) ); # sprintf ELE_PRECISION,
        $ele_full_len = max( $ele_full_len, length($ele) );
        $ele = "" if !$ele_str && !$sec; # for routes generated, e.g., using Google My Maps
    }

    my $tim = "", my $sec = 0;
    if ( $str =~ s#[ \t]*(<time>\s*([-:.T\dZ]+)\s*</time>)\n?##s ) {
        $tim = $2;
        $tim =~ s/\.0+Z/Z/;
        $tim_len = max( $tim_len, length($tim) );
        $sec = str_to_epoch($tim);    # or within a day: $7+60*($6+60*$5); # may be 0
        if ( $sec && TIME_CORRECTION ) {
            $sec += TIME_CORRECTION;
            $tim = epoch_to_str($sec);
        } else {
            $tim =~ s/(T\d\d)Z/$1:00Z/;
            $tim =~ s/(T\d\d:\d\d)Z/$1:00Z/;
        }
        $min_tim = $tim if $sec && $sec < $min_sec || $min_tim eq "";
        $min_sec = $sec if $sec && $sec < $min_sec || $min_sec == 0;
    }

    my $spd = "";
    if ( $str =~ m#<(\w:)?speed>(-?[\.\d ]+)</(\w:)?speed>#s ) {
        $spd       = $2 / 3.6;    # assuming speed is given in km/h
        $max_speed = $spd if $max_speed < $spd;
    }

    my $ext = "";
    if ( $str =~ s#[ \t]*(<extensions>(.*?</extensions>)+)\n?##s ) {
        if ( $prune_exts ) {
            ++$num_pruned_exts;
        } else {
            $ext = $1;
            $ext =~ s#\n##sg;
            $ext =~ s#>[ \t]+<#><#sg;
        }
    }

    my $rest = $str;
    $rest =~ s#\n##sg;
    $rest =~ s#>[ \t]+<#><#g;
    # clean up potential errors in input:
    $rest =~ s#<ele></ele>##;
    $rest =~ s#<time></time>##;

    my $ignore = 0;
    $ignore = 1 if
        ( $begin_sec && $sec && $sec < $begin_sec && ++$num_ignored_before ||
          $end_sec   && $sec && $end_sec < $sec   && ++$num_ignored_after  ||
          $max_elem  && $str =~ m#<$max_elem>\s*(-?[\.\d]+)\s*</$max_elem>#s && $1 > $max_elem_limit && ++$num_elem_above ||
          $min_elem  && $str =~ m#<$min_elem>\s*(-?[\.\d]+)\s*</$min_elem>#s && $1 < $min_elem_limit && ++$num_elem_below
        );
    $ext     =~ s#<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>##s if $max_ext &&
        $ext =~ m#<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>#s && $1 > $max_ext_limit && ++$num_ext_above;
    $ext     =~ s#<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>##s if $min_ext &&
        $ext =~ m#<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>#s && $1 < $min_ext_limit && ++$num_ext_below;
    $ext =~ s#<gpxtpx:TrackPointExtension></gpxtpx:TrackPointExtension>##sg;
    $ext =~ s#<extensions></extensions>##sg;

    return ( $lat, $lon, $ele, $tim, $sec, $spd, $rest, $ext, $ignore );
}

sub print_line { print STDERR "$_[0]\n"; }

sub warning {
    print_line("WARNING: $_[0]") if $print_warnings;
}

sub info {
    print_line("INFO   : $_[0]") if $print_info;
}

sub abort {
    print_line("$_[0]aborting");
    exit 1;
}

sub debug {
    print_line("### DEBUG: $_[0]");
}

sub info_trkpt  { info_trkpt_i( -1, $_[0], $_[1] ); }
sub warn_trkpt  { warn_trkpt_i( -1, $_[0], $_[1] ); }
sub print_trkpt { print_trkpt_i( -1, $_[0], $_[1] ); }

sub info_trkpt_i {
    print_trkpt_i( $_[0], "INFO   : $_[1]", $_[2] ) if $print_info;
}

sub warn_trkpt_i {
    print_trkpt_i( $_[0], "WARNING: $_[1]", $_[2] ) if $print_warnings;
}

sub print_trkpt_i {
    my $i    = $_[0];
    my $head = $_[1];    # may be empty
    my $tail = $_[2];    # may be empty
    my ( $lati, $long, $elev, $t ) =
      $i < 0
      ? ( $lat, $lon, $ele, $tim )
      : ( $LAT[$i], $LON[$i], $ELE[$i], $TIM[$i] );

    # using original precision here for better traceability
    # $lati = sprintf LAT_PRECISION, $lati;
    # $long = sprintf LON_PRECISION, $long;
    if ( $elev eq "" ) {
        $elev         = "NONE";
        $ele_prec_len = max( $ele_prec_len, length("NONE") );
        $ele_full_len = max( $ele_full_len, length("NONE") );
    }
    elsif ( $ele_full_len > $ele_prec_len ) {
        my $decimals = -1;
        $decimals = length($1) if $elev =~ m/\.(\d+)/;
        my $n_spaces = $ele_full_len - $ele_prec_len - $decimals - 1;
        $elev .= ' ' x $n_spaces if $n_spaces > 0;
    }
    my $time = $t ne "" ? $t : "NONE";
    print_line("$head "
      . "<trkpt"
      . ' lat="' . ( $lati . '"' . ( ' ' x max( 0, $lat_len - length($lati) ) ) )
      . ' lon="' . ( $long . '"' . ( ' ' x max( 0, $lon_len - length($long) ) ) )
      . " <ele>" . ele_string( $ele_full_len, $elev )
      . ( $t ne "NO" ? " <time>" . ( $time . ( " " x max( 0, $tim_len - length($time) ) ) ) : "" )
      . "$tail");
    abort("") if ( $head =~ "^FATAL:" );
}

sub ignoring_trkpt { ignoring_trkpt_i( -1, $_[0] , $_[1] ); }

sub ignoring_trkpt_i {
    my $Spd = $_[1];
    my $Spd_txt = $Spd ne "" ? " at speed = $Spd km/h" : "";
    warn_trkpt_i( $_[0], "ignoring", "$Spd_txt because $_[2]" );
}

my $i_last_removed = -1;
sub remove_trkpt {
    my $i = $_[0];
    warning("ignored more than one point in a row") if $i == $i_last_removed;
    $i_last_removed = $i;
    $IGN[ $i + 1 ] = $IGN[$i] + 1; # indicate that previous point has been ignored, in addition to any previous ignores
    $SEG[ $i + 1 ] = 1 if $SEG[$i] && $i < $#SEG;  # take over any segment start
    $DIS[ $i + 1 ] = distance($LAT[ $i + 1 ], $LON[ $i + 1 ], $ELE[ $i + 1 ],
                              $LAT[ $i - 1 ], $LON[ $i - 1 ], $ELE[ $i - 1 ]) if $i > 0;
    splice @IGN, $i, 1;
    splice @SEG, $i, 1;
    splice @FLG, $i, 1;
    splice @LAT, $i, 1;
    splice @LON, $i, 1;
    splice @ELE, $i, 1;
    splice @TIM, $i, 1;
    splice @SEC, $i, 1;
    splice @DIS, $i, 1;
    splice @SPD, $i, 1;
    splice @EXT, $i, 1;
}

sub distance {
    my $lat      = $_[0];
    my $lon      = $_[1];
    my $ele      = $_[2];
    my $prev_lat = $_[3];
    my $prev_lon = $_[4];
    my $prev_ele = $_[5];
    my $diff_lat = ( $lat - $prev_lat ) * METERS_PER_DEGREE_LAT;
    my $diff_lon = ( $lon - $prev_lon ) * METERS_PER_DEGREE_LAT *
      cos( deg2rad( ( $lat + $prev_lat ) / 2 ) );

#my$diff_lon = ($lon * cos(deg2rad($lat)) - $prev_lon * cos(deg2rad($prev_lat))) * METERS_PER_DEGREE_LAT;
    my $diff_ele = ( $ele ne "" && $prev_ele ne "" ? $ele - $prev_ele : 0 );

    # assuming no elevation change if no elevation available
    return sqrt( $diff_lat * $diff_lat + $diff_lon * $diff_lon + $diff_ele * $diff_ele );

#$distance = Math::Trig::great_circle_distance( #does not account for $diff_ele!
#						  deg2rad($lon)     , deg2rad(90 - $lat     ),
#						  deg2rad($prev_lon), deg2rad(90 - $prev_lat),
#						  40*1000*1000/pi/2); #http://perldoc.perl.org/Math/Trig.html
## debug "diff_lat=$diff_lat, diff_lon=$diff_lon, dis=$dis, distance=$distance";
}

sub distance_curr {    # of $lat, $lon, $ele
    return distance( $lat, $lon, $ele, $_[0], $_[1], $_[2] );
}

sub calc_diffs()
{ # of $lat, $lon, $ele relative to $prev_lat, $prev_lon, $prev_ele, so speed is relative to previous point
    my $dis = distance_curr( $prev_lat, $prev_lon, $prev_ele );
    # re-calculating distance since coordinates may have been filled in or smoothened
    my $diff_ele = ( $ele ne "" && $prev_ele ne "" ? $ele - $prev_ele : "" );

    #http://forums.howwhatwhy.com/showflat.php?Cat=&Board=scigen&Number=-208125
    my $timediff = ( $sec && $prev_sec ? $sec - $prev_sec : "" );
    my $rate = $diff_ele ne "" && $timediff ne ""
        ? ( $timediff > 0 ? 3600 * $diff_ele / $timediff : $prev_rate )
        : "";
    my $speed = ( $timediff ne ""
                  ? ( $timediff > 0 ? $dis / $timediff : $prev_spd )
                  : "" );
    my $acc = ( $speed ne "" && $prev_spd ne "" && $timediff ne ""
                ? ( $timediff > 0 ? ( $speed - $prev_spd ) / $timediff : $prev_acc )
                : "" );
    return ( $diff_ele, $timediff, $rate, $dis, $speed, $acc );
}

### parse command line
# TODO clean up use of ARGV

for (my $i = 0; $#ARGV - $i >= 0; ) {
    my $opt  = $ARGV[$i];
    my $arg1 = $ARGV[$i + 1];
    my $arg2 = $ARGV[$i + 2];

    # not checking for duplicate options
    if ($opt eq "-swim"  ||
        $opt eq "-walk"  ||
        $opt eq "-cycle" ||
        $opt eq "-drive" ||
        $opt eq "-fly" ) {
        $activity = $opt;
    }
    elsif ( $opt eq "-smooth" ) {
        $smoothing = 1;
    }
    elsif ( $opt eq "-phases" ) {
        $phases = 1;
    }
    elsif ( $opt eq "-merge" ) {
        abort("missing file argument for -$opt option\n") if $#ARGV - $i < 1;
        $merge = $arg1;
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ( $opt eq "-weight" ) {
        abort("missing value argument for -$opt option\n") if $#ARGV - $i < 1;
        abort("cannot parse value argument in '$opt $arg1'\n") unless looks_like_number($arg1);
        $weight = $arg1 + 0;
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ( $opt eq "-begin" || $opt eq "-end") {
        abort("missing time argument for $opt option\n") if $#ARGV - $i < 1;
        my $sec = str_to_epoch($arg1);
        abort("cannot parse time argument in '$opt $arg1'\n") unless $sec;
        $begin_sec = $sec if $opt eq "-begin";
        $end_sec   = $sec if $opt eq "-end";
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ( $opt eq "-max" || $opt eq "-min" ) {
        abort("missing element name argument for $opt option\n") if $#ARGV - $i < 1;
        abort("missing limit argument for -$opt option\n") if $#ARGV - $i < 2;
        abort("cannot parse limit argument in '$opt $arg1 $arg2'\n") unless looks_like_number($arg2);
        ( $max_elem, $max_elem_limit ) = ( $arg1, $arg2 + 0 ) if $opt eq "-max";;
        ( $min_elem, $min_elem_limit ) = ( $arg1, $arg2 + 0 ) if $opt eq "-min";;
        splice @ARGV, $i + 1, 2;    # remove from ARGV the option arguments
    }
    elsif ( $opt eq "-max_ext" || $opt eq "-min_ext" ) {
        abort("missing extension name argument for $opt option\n") if $#ARGV - $i < 1;
        abort("missing limit argument for -$opt option\n") if $#ARGV - $i < 2;
        abort("cannt parse limit argument in '$opt $arg1 $arg2'\n") unless looks_like_number($arg2);
        ( $max_ext, $max_ext_limit ) = ( $arg1, $arg2 + 0 ) if $opt eq "-max_ext";
        ( $min_ext, $min_ext_limit ) = ( $arg1, $arg2 + 0 ) if $opt eq "-min_ext";
        splice @ARGV, $i + 1, 2;    # remove from ARGV the option arguments
    }
    elsif ( $opt eq "-prune_wpts" ) {
        $prune_wpts = 1;
    }
    elsif ( $opt eq "-prune_exts" ) {
        $prune_exts = 1;
    }
    elsif ( $opt eq "-nw" ) {
        $print_warnings = 0;
    }
    elsif ( $opt eq "-ni" ) {
        $print_info = 0;
    }
    elsif ( $opt eq "-o" ) {

     # not checking for operlap with shell-level redirection of STDOUT using '>'
        abort("missing outfile argument for -o option\n") if $#ARGV - $i < 1;
        open( $out, "> $arg1" );
        splice @ARGV, $i + 1, 1;    # remove from ARGV the option argument
    }
    elsif ( $opt =~ m/^-/ ) {
        abort("unknown option: $opt\n");
    }
    else {
        $i++;
        next;                   # infile
    }
    splice @ARGV, $i, 1;        # remove from ARGV the option just handled
}
if ( $prune_exts ) {
    warning("-max_ext option has little effect since -prune_exts is given") if $max_ext;
    warning("-min_ext option has little effect since -prune_exts is given") if $min_ext;
}

if ( $activity eq "-swim" ) {
    $MIN_TIMEDIFF          = 4;
    $MAX_SENSIBLE_SPEED    = 7;
    $MAX_SENSIBLE_ACCEL    = 1;
    $MAX_SENSIBLE_ELE_GAIN = 1;
    $MAX_SENSIBLE_ELE_LOSS = 1;
}
elsif ( $activity eq "-walk" ) {
    $MIN_TIMEDIFF          = 4;
    $MAX_SENSIBLE_SPEED    = 20;
    $MAX_SENSIBLE_ACCEL    = 0.5;
    $MAX_SENSIBLE_ELE_GAIN = 1800;
    $MAX_SENSIBLE_ELE_LOSS = 3600;
}
elsif ( $activity eq "-cycle" ) {
    $MIN_TIMEDIFF          = 2;
    $MAX_SENSIBLE_SPEED    = 80;
    $MAX_SENSIBLE_ACCEL    = 4;
    $MAX_SENSIBLE_ELE_GAIN = 3000;
    $MAX_SENSIBLE_ELE_LOSS = 9000;
}
elsif ( $activity eq "-drive" ) { # default
    $MIN_TIMEDIFF          = 2;     # in seconds
    $MAX_SENSIBLE_SPEED    = 200;   # maximal speed in km/h
    $MAX_SENSIBLE_ACCEL    = 5;     # maximal acceleration m/s/s
    $MAX_SENSIBLE_ELE_GAIN = 20000; # maximal ascent rate in m/h
    $MAX_SENSIBLE_ELE_LOSS = 20000; # maximal descent rate in m/h
    $PHASES_REPORT_THRESHOLD = 100;
}
elsif ( $activity eq "-fly" ) {
    $MIN_TIMEDIFF          = 1;
    $MAX_SENSIBLE_SPEED    = 1200;
    $MAX_SENSIBLE_ACCEL    = 10;
    $MAX_SENSIBLE_ELE_GAIN = 30000;
    $MAX_SENSIBLE_ELE_LOSS = 50000;
    $PHASES_REPORT_THRESHOLD = 100;
} else {
    abort("unknown activity: $activity\naborting\n");
}

### main loops

## read all trackpoints from all track segments, optionally completing them

{ # TODO re-format
my $ele_miss_start  = 0; # TODO restrict scope
my $tim_miss_start  = 0; # TODO restrict scope
my $num_no_ele      = 0;
my $ele_gap_length  = 0;
my $num_no_time     = 0;
my $time_gap_length = 0;
my $prev_tim        = "";
my $prev_sec        = 0;
# $prev_avail_tim = "";
push @DIST, 0;
push @RATE, 0;

$/ = "<trkpt ";
if ($merge) {
    open M, $merge || abort("FATAL: Cannot open alternative GPX source file $merge: $.\n") if $#TIM < 0;
    <M>; # first item is before "<trktpt"
}
my ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $exts1) if $merge; # current end of gap to be merged
my ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $exts2) if $merge; # current trkpt from alternative input
sub next_trkpt2() {
    my $trkpt2;
    my $ignore2 = 1;
    while ($ignore2 && defined($trkpt2 = <M>)) {
        $trkpt2 =~ m#(.*?</trkpt>)#s;
        $trkpt2 = $1;
        ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, my $rest_unused2, $exts2, $ignore2) = parse_point("<trkpt $trkpt2") if $trkpt2;
    }
    my $Spd_ = defined($spd2) && $spd2 ne "" ? spd_string($spd2) : "";
    ## debug "read non-ignored point   from alt input with lat=$lat2 lon=$lon2 ele=$ele2 tim=$tim2 sec=$sec2 spd=$Spd_" if $trkpt2;
    return $trkpt2;
}
my $in_merge = 0; # if set, using trkpt from $merge
if ($merge && !next_trkpt2()) {
    abort("FATAL: no trkpt found in alternative input $merge\n");
    $merge = 0;
    close M;
}

# TODO before further complicating input handling, split file reading and parsing from any further processing
for ( my $state = 0,
      my $prev_avail_sec  = 0, my $prev_avail_ele  = "",
      my $ele_miss_length = 0, my $tim_miss_length = 0,
      my $i = 0;
      $in_merge ? (next_trkpt2() ? 1
                   : ($in_merge = -$in_merge, $in_merge != -2 && defined($_ = <>))) # EOF in $merge
                : (defined($_ = <>) ||
                   # EOF in infile(s)
                   ($merge && (info("infile(s) ended before alternative input"), 1)
                       ? ($in_merge = 2, 1) : 0));
    ) {
    ++$num_pruned_descs if PRUNE_DESCS && s#[ \t]*<desc>.+?</desc>\n?##sg;
    ++$num_pruned_links if PRUNE_LINKS && s#[ \t]*<link>.+?</link>\n?##sg;

    #collect waypoints, possibly in later infile(s) headers
    my $prev_wpt_time_stripped = "";
    while (!$in_merge && s#(<wpt .+?)(</wpt>)\n?##s)
    {
        my $wpt = $1 . $2;
        # workaround for OurxMaps partly duplicating waypoints of <type>Finishing Point</type> when manually starting new segment
        my $wpt_time_stripped = $wpt;
        $wpt_time_stripped =~ s#<time>.*</time>##;
        next if $wpt_time_stripped eq $prev_wpt_time_stripped;
        $prev_wpt_time_stripped = $wpt_time_stripped;

        ( $lat, $lon, $ele, $tim, my $sec, my $spd, my $rest, my $exts, my $ignore ) = parse_point($wpt); # collect some basic data even if pruned
        $rest =~ s#^<wpt[ \t]*##;
        $rest =~ s#</wpt>$##;
        ++$num_pruned_wpts if $prune_wpts;
        if (!$ignore && !$prune_wpts
            && !( PRUNE_AUTOMATIC_WPTS &&
                  $rest =~ m#<name><!\[CDATA\[\d*\]\]></name># && ++$num_auto_wpts )
            && !( $rest =~ m#\[(start|end.*?)\]# )
            && # waypoint with statistics added previously by this tool:
            !( $rest =~
m#\[((max|min)\s+(altitude|height)|max\s+speed|max\s+(climb|ascent|descent)\s+rate|total\s+(ascent|descent|gain|loss))\s+=\s+[+-]?[\d\.]+ k?m(\/h)?( at -?[\d\.]+ km/h|;\s+avg\s+rate\s+=\s+[+-]?[\d.]+ m/h)?\]# ))
        {
            push @WLAT, $lat;
            push @WLON, $lon;
            push @WELE, $ele;
            push @WTIM, $tim;
            push @WSEC, $sec;
            push @WTXT, $rest . $exts;
            $wpt =~ s/(^|\n)/\n  /sg;
            push @WSTR, $wpt;
        }
    }

    if ( $state == 0 ) {
        # processing first header (of first input file)

        if ( $prune_exts ) {
            ++$num_pruned_exts if s#<extensions>(.*?</extensions>)+\n?##sg;
        }
        # well, the following extension pruning may affect also header elements outside extensions
        s#[ \t]*<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>\n?##s if $max_ext
           && m#<$max_ext>\s*(-?[\.\d]+)\s*</$max_ext>#s && $1 > $max_ext_limit && ++$num_ext_above;
        s#[ \t]*<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>\n?##s if $min_ext
           && m#<$min_ext>\s*(-?[\.\d]+)\s*</$min_ext>#s && $1 < $min_ext_limit && ++$num_ext_below;

        if (s#\nGPXConv statistics (.*?)GPXConv statistics end\n##s)
        {    #remove any earlier statistics section
            my $stats = $1;
            warning("smoothing apparently has already been done on input")
              if $smoothing && $stats =~ m#smoothened#;
        }
        if (m#$/#s) {
            s#$/##s;    #remove trailing "<trkpt "
        }
        else {
            s#(^.*</type>).*#$1\n<trkseg>\n#s; #ignore rest of (header-only) file having no trkpt
        }
        s#[\s]+\n$#\n#s;    #remove any trailing spaces on line before
        s#[ \t]*(<trkseg>)#$1#s;
        $HEAD  = $_;
        $state = 1;         # expecting the very first trkpt
    }
    elsif (!$in_merge && m#(<gpx )#s) { # processing further track file
        ++$num_ignored_hdrs;
        if ( $smoothing && m#\nGPXConv statistics (.*?)smoothened(.*?)GPXConv statistics end\n# )
        {
            warning("smoothing apparently has already been done on input");
        }
        if ( $#TIM >= 0 ) { # typically, new file
            info_trkpt_i( $i - 1, "end of segment at", "" ) if $i > 0;
            info("further track, from file $ARGV");
        }
        $state = 2 if $state > 2;    # expecting new trkseg
    }
    else {
        # when $state == 1 || $state == 2: processing first trkpt in new trkseg
        # when $state == 3: processing further trkpt in trkseg
        my ($sec, $spd, $exts);
        if (!$in_merge) {
            m#(.*?</trkpt>)#s;
            my $trkpt = $1;
            ( $lat, $lon, $ele, $tim, $sec, $spd, my $rest_unused, $exts, my $ignore ) = parse_point("<trkpt $trkpt");
            next if $ignore;
            my $Spd_ = $spd ne "" ? spd_string($spd) : "";
            ## debug "read non-ignored point $i from infile(s) with lat=$lat lon=$lon ele=$ele tim=$tim sec=$sec spd=$Spd_; state = $state";
        } elsif ($merge) {
            ( $lat, $lon, $ele, $tim, $sec, $spd, $exts) =
                $in_merge == -1 ? ( $lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $exts1 ) # EOF in $merge during infile(s)
                                : ( $lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $exts2 );
        }
        my $diff_time = $sec && $prev_avail_sec ? $sec - $prev_avail_sec : 0;

        if ($merge) {
            if (!$in_merge) {
                if (($diff_time >= MERGE_FILL_GAP || $state == 1)
                        && $sec && $sec2 && $sec2 < $sec) { # $merge currently is before infiles(s)
                    $in_merge = 1;
                    if ($state == 1) {
                        info("alternative input starts before infile(s)");
                    } else { # certainly $i > 0
                        info_trkpt_i( $i - 1, "start using alternative input on ".timediff_string($diff_time)." gap after", "" );
                    }
                    ($lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $exts1)
                        = ($lat, $lon, $ele, $tim, $sec, $spd, $exts);
                    ($lat, $lon, $ele, $tim, $sec, $spd, $exts) =
                        ($lat2, $lon2, $ele2, $tim2, $sec2, $spd2, $exts2);
                } else {
                    while ($merge && $sec && $sec2 && $sec2 <= $sec) {
                        # advance $merge as far as possible to catch up with infile(s)
                        ($merge = 0, close M) unless next_trkpt2();
                    }
                }
            } else { # $in_merge != 0
                if ($sec && $in_merge != 2 && $sec1 && $sec1 <= $sec) { # $merge is not before infiles(s)
                    ( $lat, $lon, $ele, $tim, $sec, $spd, $exts) =
                        ( $lat1, $lon1, $ele1, $tim1, $sec1, $spd1, $exts1 );
                    $in_merge = 0;
                    info_trkpt_i( $i - 1, "end using alternative input at", "" );
                }
            }
            $diff_time = $sec && $prev_avail_sec ? $sec - $prev_avail_sec : 0; # re-calculate
        }
        if ( $state == 1 ) {
            info("initial track, from file $ARGV");
            info_trkpt( "first   segment at", "" );
        }
        else {
            print_trkpt("FATAL: before", " negative time difference (-".timediff_string(-$diff_time).")")
                if $diff_time < 0; # this implies $sec && $prev_sec
            if ($sec && $prev_sec && $diff_time == 0) {
                print_trkpt("FATAL: point before",
                            " has same time ($prev_tim) but different position ($prev_lat, $prev_lon)")
                    if $lat != $prev_lat || $lon != $prev_lon;
                print_trkpt("FATAL: point before",
                            " has same time ($prev_tim) but different elevation ($prev_ele m)")
                    if $ele != $prev_ele;
            }
        }

        my $flags = 0;
        my $dis = $state == 1 ? 0 : distance_curr( $prev_lat, $prev_lon, $prev_ele );
        if ( $state < 3 ) {    # the first point in trkseg
            if ( CARRY_OVER_ELE && $ele ne "" ) {
                if ( $i > 0 && $ELE[ $i - 1 ] eq "" ) {
                    $FLG[ $i - 1 ] |= SUBSTITUTED_ELE;
                    $ELE[ $i - 1 ] = $ele;
                    warn_trkpt_i($i - 1, "at segment end    ",
                                 " no elevation was given; using value from begin of next segment");
                }
            }
            elsif ($ele_miss_start) {
                warn_trkpt_i($i - 1, "             up to",
                             " was unable to interpolate missing elevation within segment");
                $ele_miss_start = 0;
            }
            if ( CARRY_OVER_TIME && $tim ne "" ) {
                if ( $i > 0 && $TIM[ $i - 1 ] eq "" ) {
                    $FLG[ $i - 1 ] |= SUBSTITUTED_TIM;
                    $TIM[ $i - 1 ] = $tim;
                    $SEC[ $i - 1 ] = $sec;
                    warn_trkpt_i($i - 1, "at segment end    ",
                                 " no time      was given; using value from begin of next segment");
                }
            }
            elsif ($tim_miss_start) {
                warn_trkpt_i($i - 1, "             up to",
                    " was unable to interpolate missing time within segment");
                $tim_miss_start = 0;
            }
            if ( $state == 2 ) {
                my $Dis = sprintf "%4" . DIS_PRECISION, $dis / 1000;
                my $Gap = timediff_string($diff_time);
                $Gap =~ s/^\s+//;
                info_trkpt( "further segment at", " after a gap of $Gap and $Dis km" );
            }

            my $resolution;
            if ( $ele eq "" ) {
                if ( $prev_avail_ele eq "" ) {    # $prev_ele
                    $resolution = " and no previous value available";
                }
                elsif (CARRY_OVER_ELE) {
                    $ele = $prev_avail_ele;  # $prev_ele; # will become $ELE[$i]
                    $resolution = "; using previous available value";
                    $flags |= SUBSTITUTED_ELE;
                }
                else {
                    $resolution = " and carrying over previous available value is disabled";
                }
                warn_trkpt( "at segment start  ",
                    " no elevation ".($resolution =~ / using / ? "was " : "")."given$resolution" );
            }
            if ( $tim eq "" ) {
                if ( $prev_tim eq "" ) {
                    $resolution = " and no previous value available";
                }
                elsif (CARRY_OVER_TIME) {
                    $tim = $prev_tim;    # will become $TIM[$i]
                    $sec = $prev_sec;    # will become $SEC[$i]
                    $flags |= SUBSTITUTED_TIM;
                    $resolution = "; using previous value";
                }
                else {
                    $resolution = " and carrying over previous value is disabled";
                }
                warn_trkpt( "at segment start  ",
                    " no time      ".($resolution =~ / using / ? "was " : "")."given$resolution" );
            }
        }
        else {    # state == 3, further (i.e., not the first) point in trkseg
            if ( $ele eq "" && FILL_MISSING_ELE && ( $ele_miss_start || $prev_ele ne "" ) )
            {     # $prev_avail_ele
                ( $ele_miss_start, $ele_miss_length ) = ( $i, 0 )
                  if !$ele_miss_start;    # $i is > 0
                $ele_miss_length += $dis;
            }
            if ( !$sec && $prev_sec && $spd ne "" && $spd > 0 ) {
                my $calc_sec = $prev_sec + $dis / $spd;
                # substitute time using recorded speed and distance from previous point
                $tim = epoch_to_str($calc_sec);    # will become $TIM[$i]
                $sec = $calc_sec;                  # will become $SEC[$i]
                warn_trkpt("at                ", " no time      given, " .
                           " filled in using time difference calculated by distance / speed");
                $FLG[$i] |= SUBSTITUTED_TIM;
            }
            if ( $tim eq "" && FILL_MISSING_TIME && ( $tim_miss_start || $prev_tim ne "" ) )
            {    # not $prev_avail_tim, which may be an earlier time
                ( $tim_miss_start, $tim_miss_length ) = ( $i, 0 ) if !$tim_miss_start; # $i is > 0
                $tim_miss_length += $dis;
            }
        }
        if ( $ele ne "" && $ele_miss_start ) {    # fill in missing elevation
            my $i_end = $i;
            if ( $state < 3 )
            {    # have been carrying over ele to end of last section
                $i_end--;
            }
            else {   # state == 3, further (i.e., not the first) point in trkseg
                $ele_miss_length += $dis;
            }
            my $ele_curr = $ELE[ $ele_miss_start - 1 ];    # $prev_avail_ele
            my $ele_gradient =
              $ele_miss_length > 0
              ? ( $ele - $ele_curr ) / $ele_miss_length
              : 0;
            for ( my $j = $ele_miss_start ; $j < $i_end ; $j++ ) {
                $ele_curr += $DIS[$j] * $ele_gradient;
                $ELE[$j] = sprintf "%.0f", $ele_curr;

# not changing $ele nor $prev_ele such that below time interpolation is not affected
                $FLG[$j] |= INTERPOLATED_ELE;
                ## debug "interpolating missing ele at point $j with ele=$ELE[$j]";
            }
            $ele_miss_start = 0;
        }
        if ( $tim ne "" && $tim_miss_start ) {    # fill in missing time
            my $i_end = $i;
            if ( $state < 3 )
            {    # have been carrying over time to end of last section
                $i_end--;
            }
            else {   # state == 3, further (i.e., not the first) point in trkseg
                $tim_miss_length += $dis;
            }
            my $sec_curr =
              $SEC[ $tim_miss_start - 1 ];    # corresponds to $prev_tim
            my $sec_gradient =
              $tim_miss_length > 0
              ? ( $sec - $sec_curr ) / $tim_miss_length
              : 0;
            ## debug("over ".($tim_miss_length/1000)." km, secdiff = ".($sec - $sec_curr));
            for ( my $j = $tim_miss_start ; $j < $i_end ; $j++ ) {
                $sec_curr += $DIS[$j] * $sec_gradient;
                $SEC[$j] = $sec_curr;
                $TIM[$j] = epoch_to_str($sec_curr);
                $FLG[$j] |= INTERPOLATED_TIM;
                ## debug "interpolating missing time at point $j with time=$TIM[$j]";
            }
            $tim_miss_start = 0;
        }

        push @IGN, 0;
        push @SEG, $state < 3;
        push @FLG, $flags;
        push @LAT, $lat;
        push @LON, $lon;
        push @ELE, $ele;
        push @TIM, $tim;
        push @SEC, $sec;
        push @DIS, $dis;
        push @SPD, $spd;         # as recorded, else ""
        push @EXT, $exts;

        # detect and report missing time and/or elevation
        my $ele_solution  = "cannot calculate ascent/descent";
        $ele_solution  = "trying to interpolate elevation" if $ele_miss_start;
        my $time_solution = "cannot calculate speed and acceleration";
        $time_solution = "trying to interpolate time" if $tim_miss_start;
        if ( $ele eq "" ) {
            $num_no_ele++;
            $ele_gap_length += $dis;
            warn_trkpt( "no elevation at   ", "; $ele_solution" )
              if $num_no_ele == 1;
        }
        elsif ($num_no_ele) {
            my $Len = sprintf "%4" . DIS_PRECISION, $ele_gap_length / 1000;
            warn_trkpt_i($i - 1, "no elevation up to", " for "
                  . $num_no_ele . " point" . ( $num_no_ele > 1 ? "s" : "" )
                  . " over a distance of $Len km"
            );
            $num_no_ele     = 0;
            $ele_gap_length = 0;
        }
        if ( !$sec ) {
            $num_no_time++;
            $time_gap_length += $dis;
            warn_trkpt( "no time      at   ", "; $time_solution" ) if $num_no_time == 1;
        }
        elsif ($num_no_time) {
            my $Len = sprintf "%4" . DIS_PRECISION, $time_gap_length / 1000;
            warn_trkpt_i($i - 1, "no time      up to", " for "
                  . $num_no_time . " point" . ( $num_no_time > 1 ? "s" : "" )
                  . " over a distance of $Len km"
            );
            $num_no_time     = 0;
            $time_gap_length = 0;
        }
        my $sec_str = $sec ? epoch_to_str($sec) : "";
        abort("FATAL: inconsistent time data for trkpt with index $i: tim=$tim != $sec_str (=$sec)\n") if $sec_str ne $tim;

        # will go wrong if previous trkpt gets ignored: $ELE[$#ELE] = $ELE[$#ELE-1] if $ele eq "" && !$SEG[$#ELE]; # implies $#ELE > 0
        $i++;
        ( $prev_lat, $prev_lon, $prev_ele, $prev_tim, $prev_sec, $prev_spd ) =
          ( $lat, $lon, $ele, $tim, $sec, $spd );
        $prev_avail_ele = $ele if $ele ne "";

     # Commenting out $prev_avail_tim as it is currently unused, but referred to
     # in another comment
     # $prev_avail_tim = $tim if $tim ne "";

        $prev_avail_sec = $sec if $sec; # enables checking negative time difference also across missing time entries
        $state = 3; # ready to process further trkpt(s) in trkseg (or new trkseg or new track)
    }
    if (!$in_merge && m#</trkseg>.*<trkseg>#s) {
        info_trkpt_i( $i - 1, "end of  segment at", "" ) if $i > 0;
        $state = 2; # starting new trkseg
        # reset intra-segment values
        $prev_spd = "";
    }
    if ($i > 0 && !$in_merge && m#<trk>#) { # further track
        ++$num_ignored_hdrs;
        info("further track, again from file $ARGV") unless m#<gpx #s;
    }
    if ($in_merge < 0) {
        $in_merge = $merge = 0;
        close M;
    }
}
my $Len = sprintf "%4" . DIS_PRECISION, $ele_gap_length / 1000; # TODO restrict scope
warn_trkpt_i($#TIM, "no elevation up to",
             " for " . $num_no_ele . " points over a distance of $Len km") if $num_no_ele > 1;
$Len = sprintf "%4" . DIS_PRECISION, $time_gap_length / 1000;
warn_trkpt_i($#TIM, "no time      up to",
             " for " . $num_no_time . " points over a distance of $Len km") if $num_no_time > 1;
info_trkpt("last   segment end", "") if $#TIM >= 0;
warn_trkpt("                at",
           " was unable to interpolate missing elevation by end of last segment") if $ele_miss_start;
warn_trkpt("                at",
           " was unable to interpolate missing time by end of last segment") if $tim_miss_start;
} # end TODO re-format

## sanitize trackpoints

{ # TODO re-format
my $sum_timediff_mov0 = 0;
my $num_pts_mov       = 0;
my $timediff_before;
my $timediff = "";
my $spd_before;
$spd = "";
for ( my $acc, my $rate,
      my $i = 0 ; $i <= $#TIM ; $i++ ) {
    $timediff_before = $timediff;
    $spd_before = $spd;
    ( $lat, $lon, $ele, $tim, $sec, $spd ) =
      ( $LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i], $SPD[ $i + 0 ] );

    ## debug"sanitizing point $i with lat=$lat lon=$lon ele='$ele' tim='$tim' sec=$sec spd='$spd'";
    my $ignore = 0;

    if ( $ele ne "" && $ele < MIN_SENSIBLE_ELE ) {
        $ignore = 1;
        ignoring_trkpt( "", "elevation is less than " . MIN_SENSIBLE_ELE );
    }

    if ( $SEG[$i] ) { # at segment start
        $acc = $rate = ""; # keep any recorded speed, but reset acceleration and climb/descent rate
    }
    else {
        my $theta_diff = 0;
        my $timediff2 = $timediff_before eq "" || $timediff eq "" ? 0 : $timediff_before + $timediff;
        my $spd2 = $timediff2 <= 0 || $spd_before eq "" || $spd eq "" ? "" :
            ($spd_before * $timediff_before + $spd * $timediff) / $timediff2;
        if ($i >= 2 && !$SEG[ $i - 1 ] # previous point not at segment start
            && $spd2 ne "" && $spd2 > MAX_SENSIBLE_ANGLE_SPD_THRESHOLD) # average speed between last two points
        {
            # turning angle calculation for spike detection
            my $prev_lon_diff = nearest( .00001, $prev_lon ) - nearest( .00001, $LON[ $i - 2 ] );
            my $prev_lat_diff = nearest( .00001, $prev_lat ) - nearest( .00001, $LAT[ $i - 2 ] );
            my $curr_lon_diff = nearest( .00001, $lon ) - nearest( .00001, $prev_lon );
            my $curr_lat_diff = nearest( .00001, $lat ) - nearest( .00001, $prev_lat );
            if ( $prev_lon_diff && $prev_lat_diff && $curr_lon_diff && $curr_lat_diff )
            {
                my $theta1 = atan2( $prev_lon_diff, $prev_lat_diff ) * 360 / pi2;
                my $theta2 = atan2( $curr_lon_diff, $curr_lat_diff ) * 360 / pi2;
                $theta_diff = ( $theta2 - $theta1 ) % 360;
                $theta_diff -= 360 if $theta_diff >= 180;
            }
        }
        my $Theta_diff = sprintf "%+.0f", $theta_diff;
        ( my $diff_ele, $timediff, $rate, my $dis, my $calc_spd, $acc ) = calc_diffs();
        $spd = $calc_spd if $spd eq "";
        my $Spd      = $spd ne "" ? spd_string("$spd") : "";
        my $Spd_txt  = $spd ne "" ? " at speed = $Spd km/h" : "";
        my $Dis      = sprintf "%4" . DIS_PRECISION, $dis / 1000;
        my $Warn_dis = sprintf "%" . DIS_PRECISION,  WARNING_TPT_DIST / 1000;
        my $Rate     = $rate ne "" ? sprintf RAT_PRECISION, $rate : "";
        my $Acc      = $acc ne "" ? sprintf ACC_PRECISION, $acc : "";
        warn_trkpt("before  ", "$Spd_txt distance between points = $Dis km (more than $Warn_dis)")
            if $dis > WARNING_TPT_DIST;

        if ( !$ignore && $spd ne "" && $SPD[$i] ne "" )
        {    # $ignore means: last trkpt has been ignored
            my $spd_diff = 3.6 * abs( $calc_spd - $spd );
            warn_trkpt("before  ",
                       "$Spd_txt calculated speed is " . spd_string($calc_spd) . " km/h " .
                       "deviation is " . spd_string( $spd_diff / 3.6 ) . " km/h" .
                       " (more than " . ( MAX_SPEED_DEVIATION - 1 ) . ")") if $spd_diff > MAX_SPEED_DEVIATION;
        }

        $ignore = 1; # the current point
        if ( MAX_SENSIBLE_ANGLE_DIFF < abs($theta_diff) ) {
            $ignore = -1; # the point before
            ignoring_trkpt_i( $i - 1, spd_string($spd2), "direction change = $Theta_diff° ("
                  . ( $theta_diff >= 0 ? "more than  " : "less than -" ) . MAX_SENSIBLE_ANGLE_DIFF . "°)" );
        }
        elsif ( $spd ne "" && $Spd > $MAX_SENSIBLE_SPEED ) {
            ignoring_trkpt( $Spd, "speed = $Spd km/h more than " . $MAX_SENSIBLE_SPEED);
        }
        elsif ($acc ne "" && abs($acc) > $MAX_SENSIBLE_ACCEL
            && ( $FLG[ $i - 1 ] & INTERPOLATED_TIM ) == ( $FLG[$i] & INTERPOLATED_TIM ) ) {
            ignoring_trkpt( $Spd, "acceleration = $Acc m/s/s ("
                  . ( $acc >= 0 ? "more than " : "less than -" ) . $MAX_SENSIBLE_ACCEL . ")" );
        }
        elsif ( $rate ne "" && $Rate > $MAX_SENSIBLE_ELE_GAIN ) {
            ignoring_trkpt( $Spd, " ascent rate = $Rate m/h (more than  " . $MAX_SENSIBLE_ELE_GAIN . ")" );
        }
        elsif ( $rate ne "" && $Rate < -$MAX_SENSIBLE_ELE_LOSS ) {
            ignoring_trkpt( $Spd, "descent rate = $Rate m/h (less than -" . $MAX_SENSIBLE_ELE_LOSS . ")" );
        }
        elsif ( $timediff ne "" && $timediff < $MIN_TIMEDIFF
                && ( $FLG[ $i - 1 ] & INTERPOLATED_TIM ) == ( $FLG[$i] & INTERPOLATED_TIM ) )
        {
            my $inter = ( $FLG[$i] & INTERPOLATED_TIM ) ? "interpolated " : "";
            ignoring_trkpt( $Spd, $inter . "time difference = " . int($timediff)
                  . " sec (less than " . $MIN_TIMEDIFF . ") over a distance of $Dis km" ) if $timediff > 1.001;
        }
        else {
            $ignore = 0;
            if ( $spd ne "" && 3.6 * $spd >= MIN_SPEED_MOVING ) # implies $timediff ne ""
            {
                $sum_timediff_mov0 += $timediff; # used for smoothing
                $num_pts_mov++;                  # used for smoothing
            }
        }
    }
    if ($ignore != 0) {
        remove_trkpt( $ignore == -1 ? --$i : $i-- );
        # will re-calculate speed etc. relative to same previous point as before
    }
    else {
        ( $prev_lat, $prev_lon, $prev_ele,  $prev_tim,
          $prev_sec, $prev_spd, $prev_rate, $prev_acc )
            = ( $lat, $lon, $ele, $tim, $sec, $spd, $rate, $acc );
    }
}
$avg_timediff = $num_pts_mov ? $sum_timediff_mov0 / $num_pts_mov : 0; # used for smoothing
# $sum_timediff_mov will be re-calculated thereafter, since points may have been ignored or smoothened
} # end TODO re-format

abort("FATAL: No trackpoint (possibly after ignoring some)\n") if $#TIM < 0;

## check waypoints

for ( my $j = 0 ; $j <= $#WSEC ; $j++ ) {
    $sec = $WSEC[$j];
    unless ($sec) {
        warning("waypoint '$WSTR[$j]\n' does not have time information; skipping proximity check");
        next;
    }
    if ( $j > 0 && $WSEC[ $j - 1 ] && $sec - $WSEC[ $j - 1 ] < 0 ) {
        warning("waypoint '$WSTR[$j]\n' is before previous waypoint: $WSTR[$j-1]");
    }
    if ( $#TIM < 0 ) { # can not happen due to above check
        warning("no trackpoint found for checking waypoints");
        last;
    }
    else {
        # find trackpoint at or just after wpt
        my $i2 = 0; # would be more efficient to do this just before the wpt loop, but then cannot deal with wpts not in time order
        while ( $i2 <= $#TIM && $SEC[$i2] < $sec && ( $i2 == 0 || $SEC[ $i2 - 1 ] != 0 ) )
        {
            $i2++;
        }
        my $i1 = ( $i2 > 0 ? $i2 - 1 : $i2 )
          ; # trackpoint just before, if any, else same as the one just determined
        next
          if $LAT[$i1] == $WLAT[$j]
          && $LON[$i1] == $WLON[$j]
          && $ELE[$i1] == $WELE[$j];    # late finishing point
        next
          if $LAT[$i2] == $WLAT[$j]
          && $LON[$i2] == $WLON[$j]
          && $ELE[$i2] == $WELE[$j];    # early starting point
        if ( $i2 > $#TIM ) {
            warning("no trackpoint found at same time or later than waypoint '$WSTR[$j]\n';" .
                    " will extrapolate distance from the one before"
            );
        }
        my $linear_factor = ( $SEC[$i2] - $SEC[$i1] <= 0 ? 0
                              : ( $sec - $SEC[$i1] ) / ( $SEC[$i2] - $SEC[$i1] ) );
        $lat = $LAT[$i1] + ( $LAT[$i2] - $LAT[$i1] ) * $linear_factor;
        $lon = $LON[$i1] + ( $LON[$i2] - $LON[$i1] ) * $linear_factor;
        my $ele2 = $ELE[$i2] eq "" ? ( $WELE[$j] eq "" ? $ELE[$i1] : $WELE[$j] ) : $ELE[$i2];
        my $ele1 = $ELE[$i1] eq "" ? $ele2 : $ELE[$i1];
        $ele  = $ele1 eq "" || $ele2 eq "" ? "" : $ele1 + ( $ele2 - $ele1 ) * $linear_factor;
        my $dis = distance_curr( $WLAT[$j], $WLON[$j], $WELE[$j] );
        $tim = "NO"; # do not print time for interpolated point, since done already for wpt
        my $Dis = sprintf "%.0f", $dis;
        warn_trkpt("according to its time information, waypoint '$WSTR[$j]\n' appears not close to track "
              . "(interpolated distance = $Dis m > " . WARNING_WPT_DIST . "); "
              . "it should be approximately at", "")
          if $dis > WARNING_WPT_DIST;
    }
}

## smoothen trackpoints

# smoothen each point, by weightened average with (smoothened) previous point and (original) next point
sub average {

    sub weight {
        #   my $d = 1.5*$avg_timediff; # max dist of influence
        #   return max(0, ($d-$_[0])/$d);
        return 1 / ( 1 + $_[0] / $avg_timediff );
    }
    my $x1 = $_[0];
    my $x  = $_[1];
    my $x2 = $_[2];
    my $diff_time1 = $_[3];
    my $diff_time2 = $_[4];

    #return $x;
    return ( $x1 * weight($diff_time1) + $x + $x2 * weight($diff_time2) ) /
      ( weight($diff_time1) + 1 + weight($diff_time2) );
}

if ( $smoothing ) {
    for ( my $i = 0 ; $i <= $#TIM ; $i++ ) {
        ( $tim, $sec ) = ( $TIM[$i], $SEC[$i] );
        if ( 0 < $i && $i < $#SEC && $SEC[ $i - 1 ]
             && $sec && $SEC[ $i + 1 ] && !$SEG[$i] && !$SEG[ $i + 1 ] )
        {
            my $diff_time1 = $sec - $SEC[ $i - 1 ];
            my $diff_time2 = $SEC[ $i + 1 ] - $sec;
            if ( max( $diff_time1, $diff_time2 ) <= SMOOTHING_MAX_GAP ) {
                $LAT[$i] = average( $prev_lat * 0 + $LAT[ $i - 1 ], $LAT[$i], $LAT[ $i + 1 ] , $diff_time1 , $diff_time2 );
                $LON[$i] = average( $prev_lon * 0 + $LON[ $i - 1 ], $LON[$i], $LON[ $i + 1 ] , $diff_time1 , $diff_time2 );
                $ELE[$i] = average( $prev_ele * 0 + $ELE[ $i - 1 ], $ELE[$i], $ELE[ $i + 1 ] , $diff_time1 , $diff_time2 )
                    if $prev_ele ne ""  && $ELE[ $i - 1 ] ne "" && $ELE[$i] ne "" && $ELE[ $i + 1 ] ne "";
                # speed will be re-calculated later
                # individiual points are not marked as smoothed; this is done globally
            }
        }
        ( $prev_lat, $prev_lon, $prev_ele ) = ( $LAT[$i], $LON[$i], $ELE[$i] );
    }
}

## perform analysis/statistics

my $energy_missing_ele = 0;
my $energy_missing_spd = 0;
sub energy { # calculate energy difference between trackpoints  # TODO simplify provisioning of parameters using index
    my $t  = $_[0];                # start date and time
    my $t0 = $_[1];                # start time relative to begin of track in s
    my $t1 = $_[2];                # end   time relative to begin of track in s
    my $dt = $t1 - $t0;            # duration in s
    my $d  = $_[3];                # 3-dimensional distance in m
    my $h0 = $_[4];                # elevation before in m
    my $h1 = $_[5];                # elevation after  in m
    my $default_ele = 500;         # default elevation in m assumed for calculating density
    if ($h0 eq "" || $h1 eq "" ) {
        $h0 = $h1 = $default_ele;
        warning("missing elevation information for computing energy, at least at $t") unless $energy_missing_ele;
        $energy_missing_ele = 1;
    }
    my $dh =  $h1 - $h0;           # elevation difference, or 0 if $default_ele used
    my $h  = ( $h0 + $h1 ) / 2;    # average elevation, used for air density
    my $v0 = $_[6];                # speed before in m/s
    my $v1 = $_[7];                # speed after  in m/s
    my $default_spd = 0;           # default speed in m/s assumed for calculating acceleration and air drag
    if ($v0 eq "" || $v1 eq "") {
        $v0 = $v1 = $default_spd;
        warning("missing speed information for computing energy, at least at $t") if $energy_missing_spd < 2;
        $energy_missing_spd++;
    }
    my $v  = ( $v0 + $v1 ) / 2;    # average speed, used for air drag, assumed with no wind (i.e., calm air)
    my $g = 9.81;                  # gravity constant in m/(s^2)

# values and formulas adapted from https://www.sheldonbrown.com/rinard/aero/formulas.html
    my $m = $weight;               # total mass including vehicle and rider in kg
    my $cr = 0.003;                # coefficient of rolling friction for racing bike      - adapt
    my $cdA = 0.39;                # coefficient of wind resistance * frontal area in m^2 - adapt
    my $r = 1.2;                   # air density on average weather (20 °C) at sea level in kg/(m^3)
    my $density = $r - ( 0.55 * $r ) * $h / 5000; # roughly corrected air density depending on elevation

    # energy components and their sum along the distance $d in Joule
    my $roll  = $cr * $m * $g * $d;
    my $slope = $m * $g * $dh;
    my $accel = $m / 2 * ( $v1 * $v1 - $v0 * $v0 );
    my $drag  = $density * $cdA / 2 * $v * $v * $d;
    my $sum   = $roll + $slope + $accel + $drag;

    ## my $debug_inputs = "dt=" . int($dt) . " d=" . int($d) . " dh=" . int($dh) . " v0=" . int($v0) . " v1=" . int($v1);
    ## my $debug_outputs = "roll:" . int($roll) . " + slope:" . int($slope) . " + accel:" . int($accel) . " + drag:" . int($drag) . " = sum:" . int($sum);
    ## debug "energy @ time=$t  $debug_inputs   =>   $debug_outputs";

    return $sum;
}

sub push_phase {
    my $start_index    = $_[0];
    my $end_index      = $_[1];
    my $sec1           = $SEC[$start_index];
    my $sec2           = $SEC[$end_index];
    my $duration       = -1;
    my $diff_ele       = $ELE[$end_index] - $ELE[$start_index];
    my $dist           = 0;
    my $rate           = 0;
    my $spd            = 0;
    my $max_rate       = 0;
    my $max_rate_index = 0;
    my $max_spd        = 0;
    my $max_spd_index  = 0;

    for ( my $i = $start_index + 1 ; $i <= $end_index ; $i++ ) {
        $dist += $DIST[$i];
        $rate = $RATE[$i];
        $spd  = $SPD[$i];
        ( $max_rate, $max_rate_index ) = ( $rate, $i ) if $rate ne "" && ( $diff_ele >= 0 ? $rate > $max_rate : $rate < $max_rate );
        ( $max_spd , $max_spd_index  ) = ( $spd , $i ) if $spd ne "" && $spd > $max_spd;
    }
    my $avg_spd  = 0;
    my $avg_rate = 0;
    if ( $sec1 && $sec2 && $sec2 > $sec1 ) {
        $duration = $sec2 - $sec1;
        $avg_spd  = $dist / $duration;
        $avg_rate = 3600 * $diff_ele / $duration;
    }
    push @PHASE_DURATION,      $duration;
    push @PHASE_DIFF,          $diff_ele;
    push @PHASE_DIST,          $dist;
    push @PHASE_SPD,           $avg_spd;
    push @PHASE_RATE,          $avg_rate;
    push @PHASE_MAXSPD_INDEX,  $max_spd_index;
    push @PHASE_MAXRATE_INDEX, $max_rate_index;
    push @PHASE_END_INDEX,     $end_index;
}

for( my $rate, my $spd, my $direction,
     my $prev_turn_index, my $prev_turn_ele, my $prev_turn_sec,
     my $local_max_index = 0, my $local_min_index = 0,
     my $local_max_sec = 0, my $local_min_sec = 0,
     my $local_max_ele = 0, my $local_min_ele = 0,
     my $i = 0 ; $i < $#TIM + 1 ; $i++ ) {
    if ( $i <= $#TIM ) {
        ( $lat, $lon, $ele, $tim, $sec, $spd ) =
          ( $LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i], $SPD[$i] );
    }
    else {
        $ele = $prev_turn_ele;
    }
    if ( $SEG[$i] )
    { # (re-)start climb phase recognition on track segment start (including: at $i == 0)
        $direction       = 0;
        $prev_turn_ele   = $local_max_ele   = $local_min_ele = "";
    }
    if ($ele ne "") {
        ( $prev_turn_ele, $prev_turn_index ) = ( $ele, $i ) if ( $prev_turn_ele eq "" );
        ( $local_max_ele, $local_max_index ) = ( $ele, $i ) if $direction >= 0
            && ( $local_max_ele eq "" || $ele > $local_max_ele );
        ( $local_min_ele, $local_min_index ) = ( $ele, $i ) if $direction <= 0
            && ( $local_min_ele eq "" || $ele < $local_min_ele );
    }
    if ( !$SEG[$i] && $ele ne "" ) {    # not at segment start
      check_next:
        $prev_turn_sec = $SEC[$prev_turn_index];
        $local_max_sec = $SEC[$local_max_index];
        $local_min_sec = $SEC[$local_min_index];
        my $seg_end       = $i == $#TIM || $SEG[ $i + 1 ];
        if ( $direction >= 0 && $local_max_index > $prev_turn_index
             && ( $ele <= $local_max_ele -ELE_THRESHOLD || $seg_end ) )
        {    # when actually starting going down, or at end
            my $diff_ele = $local_max_ele - $prev_turn_ele;
            if ( $diff_ele >= ELE_THRESHOLD ) {
                if ($phases && $diff_ele >= $PHASES_REPORT_THRESHOLD) {
                    push_phase($prev_turn_index, $local_max_index);
                } else {
                    $ascent__phases_suppressed++;
                }
                $sum__ascent  += $diff_ele;
                $time__ascent += $local_max_sec - $prev_turn_sec;
                $last_gain_index = $local_max_index if $ele ne "";
            }
            ( $prev_turn_ele, $prev_turn_index ) = ( $local_max_ele, $local_max_index );
            ( $local_min_ele, $local_min_index ) = ( $ele, $i );
            $direction = -1;
            goto check_next;
        }
        elsif ($direction <= 0 && $local_min_index > $prev_turn_index
            && ( $ele >= $local_min_ele + ELE_THRESHOLD || $seg_end ) )
        {    # when actually starting going up, or at end
            my $diff_ele = $local_min_ele - $prev_turn_ele;
            if ( -$diff_ele >= ELE_THRESHOLD ) {
                if ($phases && -$diff_ele >= $PHASES_REPORT_THRESHOLD) {
                    push_phase($prev_turn_index, $local_min_index);
                } else {
                    $descent_phases_suppressed++;
                }
                $sum_descent  += $diff_ele;
                $time_descent += $local_min_sec - $prev_turn_sec;
                $last_loss_index = $local_min_index if $ele ne "";
            }
            ( $prev_turn_ele, $prev_turn_index ) =
              ( $local_min_ele, $local_min_index );
            ( $local_max_ele, $local_max_index ) = ( $ele, $i );
            $direction = 1;
            goto check_next;
        }
    }
    if ( $i <= $#TIM ) {
        ( my $diff_ele_unused, my $timediff, $rate, my $dis, $spd, my $acc_unused ) =
          $SEG[$i] ? ( "", "", "", 0, "", "" ) : calc_diffs();
        $sum_dis += $dis;
        if ( $SPD[$i] eq "" && $spd ne "") # set calculated speed if recorded speed is not available
        {
            $SPD[$i] = $spd;
            $FLG[$i] |= CALCULATED_SPEED;
        }
        $spd = $SPD[$i];
        push @DIST, $dis;
        push @RATE, $rate;
        if ( $spd ne "" && $timediff ne "" && 3.6 * $spd >= MIN_SPEED_MOVING ) {
            $sum_timediff_mov += $timediff;
        }
        if ( $weight && !$SEG[$i] ) { # not at segment start
            my $tim_start = $TIM[ $i - 1 ];
            $tim_start = "<unknown time>" if $tim_start eq ""; # TODO improve, using index
            $tim_start =~ s/(:\d\d)(\.\d+)/$1/;    # strip fractional seconds
            my $start_sec = $#TIM < 0 ? 0 : $SEC[0];
            $sum_energy += energy($tim_start,
                                  $prev_sec - $start_sec,
                                  $sec - $start_sec,
                                  $dis, $prev_ele, $ele,
                                  $prev_spd, $spd);
        }
    }
    $min_lat = $lat if $i == 0 || $min_lat > $lat;
    $max_lat = $lat if $i == 0 || $max_lat < $lat;
    $min_lon = $lon if $i == 0 || $min_lon > $lon;
    $max_lon = $lon if $i == 0 || $max_lon < $lon;
    $max_sec = $sec if            $max_sec < $sec; # may be 0
    ( $min_ele , $min_ele_index  ) = ( $ele           , $i ) if $ele  ne "" && ( $min_ele eq "" || $min_ele  >  $ele  );
    ( $max_ele , $max_ele_index  ) = ( $ele           , $i ) if $ele  ne "" && ( $max_ele eq "" || $max_ele  <  $ele  );
    ( $max_gain, $max_gain_index ) = ( max( $rate, 0 ), $i ) if $rate ne "" && (                   $max_gain <  $rate );
    ( $max_loss, $max_loss_index ) = ( min( $rate, 0 ), $i ) if $rate ne "" && (                  -$max_loss < -$rate );
    ( $max_spd , $max_spd_index  ) = ( $spd           , $i ) if $spd  ne "" && (                   $max_spd  <  $spd  );

    if ( $i < $#TIM ) {
        ( $prev_lat, $prev_lon, $prev_ele, $prev_sec, $prev_spd ) =
          ( $lat, $lon, $ele, $sec, $spd );
    }
}
$max_speed = $max_spd if $max_speed < $max_spd;
$avg_spd   = $sum_timediff_mov ? $sum_dis / $sum_timediff_mov : 0;

#$sec_diff = $SEC[$max_ele_index] - $SEC[$min_ele_index];
#$avg_gain = $sec_diff != 0 ? ($max_ele - $min_ele) / $sec_diff * 3600 : 0;


## optional elevation correction by geoid height

sub neg_geoid_height {    # potentially $updates $found_corr and $ele_corr
    my $lat = $_[0];
    my $lon = $_[1];
    return $ele_corr if !GEOID_ELE_CORRECTION;
    ( my $fh, my $tmp_GeoidEval ) = tempfile();
    system "wget --quiet -O $tmp_GeoidEval "
      . "http://geographiclib.sourceforge.net/cgi-bin/GeoidEval?input=$lat+$lon";
    open G, $tmp_GeoidEval;
    while (<G>) {
        if (m#EGM84</a>\s*=\s*<font.*?>(-?\d+\.?\d*)</font>#i) {
            $found_corr = 1;
            $ele_corr   = -$1;
        }
    }
    close G;
    if ($found_corr) {
        info_trkpt( "   at    ", " geoid height is $ele_corr m" );
    }
    else {
        warn_trkpt( "at    ", " geoid height is assumed $ele_corr m" );
    }
    return $ele_corr;
}

sub linear_ele_correction {
    return 0;                                   # linear correction not wanted
    my $sec  = $_[0];
    my $sec1 = 1296543617;                      #start time
    my $sec2 = 1296569335;                      #end   time
    return 0 unless ( $sec1 <= $sec && $sec <= $sec2 );   # linear correction not in scope
    my $ele1 = 4720 - 4677;                     #actual and wanted start value
    my $ele2 = 1925 - 1635;                     #actual and wanted end   value
    return
      int( ( $sec - $sec1 ) / ( $sec2 - $sec1 ) * ( $ele2 - $ele1 ) + $ele1 );
}

sub correct_ele {    # may update $ele_corr; uses $ele_corr
    my $j = $_[0];    # index of waypoint if >= 0
    my $i = $_[1];    # otherwise, index of trackpoint or < 0 for none
    return "" if $j < 0 && $i < 0;
    my ( $lat, $lon, $ele, $sec ) =
      $j >= 0
      ? ( $WLAT[$j], $WLON[$j], $WELE[$j], $WSEC[$j] )
      : ( $LAT[$i], $LON[$i], $ELE[$i], $SEC[$i] );
    return "" if $ele eq "";
    $ele_corr = neg_geoid_height( $lat, $lon ) if ( $j >= 0 || $i == 0 || $SEC[ $i - 1 ] ) ;
    # do expensive operation only at specific points or beginning of track segment
    if ( $ele_corr && $ele ne "" ) {
        $ele += $ele_corr + linear_ele_correction($sec);
    }
    return $ele;
}

## prepare output header

# TODO make below decls local
#must be done before interpolating, which may shift indexes
my $Min_lat     = sprintf LAT_PRECISION, $min_lat;
my $Min_lon     = sprintf LON_PRECISION, $min_lon;
my $Max_lat     = sprintf LAT_PRECISION, $max_lat;
my $Max_lon     = sprintf LON_PRECISION, $max_lon;
my $Min_ele     = sprintf ELE_PRECISION, correct_ele( -1, $min_ele_index ); # may be ""
my $Max_ele     = sprintf ELE_PRECISION, correct_ele( -1, $max_ele_index ); # may be ""
my $Sum__ascent = sprintf DIF_PRECISION, $sum__ascent;
my $Sum_descent = sprintf DIF_PRECISION, $sum_descent;
   $Sum_descent =~ s/\+/-/ if !$sum_descent;
my $Max_gain = sprintf RAT_PRECISION, $max_gain;
my $Max_loss = sprintf RAT_PRECISION, $max_loss;
   $Max_loss =~ s/\+/-/ if !$max_loss;

my $avg__ascent_rate = $time__ascent ? 3600 * $sum__ascent / $time__ascent : 0;
my $avg_descent_rate = $time_descent ? 3600 * $sum_descent / $time_descent : 0;
#my $Avg_gain=sprintf RAT_PRECISION, $avg_gain;
my $Avg__ascent_rate = sprintf RAT_PRECISION, $avg__ascent_rate;
my $Avg_descent_rate = sprintf RAT_PRECISION, $avg_descent_rate;
$Avg_descent_rate =~ s/\+/-/ if !$avg_descent_rate;
my $Sum_dis    = sprintf "%" . DIS_PRECISION, $sum_dis / 1000;
my $Sum_energy = sprintf "%.0f", $sum_energy / 1000 if $weight;
my $Avg_spd    = spd_string($avg_spd);
   $Avg_spd =~ s/^\s+//;
my $Sum_timediff_mov = timediff_string($sum_timediff_mov);
   $Sum_timediff_mov =~ s/^\s+//;

$HEAD =~ s/(<gpx )/$1creator="GPXConv" /
  unless $HEAD =~ m/<gpx.*? creator\s*=.*?>/;
$HEAD =~ s/(<gpx )/$1version="1.1" / unless $HEAD =~ m/<gpx.*? version\s*=.*?>/;
$HEAD =~ s|(<gpx )|$1xmlns:x="http://www.garmin.com/xmlschemas/TrackPointExtension/v2" |;

# http://docstore.mik.ua/orelly/perl/cookbook/ch06_07.htm match multiple lines with 's' option
if ($HEAD =~ m|(\r?\n?[ \t]*)</metadata>|s) { # TODO insert metadata if not present
    my $indent = $1;
    $indent .= ( $indent =~ m/ $/ ? '    ' : "\t" );
    if ( $min_tim ne "" ) {
        $HEAD =~ s|\r?\n?[ \t]*<time>.*?</time>||sg;   # remove any pre-existing time entry
        $HEAD =~ s|(\r?\n?[ \t]*</metadata>)|$indent<time>$min_tim</time>$1|s; # add new time
    }
    my $bounds = '<bounds'
      .  ' minlat="' . $Min_lat
      . '" minlon="' . $Min_lon
      . '" maxlat="' . $Max_lat
      . '" maxlon="' . $Max_lon . '"/>';
    $HEAD =~ s|\r?\n?[ \t]*<bounds .*?/>||sg;                # remove any pre-existing bounds entry
    $HEAD =~ s|(\r?\n?[ \t]*</metadata>)|$indent$bounds$1|s; # add new bounds
}
#$speed_extension = '<xsd:element name="speed" type="xsd:decimal" minOccurs="0"><xsd:annotation><xsd:documentation>The current speed relative to the previous point, in meters per second</xsd:documentation></xsd:annotation></xsd:element>';
#$HEAD =~ s|(( )*</metadata>)|$2$2<extensions>$speed_extension</extensions>\n$1|s if $speed_extension ne ""; # add declaration for speed extension
$HEAD =~ s/\n?\n *(<trk>)/\n$1/g; # remove any double empty line (after metadata) before trk
$HEAD =~ s/ *$//;

sub wpt {
    my $j = $_[0];    # index of waypoint if >= 0
    my $i = $_[1];    # otherwise, index of trackpoint or < 0 for no wpt
    my $n = $_[2];    # text to be attributed to trackpoint
    return "" if $j < 0 && $i < 0;
    if ( $j < 0 ) {
        $n =~ s/\n/; /g;
        $n =~ s/; $//;
        $n =~ s/\s+/ /g;
    }
    my ( $lat, $lon, $tim ) = $j >= 0
      ? ( $WLAT[$j], $WLON[$j], $WTIM[$j] )
      : ( $LAT[$i], $LON[$i], $TIM[$i] );
    $tim =~ s/(:\d\d)(\.\d+)/$1/;    # strip fractional seconds
    my $ele  = correct_ele( $j, $i );
    my $name_or_orig_text = $j >= 0 ? $WTXT[$j] : $n eq "" ? "" : "<name>[$n]</name>";
    return '<wpt lat="' . ( sprintf LAT_PRECISION, $lat ) .
         '" ' . 'lon="' . ( sprintf LON_PRECISION, $lon ) . '">'
        . ( $ele eq "" ? "     " . (" " x $ele_prec_len ) . "      "
            : "<ele>" . ele_string( $ele_prec_len, int($ele) ) . "</ele>" )
        . ( $tim eq "" ? "      " . "                    " . "       "
            : "<time>$tim</time>" )
      . $name_or_orig_text . "</wpt>\n";
}

sub point {
    my $i = $_[0];
    my $n = $_[1];
    return "" if $i < 0;
    my $ele      = correct_ele( -1, $i );
    my $ele_text = $ele eq "" ? "" : ",ele";
    my $ele_val =
      $ele eq "" ? "" : "," . ele_string( $ele_prec_len, int($ele) );
    my $time_val = $TIM[$i] eq "" ? "" : " time = $TIM[$i]";
    $time_val =~ s/(:\d\d)(\.\d+)/$1/;    # strip fractional seconds
    return "At lat,lon$ele_text = "
      . ( sprintf LAT_PRECISION, $LAT[$i] ) . ","
      . ( sprintf LON_PRECISION, $LON[$i] )
      . $ele_val . $time_val . ": $n\n";
}

sub phase_text {
    my $i = $_[0] + 1;
    my $d = $i % 10;
    return ( " " x max( 0, length( $#PHASE_END_INDEX + 1 ) - length($i) ) )
        . $i .
        ( 11 <= $i && $i <= 13 ? "th"
        : $d == 1 ? "st"
        : $d == 2 ? "nd"
        : $d == 3 ? "rd"
        :           "th" )
      . " ";
}

my $wpts = "";
for ( my $j = 0 ; $j <= $#WTIM ; $j++ ) {
    $wpts .= wpt( $j, -1, "" );
}
my $phase_wpts   = "";
my $phase_points = "";
for ( my $i = 0 ; $i <= $#PHASE_END_INDEX ; $i++ ) {
    my $type = $PHASE_DIFF[$i] >= 0 ? "ascent " : "descent";
    my $Len = phase_text($i) . "$type   = " . ( sprintf DIF_PRECISION, $PHASE_DIFF[$i] ) . "  m;   "
      . "distance   =" . ( $PHASE_DIST[$i] / 1000 >= 10 ? "" : " " )
      . ( sprintf "%" . DIS_PRECISION, $PHASE_DIST[$i] / 1000 ) . " km";
    my $duration = $PHASE_DURATION[$i];
    $Len .= "; duration = " . timediff_string($duration) if $duration >= 0;
    my $max_spd_index = $PHASE_MAXSPD_INDEX[$i];
    my $Spd = phase_text($i)
        . "max speed =  " . (sprintf SPD_PRECISION2, 3.6 * $SPD[$max_spd_index]) . " km/h; "
        . "avg speed  = " . (sprintf SPD_PRECISION2, 3.6 * $PHASE_SPD[$i]      ) . " km/h"
        if $max_spd_index;
    my $max_rate_index = $PHASE_MAXRATE_INDEX[$i];
    my $Rate = phase_text($i)
        . "max rate  =" . (sprintf RAT_PRECISION2, $RATE[$max_rate_index]) . "  m/h; "
        . "avg rate   =" . (sprintf RAT_PRECISION, $PHASE_RATE[$i]       ) . "  m/h"
        if $max_rate_index;
    $phase_wpts .= wpt(-1, $PHASE_END_INDEX    [$i], $Len );
    $phase_wpts .= wpt(-1, $PHASE_MAXSPD_INDEX [$i], $Spd ) if $max_spd_index;
    $phase_wpts .= wpt(-1, $PHASE_MAXRATE_INDEX[$i], $Rate) if $max_rate_index;
    $phase_points .= point($PHASE_END_INDEX    [$i], $Len );
    $phase_points .= point($PHASE_MAXSPD_INDEX [$i], $Spd ) if $max_spd_index;
    $phase_points .= point($PHASE_MAXRATE_INDEX[$i], $Rate) if $max_rate_index;
}
my $Max_spd      = spd_string( $SPD[$max_spd_index] );
my $Max_gain_spd = sprintf SPD_PRECISION, 3.6 * $SPD[$max_gain_index];
my $Max_loss_spd = sprintf SPD_PRECISION, 3.6 * $SPD[$max_loss_index];
while (substr( $Max_gain_spd, 0, 1 ) eq " "
    && substr( $Max_loss_spd, 0, 1 ) eq " " )
{
    $Max_gain_spd = substr( $Max_gain_spd, 1 );
    $Max_loss_spd = substr( $Max_loss_spd, 1 );
}
my $max_spd_text     = "max speed        =    $Max_spd km/h";
my $min_ele_text     = "min altitude     = $Min_ele m";
my $max_ele_text     = "max altitude     = $Max_ele m";
my $sum__ascent_text = "total  ascent    = $Sum__ascent m";
my $sum_descent_text = "total descent    = $Sum_descent m";
my $avg__ascent_text = "avg rate  = $Avg__ascent_rate m/h";
my $avg_descent_text = "avg rate  = $Avg_descent_rate m/h";
my $max_gain_text    = "max  ascent rate = $Max_gain m/h at $Max_gain_spd km/h";
my $max_loss_text    = "max descent rate = $Max_loss m/h at $Max_loss_spd km/h";

#average ".($avg_gain >= 0 ?  "ascent rate between lowest and highest"
#	                  : "descent rate between highest and lowest")." point = $Avg_gain m/h

my $final_text = "\n";
$final_text .= "total distance       = $Sum_dis km\n";
$final_text .= "total moving time    = $Sum_timediff_mov\n"  if $sum_timediff_mov;
$final_text .= "total biking energy  = $Sum_energy kJ\n"     if $sum_timediff_mov && $weight;
$final_text .= "average moving speed = $Avg_spd km/h\n"      if $avg_spd;
$final_text .= "$num_pruned_wpts waypoints"    . " pruned\n" if $num_pruned_wpts;
$final_text .= "$num_auto_wpts automatic waypoints pruned\n" if $num_auto_wpts;
$final_text .= "$num_ignored_hdrs track headers"." ignored (apart from any included waypoints)\n" if $num_ignored_hdrs;
$final_text .= "$num_pruned_exts extensions"   . " pruned\n" if $num_pruned_exts;    # not counting nested ones
$final_text .= "$num_pruned_descs descriptions". " pruned\n" if $num_pruned_descs;   # not counting nested ones
$final_text .= "$num_pruned_links links"       . " pruned\n" if $num_pruned_links;   # not counting nested ones
$final_text .= "$num_ignored_before points with time before " . epoch_to_str($begin_sec)  . " filtered out\n" if $begin_sec;
$final_text .= "$num_ignored_after points with time after  "  . epoch_to_str($end_sec  )  . " filtered out\n" if $end_sec;
$final_text .= "$num_elem_above points with $max_elem above " . $max_elem_limit           . " filtered out\n" if $max_elem;
$final_text .= "$num_elem_below points with $min_elem below " . $min_elem_limit           . " filtered out\n" if $min_elem;
$final_text .= "$num_ext_above extensions with name '$max_ext' and value above $max_ext_limit pruned\n" if $max_ext;
$final_text .= "$num_ext_below extensions with name '$min_ext' and value below $min_ext_limit pruned\n" if $min_ext;
$final_text .= "elevation ". ( !GEOID_ELE_CORRECTION ? "not corrected" :
                               "corrected by " . ( $found_corr ? "last retrieved" : "assumed" ) . " geoid height = $ele_corr m") . "\n";
$final_text .= ($smoothing ? "within each track, points that are at most ${ \SMOOTHING_MAX_GAP } seconds apart have been smoothened\n" : "" );

$wpts .=
    wpt( -1, 0, "start" )
  . wpt( -1, $max_spd_index,   $max_spd_text )
  . wpt( -1, $min_ele_index,   $min_ele_text )
  . wpt( -1, $max_ele_index,   $max_ele_text )
  . wpt( -1, $last_gain_index, "$sum__ascent_text; $avg__ascent_text" )
  . wpt( -1, $last_loss_index, "$sum_descent_text; $avg_descent_text" )
  . wpt( -1, $max_gain_index,  $max_gain_text )
  . wpt( -1, $max_loss_index,  $max_loss_text )
  . $phase_wpts
  . wpt( -1, $#TIM, "end$final_text" );
$HEAD =~ s/(<trk>)/$wpts$1/s;    # prepend collected and computed waypoints to track

my $stats = "GPXConv statistics (not including sanitized trackpoints nor periods between segments)\n"
  . point( 0,                "start" )
  . point( $max_spd_index,   $max_spd_text )
  . point( $min_ele_index,   $min_ele_text )
  . point( $max_ele_index,   $max_ele_text )
  . point( $last_gain_index, "$sum__ascent_text; $avg__ascent_text" )
  . point( $last_loss_index, "$sum_descent_text; $avg_descent_text" )
  . point( $max_gain_index,  $max_gain_text )
  . point( $max_loss_index,  $max_loss_text )
  . $phase_points
  . point( $#TIM, "end" )
  .($phases && $PHASES_REPORT_THRESHOLD > ELE_THRESHOLD ?
    "$ascent__phases_suppressed ascent phases and $descent_phases_suppressed descent phases " .
    "not reported because they are below the threshold of +/-$PHASES_REPORT_THRESHOLD m\n" : "")
    . substr( $final_text, 1 ) .
"GPXConv statistics end";

print_line(""); # empty line
info($stats);
$HEAD =~
  s|(<trk>\s*(<name>.*?</name>)?)|$1\n<cmt></cmt>|s # add preliminarily empty comment in track
  unless $HEAD =~ m/<trk>.*?<cmt>/s;                # if not already existing
$HEAD =~ s/(<trk>.*?<cmt>)/$1\n$stats\n/s;    # prepend stats to track comment

## fill long time gaps as far as needed with intermediate points by linear interpolation

for ( my $i = 0 ; INTERPOLATE_POINTS && $i <= $#TIM ; $i++ ) {
    ( $lat, $lon, $ele, $tim, $sec, $spd ) =
      ( $LAT[$i], $LON[$i], $ELE[$i], $TIM[$i], $SEC[$i], $SPD[$i] ); # needed also for print_trkpt
    ## debug "checking gap at point $i with lat=$lat lon=$lon ele=$ele tim=$tim sec=$sec spd=$spd";
    my $diff_time = $i > 0 && $sec && $SEC[ $i - 1 ] ? int( $sec - $SEC[ $i - 1 ] ) : 0;
    if ( $diff_time > INTERPOLATION_MAX_GAP ) { # implies $i>0
        my $n_spans = int( $diff_time / INTERPOLATION_MAX_GAP ) +
          ( $diff_time % INTERPOLATION_MAX_GAP == 0 ? 0 : 1 );
        my $time_inc = $diff_time / $n_spans;    # 0 < $time_inc <= INTERPOLATION_MAX_GAP
        my $dis = distance_curr( $prev_lat, $prev_lon, $prev_ele );
        # re-calculating distance since coordinates may have been filled in or smoothened
        my $Dis      = sprintf "%4" . DIS_PRECISION, $dis / 1000;
        my $dis_inc  = $dis / $n_spans;
        my $N_points = $n_spans - 1;
        my $s        = $N_points > 1 ? "s" : "";
        warn_trkpt( "before", "  long time gap = ". timediff_string($diff_time) .
                    " over a distance of " . $Dis . " km" . "; inserting $N_points point$s" );
        # by interpolation every ". (sprintf SEC_PRECISION, $time_inc) ." seconds");
        my $seg = $SEG[$i]; # if gap was at segment start, have segment starts just before and after interpolated points
        my $start = $seg ? 0 : 1;
        my $n_end = $n_spans - ( $seg ? 0 : 1 );
        my $flags = $FLG[$i];

        # move info on previous ignored points over to first interpolated point
        my $ign = $IGN[$i];
        $IGN[$i] = 0;
        $DIS[$i] = $dis_inc;

# insert equidistant interpolated points,
# plus in case of new segment: an extra trkpt that equals the end of the previous segment and and one the equals the start of the next segment
        my $p = $i - 1;                 # previous index
        my $t = $seg ? 0 : $time_inc;
        for ( my $n = $start ; $n <= $n_end ; $n++ ) {
            splice @IGN, $i, 0, $n == $start ? $ign : 0;

# if $n == 0, here is a new segment start, with contents duplicated from segment end just before interpolation
# if $n == $n_spans, here is a new segment end, with contents duplicated from segment start just after interpolation
            splice @SEG, $i, 0, $n == 0;
            splice @FLG, $i, 0, $n == 0 ? $FLG[$p] | DUPLICATED_POINT
                : $n == $n_spans ? $flags | DUPLICATED_POINT : INTERPOLATED_POINT;
            splice @LAT, $i, 0, $LAT[$p] + ( $lat - $LAT[$p] ) * $t / $diff_time;
            splice @LON, $i, 0, $LON[$p] + ( $lon - $LON[$p] ) * $t / $diff_time;
            splice @ELE, $i, 0, (   $ELE[$p] ne "" && $ele ne ""
                ? $ELE[$p] + ( $ele - $ELE[$p] ) * $t / $diff_time : "" );
            splice @TIM, $i, 0, epoch_to_str( $SEC[$p] + $t );
            splice @SEC, $i, 0, $SEC[$p] + $t;
            splice @DIS, $i, 0, $dis_inc;
            splice @SPD, $i, 0, $spd;
            splice @EXT, $i, 0, "";
            $i++;
            $t += $time_inc;
        }
    }
    ( $prev_lat, $prev_lon, $prev_ele, $prev_sec, $prev_spd ) =
      ( $lat, $lon, $ele, $sec, $spd );
}

## finally write output

use constant SPEED  => "<speed>";     # "<x:TrackPointExtension><x:speed>"
use constant _SPEED => "</speed>";    # </x:speed></x:TrackPointExtension>"
print $out $HEAD;                     # includes <gpx> <trk> <trkseg>
for ( my $i = 0 ; $i <= $#TIM ; $i++ ) {
    ( $tim, $spd ) = ( $TIM[$i], $SPD[$i] );
    $tim =~ s/(:\d\d)(\.\d+)/$1/;     # strip fractional seconds
    print $out '<trkpt lat="' . ( sprintf LAT_PRECISION, $LAT[$i] )
      . '" lon="' . ( sprintf LON_PRECISION, $LON[$i] ) . '">';
    print $out "<ele>" . ele_string( $ele_prec_len, int( correct_ele( -1, $i ) ) ) . "</ele>" if $ELE[$i] ne "";
    print $out "<time>$tim</time>" if $tim;
    print $out "<cmt>$IGN[$i] previous point" . ( $IGN[$i] == 1 ? "" : "s" ) . " ignored</cmt>"
        if $IGN[$i] && !DISABLE_TRKPT_CMT;
    if (!DISABLE_TRKPT_SRC) {
        my $src = $FLG[$i] & INTERPOLATED_POINT ? "bridging time gap: interpolated point"
            : $FLG[$i] & DUPLICATED_POINT ? "bridging time gap: duplicated point "
            . ($i > 0 && ($FLG[$i - 1] & INTERPOLATED_POINT) != 0 ? "after" : "before") : "";
        # cannot place interpolation info in <trkseg> element because it cannot hold a comment
        $src .= ( $src eq "" ? "" : "; " ) . "interpolated elevation" if $FLG[$i] & INTERPOLATED_ELE;
        $src .= ( $src eq "" ? "" : "; " ) . "interpolated time"      if $FLG[$i] & INTERPOLATED_TIM;
        $src .= ( $src eq "" ? "" : "; " ) . "substituted elevation"  if $FLG[$i] & SUBSTITUTED_ELE;
        $src .= ( $src eq "" ? "" : "; " ) . "substituted time"       if $FLG[$i] & SUBSTITUTED_TIM;
        $src .= ( $src eq "" ? "" : "; " ) . "calculated speed"       if $FLG[$i] & CALCULATED_SPEED && INCLUDE_CALC_SPEED;
        print $out "<src>$src</src>" if $src ne "";
    }
    if ( ( $FLG[$i] & INTERPOLATED_POINT ) != 0 && !DISABLE_TRKPT_FIX) {
        my $fix = "none";   # TODO check
        # was before: my $fix = $flags == 0 ? "": ( $FLG[$i] & ( INTERPOLATED_POINT | INTERPOLATED_TIM | SUBSTITUTED_TIM ) == 0 ? "2d" : "none" );
        print $out "<fix>$fix</fix>";
    }
    my $exts = $EXT[$i];
    if ( $spd ne "" && ( !( $FLG[$i] & CALCULATED_SPEED ) || INCLUDE_CALC_SPEED ) ) {
        my $spdstr = SPEED . spd_string($spd) . _SPEED;
        if ( $exts eq "" ) {
            $exts = "<extensions>$spdstr</extensions>";
        } else {
            $exts =~ s#(<extensions>)#$1$spdstr#s;
        }
    }
    print $out $exts;
    print $out "</trkpt>\n";
    print $out "</trkseg>\n<trkseg>\n" if $SEG[ $i + 1 ] && $i < $#TIM;
}
print $out "</trkseg>\n</trk>\n</gpx>\n";

close $out;   # does not hurt in case STDOUT
exit 0;
